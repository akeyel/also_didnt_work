{
    "contents" : "#Helper functions for SpatialDemography.  See spatialdemography package license & details\n#Originally by J. Gerstenlauer\n#Updated by Sasha Keyel, skeyel@gmail.com\n\n    \n# Functions from myr.r version 1.0.1\n    #as.num = function to shorten as.numeric(as.character()) command\n    #Digit - add leading zeros to allow proper sorting\n    #force.hibernate = hibernate the computer (force means it will still work if the machine is locked)\n    #gettime = function to get the time from the code in a more intuitive manner.\n    #listtotext - convert a list to text NOTE: THIS FUNCTION ALSO APPEARS IN MULTIRICH\n    #sample.fixed = a function to fix R's sample function to remove inconsistent behavior\n\n# Functions based on I. Stott's code\n    #is.irreducible\n    #is.ergodic\n\n# Index to broken functions\n    #LocalTransitionMatrix = function for computing the local transition matrices, for eigenvector analysis\n    #CalcA = calculate the overall matrix properties - may be useful as a diagnostic tool.  Not currently in the model\n    #CalcEigen = function to compute Eigen analyses - needs updating!\n    #CalcPerturbation = calculate perturbation analysis for the matrix model\n    #EigenVis = function to visualize the eigenvalues on the landscape\n    #DispersalVis = function to visualize dispersal on the landscape\n\n#' MetaComeSE (package)\n#' \n#' Package to run a spatially explicit, matrix-based metacommunity model\n#'\n#' @details \\tabular{ll}{ %% Note tabular{ll} is tabular{lowercase(LL)} not tabular{11} \n#' Package: \\tab spatialdemography\\cr\n#' Type: \\tab Package\\cr\n#' Version: \\tab 0.10.2\\cr\n#' Date: \\tab 2015-03-12\\cr\n#' License: \\tab GPL-2 (or later)\\cr\n#' }\n#' @author Alexander \"Sasha\" Keyel & Jakob L.K. Gerstenlauer\\cr\n#' Maintainer: Sasha Keyel <skeyel@@gmail.com>\n#'\n#' @template mycitation\n#' @keywords package\n#' @name spatialdemography_package\n#' @docType package\n#' @seealso \\link[spatialdemography]{SpatialDemography}\n#' @import Matrix\nNULL\n\n################ FUNCTIONS FROM MYR.R Version 1.0.1 ######################\n#DD# Think about whether to export these functions - they seem generally useful to me, but are not the focus of the package.\n\n#' As number\n#'\n#' A shortcut to avoid having to always write out as.numeric(as.character(x))\n#'\n#' @param x the thing to be converted to numeric\n#'\nas.num = function(x){\n\n    #check if length of x is > 1\n    if (length(x) == 1){\n        #if so, and x is NA, mark NA\n        if (is.na(x)){\n            out = NA\n        #otherwise\n        }else{\n            #if x is \"NA\", mark as NA\n            if (x == \"NA\"){\n                out = NA\n            #otherwise proceed as normal\n            }else{\n                out = as.numeric(as.character(x))\n                }\n            }\n    #if length x > 1, proceed as normal\n    }else{\n        out = as.numeric(as.character(x))\n        }\n\n    return(out)\n    }\n\n#' Digit\n#'\n#' Digit takes a number and places leading zeros before it if needed to bring\n#' the length of the number up to places. Inputs can be either numeric or\n#' character but must be integers (e.g., \"1\" or 1 are okay, 1.5 is not).\n#' @param number The input number (potentially) in need of leading zeros\n#' @param places The number of places the final number should have.  Needs to be\n#' greater than or equal to one.\n#' @return A number with leading zeros in character format\n#' @note I have written a similar function for Python, but with a different\n#' implementation.\n#' @author Alexander \"Sasha\" Keyel\n#' @examples\n#' Digit(10,3)  #010; one leading zero added\n#' Digit(5,3)   #005; two leading zeros added\n#' Digit(200,3) #200; long enough, no leading zeros added\n#' Digit(2000,3) #2000; no leading zeros, no truncation (places 4 would be better)\n#' @export Digit\nDigit = function(number,places){\n    \n    #Check that Digit is a single number, not a vector\n    if (length(number) > 1){\n        stop(\"Inputs to Digit function must be single numbers, not vectors!\")\n        }\n    \n    #Check that input is an integer, if not, return NA\n    test = as.integer(number)\n    if (test != number){\n        stop(\"Inputs to Digit function must be integers\")\n        }\n        \n    if (places < 1){\n        stop(\"Number of places to round to is less than 1. This is a non-sensical input for this function\")\n        }\n    \n    number = as.character(number) #Convert number to string\n    nlen = nchar(number)\n    #If number is longer than the number of places needed, leave the number unchanged (other than converted to string)\n    #otherwise, continue until number = places\n    while (nlen < places){\n        zro = \"0\"\n        number = sprintf(\"%s%s\",zro,number)\n        nlen = nchar(number)}\n        \n    return(number)\n    }\n\n#Tell the computer to hibernate in a way that will still work if the machine is locked.\n#' Hibernate\n#'\n#' Hibernate the computer.\n#' \n#' Can be used following simulation runs to shut-down the computer.\n#' Hibernate is chosen over shutdown, as this allows direct access to the\n#' current R session (rather than requiring reloading a saved session, where you\n#' can no longer see the commands & have to deal with the changed workspace.\n#' Note that the force option is used, which will cause the computer to\n#' hibernate even if other programs are running, or if the computer is locked.\n#'\nforce.hibernate = function(){\n    shell(\"shutdown -h -f\")\n    }\n\n#' Get Time\n#'\n#' A short function so I don't have to keep writing proc.time()[3]\n#'\ngettime = function(){\n    outtime = proc.time()[3]\n    return(outtime)\n    }\n\n#' List to text\n#' \n#' Take a list (or vector) and convert it to text separated by separator.\n#' Does not work for nested lists\n#'\n#' @param inlist a list to convert to text\n#' @param separator The separator to separate the text\n#'\nlisttotext = function(inlist,separator){\n\n    #Check that there is no nesting in the list structure\n    for (thing in inlist){\n        if (length(thing) > 1){\n            print(\"One or more list elements containied multiple elements.\")\n            print(\"This is not allowed, as it will lead to strange outputs.\")\n            return(NA)\n            }\n        }\n        \n    #Check that separator is input (otherwise it can let a typo through where just a one element list or a separator is given)\n    sep.check = separator #sep.check is not used later.  It is here to make it so R will crash if it is not input.\n\n    #Perform list to text function\n    textout = sprintf(\"%s\",inlist[1])\n    listlen = length(inlist)\n    if (listlen > 1){\n        for (item in inlist[2:listlen]){\n            textout = sprintf(\"%s%s%s\",textout,separator,item)\n            }\n        }\n    return(textout)\n    }\n\n#Default behavior of this function was unacceptable, so I fixed it\n#' Sample (fixed)\n#'\n#' Goal is to correct the default behavior of the \"sample\" function in R.\n#' The default behavior changes if only one sample is needed, but some of my\n#' code depends on consistent behavior.  Consequently, this function avoids\n#' the change in behavior.\n#'\n#' @param x Vector to be sampled\n#' @param size Number of samples to take.  Must be an integer less than x but\n#' greater than zero.\n#' @return A vector of length size sampled from x.  If the length of x is 1,\n#' this returns x.\n#'\nsample.fixed = function(x,size){\n\n    #Require that size be >= 0 (should it just be > 0?)\n    if (size < 0){\n        stop(\"number of samples taken must be zero or greater\")\n        }\n\n    if (length(x) < size){ \n        stop(\"There was an error - more samples were required than values to sample from!\")\n        }\n\n    #Correct the default behavior so that asking for one sample from a vector length 1 gives the element of the vector, instead of drawing from 1:the value of the element.  See documentation\n    if (length(x) == 1){\n        output = x\n        }\n\n    #Otherwise, proceed as normal.\n    if (length(x) != 1){\n        output = sample(x,size)\n        }\n    return(output)\n    \n    }\n\n############## FUNCTIONS FROM CODE SUPPLIED BY IAIN STOTT TO JAKOB GERSTENLAUER.############\n#Permission to use them in SpatialDemography granted on Oct 23, 2014, until popdemo is patched to accept sparseMatrix format\n\n#'1. TEST REDUCIBILITY OF THE MATRIX\n#'\n#' This function tests whether a matrix is reducible or irreducible.\n#' IT WILL ONLY RELIABLY WORK FOR NONNEGATIVE MATRICES (e.g. PPMs).\n#' It works on the basis that for any matrix A, (I+A)^(s-1) where I\n#' is the identity matrix and s is equal to the order of the matrix\n#' is positive (Caswell 2001).  The function returns the condition\n#' \"TRUE: Irreducible\" or \"FALSE: Reducible\".\n#' @param x a square nonnegative matrix\n#' @author Iain Stott, 9.1.2009\nis.irreducible<-function(x){\n\n    #create an object 'order' that is equal to the dimension of x.\n    order=sqrt(length(x))\n    \n    #create an identity matrix of the same size as x\n    identity=diag(order)\n    \n    #create an object 'identityplusx'=I+A\n    identityplusx=identity+x\n    \n    #create a character string for multiplication of I+A and repeat it s-2 times\n    string=rep(\"identityplusx%*%\",order-2)\n    \n    #end the character string so that it now repeats multiplication of I+A s-1 times\n    string=c(string,\"identityplusx\")\n\n    #collapse the character and evaluate it, omitting quotation marks\n    string=paste(string,collapse=\"\")\n    powermatrix=eval(parse(text=noquote(string)))\n\n    #create an object 'minval' that is equal to the smallest entry of the matrix\n    minval=min(powermatrix)\n\n    #if this minimum is greater than 0 (i.e. the matrix is positive), then return\n    #\"TRUE: Irreducible\", if it is not greater than 0 (i.e. the matrix is not positive)\n    #then return \"FALSE: Reducible\", omitting quotation marks.\n    if(minval>0)return(noquote(\"TRUE: Irreducible\"))else(noquote(\"FALSE: Reducible\"))\n    }\n\n#' 2. TEST ERGODICITY OF A MATRIX\n#'\n#' This function will test the ergodicity of a matrix based upon whether its dominant\n#' left eigenvector is positive or not.  A reducible-ergodic matrix has a positive\n#' dominant left eigenvector, where a reducible-nonergodic matrix will contain zeroes\n#' in its dominant left eigenvector.  An irreducible matrix is always ergodic.\n#' NOTE: this function can prove problematic for imprimitive, irreducible matrices or\n#' reducible matrices with imprimitive, irreducible blocks on the diagonal.  The\n#' 'dominant' left eigenvector chosen by R is that with the largest absolute value\n#' (including both real and imaginary components), so that sometimes it chooses a dominant\n#' with imaginary components.  In addition, where a reducible matrix in block-permuted form\n#' contains one or more irreducible, imprimitive blocks on the diagonal, values of zero in\n#' the dominant left eigenvector may actually be calculated by R as small numbers, approximate\n#' to zero.  Hence, for such matrices, R may return a spurious result of the matrix being ergodic\n#' when in fact it is nonergodic.  For this reason, the 'dominant' left eigenvector is also returned\n#' by the function so that it may be checked by eye: if it contains non-zero imaginary components,\n#' or if it contains small numbers that may approximate to zero then further diagnosis may be\n#' required.  The 'blockmatrix' and 'is.primitive' functions can help to\n#' diagnose whether diagonal blocks are imprimitive or not.\n#' @param x a square nonnegative matrix\n#' @author Iain Stott, 29.1.2010\nis.ergodic=function(x){\n    \n    #create an object 'order' that is equal to the dimension of the matrix\n    order=sqrt(length(x))\n    \n    #create an object 'xt' that is the transpose of x\n    xt=t(x)\n    \n    #create an object 'lefteigvec' that is the dominant right eigenvector of xt, hence the dominant\n    #left eigenvector of x\n    lefteigvec=as.matrix(eigen(xt)$vectors[,1])\n    \n    #create an object 'abslefteigvec' that is the modulus of the dominant left eigenvector\n    abslefteigvec=as.matrix(abs(lefteigvec))\n    \n    #create an empty object 'ergodic'\n    ergodic=numeric(1)\n    \n    #if the minimum absolute value of the dominant left eigenvector is >0 then the matrix is\n    #ergodic, otherwise it is nonergodic\n    if(min(abslefteigvec)>0) ergodic= 1 else(ergodic= 0 )\n    \n    #return 'ergodic' and 'lefteigvec'.\n    return(list(ergodic=ergodic,lefteigvec=lefteigvec))\n    }\n\n\n################# SPATIALDEMOGRAPHY FUNCTIONS ###############################\n\n#' Check for required packages\n#'\n#' This function checks that all required packages needed to run SpatialDemography\n#' are present and usable. Packages to check are:\n#' Matrix, multirich, FD, and copula.\n#' spatialdemography may also use lhs and raster, but these are used in exported\n#' functions that contain their own checks.\n#' Hmisc, quantreg & gbm were formerly listed under suggests, but are currently\n#' not part of the code workflow (i.e. they would require an external call to an internal function)\n#' lattice was formerly listed under suggests, but I don't think it was actually used\n#' so it is no longer listed nor is it checked for.are not integrated into the code.\n#'\n#' @param out.metrics A vector of potential metrics to calculate. Those ending in UTC\n#' will require multirich to calculate, and those ending in FRIC will require\n#' FD to calculate. At some point, I need to add in Petchey & Gaston's FD metric.\n#' @param include.copula An entry from the settings file. If null or 0, the copula\n#' package is not required.\n#'\ncheck.packages = function(out.metrics, include.copula){\n\n    missing.pkg = 0\n    \n    if (!require(Matrix)){\n        warning(\"Please install package 'Matrix', install.packages('Matrix')\")\n        missing.pkg = 1\n        }\n    \n    #Check outmetrics if multirich or FD will be required\n    for (item in out.metrics){\n        test = substring(item,nchar(item) - 2,nchar(item))\n        if (test == \"UTC\"){\n            if (!require(multirich)){\n                warning(\"Package multirich must be installed to calculate the specified or default output metrics. Please install package multirich (install.packages('multirich') \")\n                missing.pkg = 1\n                }\n            }\n        if (test == \"FRIC\"){\n            if (!require(FD)){\n                warning(\"Package FD is required to calculate the specified output metrics. Please install package FD (install.packages('FD'))\")\n                missing.pkg = 1\n                }\n            }\n        }\n        \n    if (length(include.copula) > 0){\n        if (include.copula > 0){\n            if (!require(copula)) {\n                warning(\"Please install copula: install.packages('copula')\")\n                missing.pkg = 1\n                }\n            }\n        }\n        \n    if (missing.pkg == 1){ stop(\"One or more required packages is missing. See warnings for details.\") }\n    }\n\n\n#' do.input.rename = Helper function to help with renaming\n#' \n#' Rename input templates with a specified file ending\n#' @param input.path Path for input files\n#' @param to.rename File names to be renamed\n#' @param file.ending The file ending to add/replace the previous file ending\n#'\n#' @export do.input.rename\ndo.input.rename = function(input.path,to.rename,file.ending){\n    \n    inputs = list.files(input.path)\n    \n    for (item in to.rename){\n        old.file = grep(item,inputs,value = T)\n        old.file = sprintf(\"%s%s\",input.path,old.file) #Add path to old.file for proper renaming\n        new.file = sprintf(\"%s%s%s.csv\",input.path,item,file.ending)\n        file.rename(old.file,new.file)\n        }\n\n    }\n\n#' Save Seed\n#'\n#' Simple function to create a seed token, that can later be assigned to .Random.seed\n#' this will allow reproducibility of results, even when pieces of the code are moved around\n#' The downside is that the code will slowly get cluttered with seed tokens, which at some point\n#' will need to be replaced & the test code updated.\n#' But this will forstall that day, and at least ensure that code that passed the test\n#' is being used to replace the test code. And that reassures me greatly.\n#' Thanks to Ben Bolker's answer on Stack Overflow:\n#'  http://stackoverflow.com/questions/13997444/print-the-current-random-seed-so-that-i-can-enter-it-with-set-seed-later\n#' The seed can be restored by doing load(\"SeedToken%s.RData\"), where %s is the seed.id you want to access.\n#'\n#' @param run.id Identifies which test run is being run\n#' @param seed.id Identifies the location where the seed needs saving\nsave.seed = function(run.id, seed.id){\n    my.seed.token = .Random.seed\n    save(\"my.seed.token\", file = sprintf(\"SeedToken%s_%s.RData\", run.id, seed.id) ) #Saves the random seed as a seed token\n    }\n\n#' Load Seed\n#'\n#' Simple function to load a seed token (and ensure that you don't break the normal code while doing so!\n#' WARNING: Output from this function needs to be assigned to .Random.seed with the global assignment operator <<-\n#' OTHERWISE the assignment will be local to the FUNCTION ONLY and will not properly reset the random seed!\n#' @param run.id Identifies which test run is being run\n#' @param seed.id Identifies the location where the seed needs saving\n#' @param testing TRUE/FALSE Indicator for whether a test is being run\nload.seed = function(run.id, seed.id, testing){\n    my.seed.token = .Random.seed\n    if (testing == T){\n        #Set seed to match that obtained after running species locations code to use prior test code for validation\n        seed.token = sprintf(\"SeedToken%s_%s.RData\", run.id, seed.id)\n        load(seed.token) #Adds an object my.seed.token to the function workspace (but not to the global workspace)\n        message(sprintf(\"Seed token %s applied\", seed.token))\n        }\n    return(my.seed.token) # .Random.seed <<- load.seed(run.id, seed.id, testing) #the global assignment operator is VERY important here, and I couldn't figure out a way around using it.\n    }\n\n# Short code used to replace seed tokens so that they would have the my.seed.token object.\n#run.names = c(\"TestRun1\",\"TestRun2\")\n#bits = c(1,2,3)\n#\n#for (rn in run.names){\n#    for (bit in bits){\n#        load(sprintf(\"SeedToken%s_%s.RData\", rn, bit))\n#        save.seed(rn,bit)\n#        }\n#    }\n\n### From Connectance.r\n#' Calculate distances between cells\n#' \n#' Calculates euclidean distance between all cells in a landscape\n#' \n#' @details Designed with a square landscape in mind, but it will work for other configurations\n#' Basically, cells are added by rows, and if there are not enough cells to complete a row, the row is missing some cells.\n#' @param NumPatches Number of cells in the landscape, equal to the extent squared\n#' @param extent Length of one side of the square landscape\n#' @author Jakob Gerstenlauer, with minor modification by A.C. Keyel\n#'\nConnectance<-function(NumPatches,extent){\n\n    #Check that extent is reasonable (i.e., non-negative!)\n    if (extent < 1){\n        stop(\"Extent cannot be less than one.\")\n        }\n        \n    #Figure out how to do warnings - issue warning if landscape is not square\n    if (NumPatches != (extent ^ 2)){\n        stop(\"Landscape must be square\")\n        }\n\n    #create a new matrix containing pairwise distances between cells\n    Distances<-matrix(rep(0.0,NumPatches^2), nrow=NumPatches, ncol=NumPatches)\n\n    #for all patches as origin cells\n    for (Origin in seq(0,NumPatches-1)){\n\n        #for all patches as target cells\n        for (Target in seq(0,NumPatches-1)){\n\n           #only calculate distance if patches are distinct\n           if (! identical (Origin,Target)){\n\n                #calculate the indices of the origin cell\n                xpos<-1 + Origin - floor(Origin / extent) * extent;\n                ypos<-1 + Origin %/% extent;  #The %/% is a modulus. I do not think the semi-colons do anything here\n\n                #calculate the indices of the target cell\n                xposT<-1 + Target - floor(Target / extent) * extent;\n                yposT<-1 + Target %/% extent;\n\n                #the absolute value of the distances in x and y direction\n              \tdx <- xposT-xpos;\n              \tdy <- yposT-ypos;\n\n                #The dispersal matrix M later is of the form p*p (p=numer of patches), where mij denotes the probability\n         \t      #of dispersal from patch j (origin) to patch i (target), thus D[Target,Origin]!\n               \tDistances[Target+1, Origin+1] <- sqrt( dx*dx + dy*dy); #calculate the euclidean distance\n                }\n\n            #if target and origin are identical then write zero to that element\n            else{\n                Distances[Target+1, Origin+1] <-0.0\n                }\n            }\n        }\n\n    return(Distances)\n    }\n\n### Sub-functions for running the simulation (called by simulation2.r which is called in turn by Metacommunities.r, modified from Simulation.r\n\n#' Create Permutation Matrix\n#'\n#' Creates the vec-permutation matrix for use in running the matrix model\n#'\n#' @param p The number of cells in a square landscape\n#' @param S The number of stages in the matrix model\n#'\n#'@author Jakob Gerstenlauer\n#'\nCreatePermutationMatrix = function(p,S){\n\n    #The permutation matrix has dimension s*P x s*P\n    Dim.PermutMatrix <- S*p\n    Elements.PermutMatrix <-  (S*p)^2\n\n    Row<-Column<-rep(0, S*p)\n\n    index<-0\n    for( i in 1:S){\n        for( j in 1:p){\n            index<-index+1\n            Column[index]<- (j-1)* S + i\n            Row[index]<- (i-1)* p + j\n            }\n        }\n\n    P<-sparseMatrix(i = Row, j = Column, x= rep(1,length(Row)),dims=rep(S*p,2))\n\n    #Assign the (identical) dispersal submatrices for 2<-2,3<-3,4<-4 submatrix\n    #this submatrix is sparse and has ones in the diagonal\n    #Here we store it as a sparse vector\n    Dim<-p^2\n    index<-0:(p-1)\n    Index<-1+index*p+index\n    M_sub<-sparseMatrix(i = rep(1,p), j = Index, x= rep(1.0,p), dims=c(1,Dim))\n\n    cpm.out = list(M_sub,P)\n    return(cpm.out)\n    }\n\n#' get positions\n#' \n#' Get positions for assigning vital rates to the appropriate matrix locations\n#'\n#' @param x The vital rate in need of a position\n#' @param cell cell\n#' @param p The number of cells in a square landscape\n#' @param S The number of stages in the matrix model\nget.positions = function(x,cell,S,p){\n    # Old version as a guide\n    #Put diagram illustrating the pattern somewhere.\n    #this.pos = S * p * block.index + S * p * row.index + S * block.offset + position.offset \n\n    block.index = S * p * (cell - 1) * S #Determine which cell a block of vital rates belong in\n    block.offset = S * (cell - 1)   #Determine where in the cell the vital rates belong \n\n    position.offset = as.numeric(substring(x,2,2)) + 1 #Determine where in a row the vital rate belongs\n    row.index = S * p * (as.numeric(substring(x,3,3))) #Determine what row the vital rate belongs in.  # Warning: this won't be the most intuitive, because my description assumes a matrix format, but the actual assignment is done to a vector.\n    position = block.index + row.index + block.offset + position.offset\n\n    return(position)\n    }\n\n#' Get adjusted positions\n#'\n#' Get positions for adjusting the B1 matrix and for assigning to the B2 matrix\n#' @param row.indicator An indicator for the row\n#' @param cell The target cell\n#' @param p The number of cells in a square landscape\n#' @param S The number of stages in the matrix model\n#'\nget.adj.pos = function(row.indicator,cell,S,p){\n    pos.offset = 1 #In this case it is always the first vital rate that needs adjusting\n    row.index = S * p * row.indicator\n    \n    block.index = S * p * (cell - 1) * S #Determine which cell a block of vital rates belong in\n    block.offset = S * (cell - 1)   #Determine where in the cell the vital rates belong \n\n    position = block.index + row.index + block.offset + pos.offset\n    return(position)\n    }\n\n#DD# Update documentation for functions 104 & 105\n#' Get Modifier\n#'\n#' Purpose is to calculate vital rate modifiers based on input functions.\n#'\n#' @param env.val The value from a focal environmental layer for a given cell\n#' @param opt.val The target value for the focal species\n#' @param funct A function describing how to determine the modifier based\n#' on env.val and opt.val.  A list of possible functions is given in #LL# LOOK UP\n#' @param par1 The first input parameter to the function.\n#' @param par2 The second input parameter to the function\n#' @return Returns a modifier between zero and one that can be multiplied with\n#' the base vital rate.\n#' @author Alexander \"Sasha\" Keyel\n#'\nget.mod = function(env.val,opt.val,funct,par1,par2){\n\n    if (funct != 104 & funct != 105){\n        par1 = as.num(par1)\n        par2 = as.num(par2)\n        }\n    \n    #Indicator to check whether modifier values are constrained to 0 & 1\n    check.constr = 1\n    \n    #apply a quadratic decrease \n      #follows form of equation of y = -a(x-h)^2 + k, where (h,k) is the vertex, and k = 1 because that is no reduction\n    if (funct == 102){\n        modifier = -par1 * (env.val - opt.val)^2 + 1\n        }\n    \n    #Apply a simple match/nomatch function for categorical layer values\n      #e.g., if layer is grazed (g)/not grazed (ng), and species are grazed specialists (gs) or ungrazed specialists (us) there are 4 possible combinations (generalist species should not be coded with this function!)\n      #Simplest setup would be to have the response for a gs in ng the same as the response for a us in g.  But I don't know that that is realistic.  But it's symmetric\n    if (funct == 101){\n        if (env.val == opt.val){\n            modifier = par1\n        }else{\n            modifier = par2\n            }\n        }\n    \n    #Create a function to read the modifier directly from the environmental layer\n    if (funct == 103){\n        modifier = env.val\n        check.constr = 0\n        }\n    \n    #Do Stochastic plants style modifier for seed number\n    if (funct == 104){ \n        #opt.val = value specified as base vr for seed production (allows calculation of the modifier)\n        #par1 = biomass.adult;biomass.seed;biomass.clone\n        #par2 = relative.allocation.reproduction;ratio.sex.allocation \n        par1.split = strsplit(par1,\":\")[[1]] #strsplit makes a list of length 1, I want a vector.  Can't use semicolons as delimiters - they're already used in an earlier step!\n        biomass.adult = as.num(par1.split[1])\n        biomass.seed = as.num(par1.split[2])\n        biomass.clone = as.num(par1.split[3])\n        \n        par2.split = strsplit(par2,\":\")[[1]]\n        a = as.num(par2.split[1])\n        g = as.num(par2.split[2])\n        \n        fertility = env.val\n        \n        q = biomass.adult * a * fertility   #in grams\n        num.seeds = q * (1 - g) / biomass.seed\n\n        #Convert to a modifier to remain consistent with rest of code\n        modifier = num.seeds / opt.val #This will later be multiplied by opt.val, allowing that part to cancel out leaving the new seed number.        \n        check.constr = 0\n        }\n    \n    #Stochastic plants style modifier for clone number.\n    if (funct == 105){\n        #opt.val = value specified as base vr for clone production (allows calculation of the modifier)\n        #par1 = biomass.adult;biomass.seed;biomass.clone\n        #par2 = relative.allocation.reproduction;ratio.sex.allocation \n        par1.split = strsplit(par1,\":\")[[1]] #strsplit makes a list of length 1, I want a vector.\n        biomass.adult = as.num(par1.split[1])\n        biomass.seed = as.num(par1.split[2])\n        biomass.clone = as.num(par1.split[3])\n        \n        par2.split = strsplit(par2,\":\")[[1]]\n        a = as.num(par2.split[1])\n        g = as.num(par2.split[2])\n        \n        fertility = env.val\n        \n        q = biomass.adult * a * fertility   #in grams\n        num.clones = q * g / biomass.clone\n\n        #Convert to a modifier to remain consistent with rest of code\n        modifier = num.clones / opt.val #This will later be multiplied by opt.val, allowing that part to cancel out leaving the new seed number.        \n        check.constr = 0\n        }\n        \n    \n    if (check.constr == 1){\n        #Check that modifier is plausible\n        if (modifier > 1){\n            warning(\"A modifier was greater than 1. Modifier changed to 1. Please check function inputs for accuracy\")  \n            modifier = 1\n            }\n        if (modifier < 0){\n            #Turned the warning off - too common\n            #warning(\"A modifier was less than 0.  Modifier changed to 0.\")\n            modifier = 0\n            }\n        }\n    \n    return(modifier)    \n    }\n\n#DD# Might be good to expand the documentation a little on this one.\n\n#' Create a composite demography matrix\n#'\n#' Creates the demographic matrices used in the matrix model\n#'\n#' @param B1.template A template for creating the B1 matrices\n#' @param B2.template A template for creating the B2 matrices\n#' @param spe The number of species in the species pool\n#' @param SpTraits The traits (i.e. vital rates, response modifiers and dispersal parameters)\n#' @param p The number of cells in the landscape\n#' @param S The number of life stages in the matrices\n#' @param landscape A list object containing the environmental layer values\n#' @param landscape.identifiers A list of single letter identifiers for each environmental layer\n#' @note The original notation used in this function was changed to be consistent & intuitive for ACK.\n#' @author Jakob Gerstenlauer and Alexander \"Sasha\" Keyel\n#'\nCreateCompositeDemographyMatrix = function(B1.template,B2.template,spe,SpTraits,p,S,landscape,landscape.identifiers){\n    evt = SpTraits #Patch, because I don't want to replace the old evt with SpeciesTraits each time.\n\n    #Incoming format for species traits needs to be:\n    #optimumvalue;function;par1;par2 - have them all in the same cell in the csv file so they can be dealt with together!\n\n    #List of matrix vital rates\n    vital.rates.base = c(\"p01\",\"p02\",\"p11\",\"p12\",\"p22\",\"p23\",\"p33\",\"p30\",\"p32\")    #no p31, Adults only produce mobile seeds (not all of which must disperse).\n    hdr = names(evt)\n\n    #create a variable to contain vital rates.\n      #It will be sorted by species, then by cell, then by vital.rates.base\n      #Should correspond to the vital.rates variable from the previous version of this code\n      #This could all be put into a function to make the code more readable, by the way.\n    vr.vals = c()\n    for (sp in 1:spe){\n\n        for (cell in 1:p){\n            env.values = c()\n            #get a vector of environmental layers in the same order as landscape\n            for (e.lyr in 1:length(landscape)){\n                this.e.lyr = landscape[[e.lyr]]\n                e.lyr.val = this.e.lyr[cell]\n                env.values = c(env.values,e.lyr.val)\n                }\n                \n\n            for (v in 1:length(vital.rates.base)){\n                vr = vital.rates.base[v]\n                #vr = \"p23\"\n    \n                this.sp = sprintf(\"%s\",sp) #convert species to character for lookup purposes\n                base.vr = as.num(evt[this.sp, vr])\n            \n                #Extract vital rate modifiers\n                vr.info = grep(vr,hdr, value = T)\n    \n                modifiers = c()\n                #loop through each potential modifier\n                for (thing in vr.info){\n                    #If thing == vr, do nothing, this has already been extracted\n                    if (thing != vr){\n                        #Find out which environmental layer it corresponds to:\n                        ident = substr(thing,1,1)\n                        env.mod.index = which(ident == landscape.identifiers) #Find out which environmetnal layer ident corresponds to\n                        env.value = env.values[env.mod.index] #Get the environmental value for this cell\n                        stuff = as.character(evt[this.sp,thing]) #**# May speed the code up to do this once after reading in SpTraits!\n                        stuff = strsplit(stuff, \";\", fixed = T)[[1]] #the [[1]] is because R turns it into a list for some reason (beyond just what holds the values)\n                        opt.val = as.num(stuff[1])\n                        funct = as.num(stuff[2])\n                        par1 = stuff[3]\n                        par2 = stuff[4]\n\n                        modifier = get.mod(env.value,opt.val,funct,par1,par2)\n                        modifiers = c(modifiers,modifier)        \n                        }\n                    }\n\n                this.vr = base.vr * prod(modifiers) #Multiply the base rate by all modifiers affecting the base rate.  If modifiers is c(), this will yield 1 and have no effect\n                vr.vals = c(vr.vals, this.vr)\n                }    \n            }\n        }\n    \n\n    # NEED THE VITAL RATES TO BE BLOCKED BY SPECIES, THEN BY CELL\n\n    #Set up so that each vital rate is present for each cell on the landscape\n    vital.rates = rep(vital.rates.base,p * spe)     #**# This is 180,000 elements for a 20 x 20 landscape & 50 species \n \n#    # Need to get a vital rates vector with all species, labeled properly\n#    sp.vec = seq(1,spe,1)\n#    sp.vec = sapply(sp.vec,Digit,2) #Convert to text with leading 0's for proper sorting\n#    sp.lbl = sprintf(\"sp%s\",sp.vec)        #create a label for each species (used in create composite demography matrix)\n#    sp.lbl = rep(sp.lbl,(length(vital.rates)/spe)) #Extend it so that there is a species label for each vital rate\n#    sp.lbl = sort(sp.lbl) #Sort it so they are in the correct order\n#    vital.rates = sprintf(\"%s%s\",vital.rates,sp.lbl) #Add the species label to look up species specific vital rates\n#    \n\n    #**# Is there a fast way to get a vector from 1 to p * vr * sp that would correspond to a cell index?\n    cell.index = seq(1,p,1)\n    cell.index = rep(cell.index,length(vital.rates.base)) #Create a cell index for each vital rate\n    cell.index = sort(cell.index) #Sort so that the cell indices are in the proper order #**# Seems like if there was a way to avoid this step, it would be faster (i.e. create the index in the proper order to begin with.\n    cell.index = rep(cell.index,spe) #Create a separate index for each species\n\n    positions = mapply(get.positions,vital.rates,cell.index,MoreArgs = list(S = S,p = p))\n    \n    #Assign matrices for each species #**# Not the most efficient approach, but will let me see what speed gains I've already achieved.\n    B1.lst = list()\n    B2.lst = list()\n\n    #This is the length of the vital rates for one species for all cells\n    sp.offset = length(vital.rates.base) * p\n\n    #Set up adjustment positions for B1 matrix\n    cell.indices = sort(rep(seq(1,p,1),3)) #Create 3 sets of cell indices, one for each position that needs replacing, sorted.\n    row.indicators = rep(seq(0,2,1),p) #Create p sets of row indices, one for each row that needs replacing.  Starts with 0 to be consistent with approach taken in initial assignment of positions    \n    adj.pos = mapply(get.adj.pos,row.indicators,cell.indices,MoreArgs = list(S = S,p = p)) # Include the postions for stage 0 to 0 - will be 0 already in B1, but needs to be 0 in B2.\n\n    #This could just be done once outside this code.  Although now that this code doesn't get looped, it might not need it.\n\n    #**# Wouldn't it be better & more intuitive to assign B1 & B2 vital rate values separately?  Probably slower (but not by much), but more intuitive\n    #This could probably be replaced by a lapply, with B as an extra input that is then returned.  That would work & get rid of another for loop.  But might not speed things up much.\n    for (sp in 1:spe){\n        #subset positions to be appropriate to this matrix\n        sp.start = 1 + sp.offset * (sp - 1) #1 is the starting place when you are on the first species, then you add the offset.  It is sp - 1 because there is no offset for the first species\n        sp.end = sp.offset * sp #Go through to last record for the species\n        sp.pos = positions[sp.start:sp.end]  #Get the positions that correspond to each species\n        \n        #Create a new matrix based on the template\n        B1 = B1.template #B1.template serves as a template (duh)\n        B2 = B2.template\n        \n        #Assign values to the B1 matrix, then move the appropriate values to B2, then remove them from B1.\n        B1[sp.pos] = vr.vals[sp.start:sp.end]        \n        B2.vals = B1[adj.pos] #Get a vector of positions from the B1 matrix that actually belong in the B2 matrix\n        B1[adj.pos] = rep(0,length(adj.pos)) #Change the vital rates that belong in the B2 matrix to 0's in the B1 matrix\n        B2[adj.pos] = B2.vals #Assign the vital rates that belong in B2 to B2.\n\n        #Put the matrices into appropriate matrix format for the vital rate code\n        dim(B1)<-rep(S*p,2)\n        dim(B2)<-rep(S*p,2)\n    \n        #Transpose matrices so that the correct vital rate is in the correct location        \n        B1<-t(B1)\n        B2<-t(B2)\n\n        #Write the matrices to a list keyed to species number\n        B1.lst = append(B1.lst,B1)\n        B2.lst = append(B2.lst,B2)\n        }\n       \n    ccdm.out = list(B1.lst,B2.lst)\n    return(ccdm.out)\n    }\n  \n#' Look up Dispersal Probabilities\n#'\n#' Function for looking up dispersal probabilities from a table\n#'\n#' @details The base probabilities will be adjusted for each cell based on the\n#' edge type. In an absorbing edge type, probabilities beyond the landscape will\n#' simply be dropped, and dispersers will be removed (e.g. dispersal off an island)\n#' With a torus edge, dispersers wrap around to the other side of the landscape,\n#' and the dispersal probabilities are adjusted to account for this wrap-around\n#' effect.\n#' @param p The number of cells in a square landscape\n#' @param BaseProbabilities A set of base dispersal probabilities.\n#' @param edge.type Either ABSORBING or TORUS. See details.\n#'\ndisp.lookup.v2 = function(p, BaseProbabilities,edge.type){\n    \n    #So, we know cells positions relative to one another because the landscape is square.\n    \n    DispersalProbabilities = c()\n    \n    # Go through cells\n    for (i in 1:p){\n        \n        #For each cell, figure out where its seeds will disperse to\n        #This allows seeds to fall off the edge of the landscape\n        if (edge.type == \"ABSORBING\"){\n            out.probs = absorbing.edge(i,p,BaseProbabilities)\n            }\n        #This wraps seeds around.\n          #Note: because of the way dispersal probabilities are calculated in an earlier step,\n            #some really long dispersers can still disperse out of the landscape entirely (if they disperse > 50 cells)\n            #This is to maintain computational efficiency, and is off-set by potential invasion from outside)\n        if (edge.type == \"TORUS\"){\n            out.probs = torus.edge(i,p,BaseProbabilities)\n            }\n\n        #Add the calculated dispersal probabilities to the overall vector        \n        DispersalProbabilities = c(DispersalProbabilities,out.probs)    \n        }\n    \n    DispersalProbabilities = as.numeric(as.character(DispersalProbabilities))\n     \n    return(DispersalProbabilities)\n    }\n\n#DD# see if you want to merge the documentation with this with Torus edge.\n\n#' Absorbing edge\n#'\n#' Implement the dispersal probabilities, with species able to fall off the edge\n#' of the world\n#' @param i The location of the specific cell\n#' @param p The number of cells in a square landscape\n#' @param BaseProbabilities Base dispersal probabilities \nabsorbing.edge = function(i,p, BaseProbabilities){\n\n    n = sqrt(p) #Get an index for the horizontal landscape\n    m = sqrt(p) #Get an index for the vertical size of landscape (equals n, but done separately to keep the concepts clearer in my head)\n\n    #Get x,y for each cell\n    #start with i - 1\n    #Divide by m to get row - 1 (+1 gives row position)\n    #remainder + 1 gives column position\n\n    #calculate location of i\n    i.cpos = ( (i - 1) %% m) + 1\n    i.rpos = ( (i - 1) %/% m) + 1\n\n    # Tested by  p = 25, i = 1, i = 25, i = 6, results visually checked for accuracy\n\n    c.disp = c() #Get displacement in columns\n    r.disp = c() #Get displacement in rows\n\n    #**# Do you need a shortcut for truncating, if all options are 0 after a certain point?\n      #Just do it complete for now, and optimize later\n\n    #Switching to row/column notation, because x,y was confusing me (the notation is opposite that for row/columns - x would correspond to columns, and would be listed second)\n    for (j in 0:(p-1)){\n        #0:(p-1) makes it start with 0, and that makes the math easier.\n        cpos = (j %% m) + 1\n        rpos = (j %/% n) + 1\n\n        #cat(sprintf(\"(%s,%s)\",rpos,cpos)) # Checked with a print statement for accuracy\n\n        #Calculate displacement from cell of interest   \n        c.disp.j = cpos - i.cpos\n        r.disp.j = rpos - i.rpos #NOTE: This would make down a positive direction.  This may matter if adding directional dispersal.\n\n        #Add to vector in character format, so it can be used as a key for looking something up in the table\n        c.disp = c(c.disp,as.character(c.disp.j))\n        r.disp = c(r.disp,as.character(r.disp.j))\n        \n        }\n\n    #Look up dispersal probability    \n    d.prob = mapply(absorbing.lookup,r.disp,c.disp,MoreArgs = list(BaseProbabilities))\n\n    return(d.prob)\n    }\n\n#DD# See if you want to merge the documentation for this with the Torus edge lookup\n\n#' Lookup function, absorbing edge\n#'\n#' Look up the base probabilities when seeds can fall off the edge of the world\n#' @param r.val Row value\n#' @param c.val Column value\n#' @param BaseProbabilities Base dispersal probabilities\nabsorbing.lookup = function(r.val,c.val,BaseProbabilities){\n    \n    #BaseProbabilities needs to be reformated to come in as a nested list\n    if ( !is.null( BaseProbabilities[[r.val]][[c.val]] ) ){\n        prob.out = BaseProbabilities[[r.val]][[c.val]]\n    }else {\n        prob.out = 0\n        }\n    \n    return(prob.out)\n    }\n\n\n#DD# consider merging documentation with absorbing edge\n\n#' Torus Edge\n#'\n#' Implement dispersal probabilities,\n#' where individuals wrap around to the other edge of the world\n#' @param i The location of the specific cell\n#' @param p The number of cells in a square landscape\n#' @param BaseProbabilities Base dispersal probabilities \ntorus.edge = function(i,p,BaseProbabilities){\n\n    d.prob = rep(0,p) #Set each cell to 0 by default\n\n    #Go through list of displacements\n    r.disps = names(BaseProbabilities) #Names gets list of keys for accessing the list\n\n    #Iterate through main keys\n    for (k in 1:length(r.disps)){\n        r.disp = r.disps[[k]] #Set the row dispersal\n        \n        sublist = BaseProbabilities[[r.disp]]\n        c.disps = names(sublist) #Get keys in each sublist\n\n        r.disp = as.numeric(as.character(r.disp)) #Convert to numeric format\n\n        #Iterate through sublist\n        for (kk in 1:length(c.disps)){\n            c.disp = c.disps[kk]\n            this.val = sublist[[c.disp]]\n        \n            c.disp = as.numeric(as.character(c.disp))\n            this.val = as.numeric(as.character(this.val))\n            \n            #need to know relationship between the target cell and the other cells (do you?  Yes, and relationship to the edge)\n            n = sqrt(p)  #get length of landscape\n            m = sqrt(p)  #get height of landscape\n    \n            #calculate location of i\n            i.cpos = ( (i - 1) %% n) + 1\n            i.rpos = ( (i - 1) %/% m) + 1\n            \n            d.re = n - i.cpos  #get distance to right edge\n            d.le = 1 - i.cpos  #get distance to left edge (this should be negative)\n            d.te = 1 - i.rpos  #get distance to top edge (this should be negative)\n            d.be = m - i.rpos  #get distance to bottom edge\n    \n            #Get displacement with wrap-around\n            column.target = find.disp(i.cpos,c.disp,d.re,d.le,n)\n            row.target = find.disp(i.rpos,r.disp,d.be,d.te,n)\n            \n            # This code spot tested with row/column comobinations from a 3 x 3 landscape and with a 5 x 5 landscape\n            #convert row/column to the appropriate location in the vector\n            c.part = column.target  #This adjusts where in the row the value is\n            r.part = (row.target - 1) * n    #This adjusts the number according to the row.\n            target.cell = c.part + r.part #Does this work?\n            \n            #print(d.prob)\n            #print(d.prob[target.cell])\n            #print(this.val)\n            \n            #Add dispersal to appropriate cell.\n            d.prob[target.cell] = d.prob[target.cell] + this.val\n            }\n        }\n\n    return(d.prob)\n    }\n\n#' Find Displacement\n#' \n#' Function to find the displacement for a torus landscape, using wrap around in the landscape\n#'\n#' @param i.pos Position of the cell in the landscape\n#' @param disp Total displacement to be applied\n#' @param d.pe Distance to the positive edge (top or right)\n#' @param d.ne Distance to the negative edge (bottom or left)\n#' @param n Dimension of the landscape\n#'\nfind.disp = function(i.pos,disp,d.pe,d.ne,n){\n\n    #Test whether column displacement fits in landscape\n    #if the displacement is to the right (or 0):\n    if (disp >= 0){\n        #check if it fits on the landscape\n        if (disp <= d.pe){\n            #Assign displacement column\n            target = i.pos + disp\n\n        }else{\n            #Apply first wrap around & decrement c.disp\n            disp = disp - d.pe #Reduce by distance needed for wrap around\n\n            #While column displacement is larger than the landscape, continue to wrap around and decrement c.disp\n            while(disp > n){\n                #Decrement disp in proportion to one wrap around\n                disp = disp - n\n                }\n\n            #Assign appropriate column displacement\n            target = disp\n            }\n        }\n\n    #if the displacement is to the left:\n    if (disp < 0){\n        #Check if it fits on the landscape\n        if (disp >= d.ne){\n            target = i.pos + disp #This will subtract from i.cpos, because c.disp is negative\n        }else{\n            #Apply first wrap around & decrement c.disp (which is actually an increment, because it's negative, and we want it to be more positive)\n            disp = disp - d.ne #This is addition, because d.le is negative\n            \n            #While the displacement column is too large for the landscape, wrap around until it fits\n            while(disp < -n){\n                disp = disp + n\n                }\n        \n            #Assign appropriate column displacement\n            target = disp + n + 1 # the + n + 1 puts it on the right side of the landscape, and the 1 makes it so that a -1 assigns it to the edge of the actual landscape            \n            }        \n        }\n    return(target)\n    }\n    \n#' Look up Seed Dispersal Ratio\n#'\n#' Finds the seed dispersal ratio\n#' @param value a value\n#' @param vec1 a vector\n#' @param vec2 a vector\n#' @note This is the proportion of seeds dispersing to other cells\n#' and is not actually a ratio (appears to be misnamed)\nsdr.lookup = function(value,vec1,vec2){\n    for (item in 1:length(vec1)){\n        if (vec1[item] == value){\n            seed.dispersal.ratio = 1 - vec2[item] #vec2[item] gives the probability of seeds remaining in the cell.  The seed dispersal ratio is the proportion of seeds dispersing to other cells.\n            }\n        }\n    \n    return(seed.dispersal.ratio)\n    }\n\n       \n#' Get dispersal probabilities\n#'\n#' @param sp The species of interest (numeric)\n#' @param SpTraits A dataframe holding information about the species\n#' @param p the number of cells in the landscape\n#' @param distances The intercell distances for every cell in the landscape\n#' @param outpath The path where a dispersal probability table is, or should be written to.\n#' @param num.sim The number of draws to use in simulating dispersal\n#' @param edge.type The type of landscape edge (i.e. ABSORBING or TORUS)\n#'\nget.disp.prob = function(sp,SpTraits,p,distances,outpath,num.sim,edge.type){\n\n    #Define a dispersal kernel for the species.\n    #Here I need two parameters: mean dispersal distance and dispersal ratio which are stored in the data set\n    sp.txt = sprintf(\"%s\",sp) #convert species to text\n    dispersal.function = as.num(SpTraits[sp.txt,\"dispersalfunction\"]) # Get the dispersal function to be used. #Currently this does not change by cell type\n\n    par1   <- SpTraits[sp.txt, \"disppar1\"]  #For log-normal this is mean dispersal distance, in normal space cell units\n    par2 = SpTraits[sp.txt,\"disppar2\"]  #For log-normal this is dispersal standard deviation, in log-cell units\n    \n    if (dispersal.function == 1 | dispersal.function == 2){            \n        #Take the distances vector, and look up dispersal probabilities\n        lookup.target = sprintf(\"%sfunct%s_mean_%s_sd_%s_Nsim_%.0f_Dispersal_Probabilities.csv\",outpath,dispersal.function,par1,par2,num.sim)\n    }else{\n        lookup.target = sprintf(\"%sfunct%s_par1_%s_par2_%s_Nsim_%.0f_Dispersal_Probabilities.csv\",outpath,dispersal.function,par1,par2,num.sim)\n        }\n    \n    #If a dispersal probabilities table does not exist, create one\n    if (!file.exists(lookup.target)){\n        out.message = sprintf('Creating dispersal probabilities table with %s simulations.\\nPlease note that this may take some time (e.g., hours for the default of 1,000,000 simulations)\\nIf you believe the dispersal tables already exist, please abort and check the path to the dispersal tables.\\nTarget path is %s',num.sim,outpath)\n        message(out.message)\n        flush.console()\n        make.disp.prob.v2(dispersal.function,par1,par2,outpath, num.recs = num.sim)\n        }\n    \n    #Read in base probabilities from table\n    bprobs = read.table(lookup.target, sep = \",\", header = T) \n\n    #Convert probabilities table to a nested list for easier lookup\n      #**# this approach may be non-optimal for speed\n    BaseProbabilities = list()\n    for (a.row in 1:nrow(bprobs)){\n        \n        test.x = as.character(bprobs[a.row , 1]) #I think bprobs should be a matrix so this should pull the appropriate row\n        test.y = as.character(bprobs[a.row , 2]) #Will pull the vertical displacement\n        d.val = as.character(bprobs[a.row, 3]) #pulls up the value\n                    \n        #check if the row index has already been added\n        if (!is.null(BaseProbabilities[[test.x]])){\n            #Add a new y value to the list\n            this.val = BaseProbabilities[[test.x]]\n            #Check that a y value does not already exist (it never should!)\n            if(!is.null(this.val[[test.y]])){\n                print(\"Something went wrong in get.disp.prob, somehow there are multiple y values for the same x value in the base probabilities table\")\n                }\n            this.val[[test.y]] = d.val\n            BaseProbabilities[[test.x]] = this.val\n            \n            \n        }else{\n            new.list = list()  #Create a blank list to contain the information\n            new.list[[test.y]] = d.val #Assign the value (this needs to be done separately, so that the list element is not called \"test.y\" and instead uses the value from test.y!\n            BaseProbabilities[[test.x]] = new.list #Assign the value to a sub-list under x. #Do not say list here, or you get too many lists!\n            \n            }            \n        }\n            \n    #Match the dispersal probabilities to the correct base probability\n    DispersalProbabilities = disp.lookup.v2(p,BaseProbabilities,edge.type)\n\n    #Find where distance = 0, use that for calculating seed dispersal ratio\n    SeedDispersalRatio = sdr.lookup(0,distances,DispersalProbabilities)\n\n    #NOTE: Is this step necessary? or simply undone by the next line of code?\n    DispersalProbabilities<-Matrix(DispersalProbabilities, p, p)  #byrow = T\n    \n    dim(DispersalProbabilities)<-c(1, p^2)\n    DispersalProbabilities<-as(DispersalProbabilities, \"sparseMatrix\")\n\n    cdispmat.out = list(DispersalProbabilities,SeedDispersalRatio)\n    return(cdispmat.out)    \n    }\n\n#' Generate dispersal probabilities\n#'\n#' Calculates dispersal probabilities (point to area) via simulation based on\n#' It creates a table with dispersal probabilities to different cells compatible with the SpatialDemography model.\n#' an input mean dispersal distance (not log transformed) and dispersal standard deviation (log-transformed).\n#'\n#' @details Point to area dispersal assumes that dispersers originate in the center of\n#' the cell, and determines dispersal probabilities using the entire area of\n#' potential destination cells. (see Chipperfield et al. 2011 for validation of\n#' this approach). Unlike Chipperfield et al. 2011, this function is not based\n#' on integrals, but uses a simulation approach to approximate the dispersal\n#' probabilities.(not as mathematically sophisticated, but much simpler to\n#' program, and with large enough sample sizes, the differences are minimal.)\n#'\n#' @references Chipperfield, J.D., E.P. Holland, C. Dytham, C.D. Thomas,\n#' T. Hovestadt. 2011.  On the approximation of continuous dispersal kernels in\n#' discrete-space models.  Methods in Ecology and Evolution 2: 668-681.\n#' @author Alexander \"Sasha\" Keyel\n#' @param funct Chose a function for modeling dispersal (e.g., log-normal).\n#' Function codes are 1: log-normal, 2: normal, 3: constant, 4: uniform,\n#' 5: uniform, rounded to nearest integer. \n#' @param par1 First function parameter.  For log-normal, this should be the\n#' mean dispersal distance in cell units.  For example, if mean dispersal for a\n#' species was 25 m, and you intend to use a 50 m cell size, you would enter\n#' 25 / 50 = 0.5 here.  Note that this is NOT log-transformed\n#' @param par2 Second function parameter.  For log-normal, this is the dispersal\n#' standard deviation in log-transformed  cell units.\n#' @param outpath outpath specifies where to put the newly generated dispersal\n#' probability table\n#' @param num.recs The number of draws used in the simulation.  Ideally this\n#' will be a large number (e.g., 1,000,000), but the function will run slowly\n#' for numbers >10,000.\n#' @param max.disp.extent The maximum dispersal distance allowed for calculation\n#' of probabilities.  With the log-normal function and a high enough standard\n#' deviation, you can get VERY long distance dispersal.  This option sets a\n#' cut-point to improve computational efficiency.\n#' @param cut.off The minimum allowed dispersal probability.  Probabilities\n#' less than this value will be rounded to 0.  This is intended to improve\n#' computational efficiency.\n#' @return No value is returned, the function is run for its side-effects\n#' (creation of a dispersal probability table.)\n#' @note WARNING: If dispersers disperse out of the landscape extent (set by\n#' max.disp.extent), they will still disperse out of the landscape, regardless\n#' of whether a torus or absorbing edge is used.\n#' Only tested for log-normal distribution so far.  Also, it may be faster\n#' to use a GIS implementation for this process.\n#' @export make.disp.prob.v2\nmake.disp.prob.v2 = function(funct,par1,par2,outpath,num.recs = 100000,max.disp.extent = 101,cut.off = 0.00001){\n    \n    #for log-normal, par 1 should be mean.disp.cell and par2 should be ln.sd\n    \n   #As of 2014-07-08 dispersal needs to be input in terms of cell distances, and not m. \n   ##Convert distances to number of cells\n   # mean.disp.cell = mean.disp / cell.size\n\n    dist.lst = list()\n\n    #Add a label, because par1 may be log-transformed later, but the un-logtransformed name is used for the title\n    par1.lbl = par1\n    \n    ##Convert par1 to logarithmic scale for use in log-normal distribution\n    if (funct == 1){\n        par1 = log(par1)\n        }\n    \n    #Start by drawing distances and angles    \n    dist.vals = compute.funct(num.recs,funct,par1,par2,to.round = NA)\n    angle.vals = runif(num.recs,0,2*pi)\n    \n    #Convert the distance and angle to x,y coordinates\n    x.vals = mapply(get.x,dist.vals,angle.vals) #mapply uses multiple vectors as an input to the function.  \n    y.vals = mapply(get.y,dist.vals,angle.vals)\n    \n    #index cells relative to cell of origin\n      #Cell coords are x,y from top right to top left going clockwise\n    origin.cell = c(0.5,0.5,0.5,-0.5,-0.5,-0.5,-0.5,0.5)\n\n    #Loop through each cell in the extent\n    l.start = -max.disp.extent/2\n    l.end = max.disp.extent/2\n    \n    #Set up vectors to hold output values\n    xmp.vec = c()\n    ymp.vec = c()\n    p.vec = c()\n            \n    counter = 0\n    for (x.right.coord in (l.start + 1):l.end){\n        for (y.top.coord in (l.start + 1):l.end){\n            counter = counter + 1\n        \n            x.left.coord = x.right.coord - 1\n            y.bottom.coord = y.top.coord - 1\n                                    \n            #Get shorter variable names & repeat so that mapply function works properly\n            xrc = rep(x.right.coord,length(x.vals))\n            xlc = rep(x.left.coord,length(x.vals))\n            ytc = rep(y.top.coord,length(y.vals))\n            ybc = rep(y.bottom.coord,length(y.vals))\n            \n            #Count the number of points falling in this cell\n            point.vec = mapply(check.coords,x.vals,y.vals,xlc,xrc,ybc,ytc)\n            num.points = sum(point.vec)\n\n            #Divide by the total number generated to get dispersal probabilities\n            disp.prob = num.points / num.recs\n            \n            #Convert dispersal probabilities < 10^-4 (or whatever the cut-off is set to) to 0 to simplify matrix calculations (sensu Jakob.  This only makes sense if surviving seed number is much less than 10^4)\n            if (disp.prob < cut.off){\n                disp.prob = 0\n                }\n                            \n            #Get cell midpoint for distance calculation\n            xmp = mean(c(x.right.coord,x.left.coord))\n            ymp = mean(c(y.top.coord,y.bottom.coord))\n            \n            #To save on computation, do not output 0 values\n            if (disp.prob != 0){\n            \n                #Add values to vectors\n                xmp.vec = c(xmp.vec,xmp)\n                ymp.vec = c(ymp.vec,ymp)\n                p.vec = c(p.vec, disp.prob)\n                }                \n            }\n        }\n\n    #Set up file & header (label with mean and standard deviation for log-normal & normal, otherwise with par1 and par2\n    if (funct == 1 | funct == 2){\n        this.csv = sprintf(\"%sfunct%s_mean_%s_sd_%s_Nsim_%.0f_Dispersal_Probabilities.csv\",outpath,funct,par1.lbl,par2,num.recs)\n        fileheader = sprintf(\"X_displacement,Y_displacement,Dispersal_Probability_mean_%s_sd_%s\\n\",par1.lbl,par2)\n\n    }else{\n        this.csv = sprintf(\"%sfunct%s_par1_%s_par2_%s_Nsim_%.0f_Dispersal_Probabilities.csv\",outpath,funct,par1,par2,num.recs)        \n        fileheader = sprintf(\"X_displacement,Y_displacement,Dispersal_Probability_par1_%s_par2_%s\\n\",par1,par2)\n        }\n\n    #Write header with mean and sd to a table  \n    cat(fileheader, file = this.csv)\n\n    probs = matrix(c(xmp.vec,ymp.vec,p.vec),ncol = 3)\n    \n    write.table(probs, file = this.csv,append = T, row.names = F, col.names = F, sep = \",\")\n\n    }\n\n#Function for getting an x coordinate from angle & distance #Used by make.disp.prob, originally from d2dhelper.r\n#' Get x/y coordinate\n#' \n#' Functions for getting an x (or y) coordinate from angle & distance\n#'\n#' @param a.distance The input distance\n#' @param an.angle The input angle\n#' @param angle.units The units for the angle. Must be set to \"RADIANS\".\n#' \nget.x = function(a.distance,an.angle,angle.units = \"RADIANS\"){\n    \n    if (angle.units == \"RADIANS\"){\n        if (an.angle >= 0 & an.angle < (pi/2)){\n            out.quad = 1\n            x = a.distance * cos(pi/2 - an.angle)\n            }\n            \n        if (an.angle >= (pi/2) & an.angle < (pi)){\n            out.quad = 2\n            x = a.distance *  cos(an.angle - pi/2)\n            }\n            \n        if (an.angle >= pi & an.angle < ((3*pi)/2)){\n            out.quad = 3\n            x = a.distance * -cos(3*pi/2 - an.angle)\n            }\n            \n        if (an.angle >= ((3*pi)/2) & an.angle < 2*pi){\n            out.quad = 4\n            x = a.distance * - cos(an.angle - 3*pi/2)\n            }\n        }\n    \n    \n    return(x)\n    }\n\n#function for getting a y coordinate from angle and distance #Used by make.disp.prob, originally from d2dhelper.r\n#DD# Figure out how to dispaly with the get.x documentation!\nget.y = function(a.distance,an.angle,angle.units = \"RADIANS\"){\n    \n    if (angle.units == \"RADIANS\"){\n        if (an.angle >= 0 & an.angle < (pi/2)){\n            out.quad = 1\n            y = a.distance * sin(pi/2 - an.angle)\n            }\n            \n        if (an.angle >= (pi/2) & an.angle < (pi)){\n            out.quad = 2\n            y = a.distance * -sin(an.angle - pi/2)\n            }\n            \n        if (an.angle >= pi & an.angle < ((3*pi)/2)){\n            out.quad = 3\n            y = a.distance * -sin(3*pi/2 - an.angle)\n            }\n            \n        if (an.angle >= ((3*pi)/2) & an.angle < 2*pi){\n            out.quad = 4\n            y = a.distance * sin(an.angle - 3*pi/2)\n            }\n        }\n    \n    \n    return(y)\n    }\n\n#' Check coordinates\n#'\n#' Checks if coordinates are within a cell.\n#'\n#' @param x.val The X coordinatea\n#' @param y.val The Y coordinate\n#' @param x.lower.bound The lower x coordinate of the cell\n#' @param x.upper.bound The upper x coordinate of the cell\n#' @param y.lower.bound The lower y coordinate of the cell\n#' @param y.upper.bound The upper y coordiante of the cell\n#' @note Used by make.disp.prob.v2\n#' @note WARNING Points that fall exactly on a cell's border are dropped.\n#' While this is bad, this is expected to be relatively minor,\n#' as the odds of getting a number that lands exactly on a cell's border is\n#' pretty low, given the number of decimal places.\n#'\ncheck.coords = function(x.val,y.val,x.lower.bound,x.upper.bound,y.lower.bound,y.upper.bound){\n\n    in.cell = 0\n    if (x.val > x.lower.bound & x.val < x.upper.bound){\n        if (y.val > y.lower.bound & y.val < y.upper.bound){\n            in.cell = 1\n            }\n        }\n    \n    return(in.cell)\n    }\n\n#' Create the composite dispersal matrix\n#'\n#' Create a composite dispersal matrix for the dispersal portion of the model\n#'\n#' This matrix consists of S*S submatrices of dimension p x p describing the\n#' dispersal probability between patches:\n#' Where p is the number of patches, S is the number of stages (here 4).\n#' Only diagonal submatrixes, which describe spatial movement of individuals of\n#' a given stage between patches, can contain non-zero matrix entries.\n#' We assume that only individuals of stage 1 (mobile seeds) move between\n#' patches, therefore only the submatrix M1<-1 contains non-zero off-diagonal\n#' matrix entries!\n#' The off-diagonal entries of M1<-1 describe the probability of seed movement\n#' between patches of the landscape.\n#' The diagonal entries describe the probability that mobile seeds stay in the\n#' local patch, which is 1-u (seed dispersal ratio).\n#' All other diagonal submatrices are identity matrices (ones in the diagonal)\n#' as all individuals of these stages stay put.\n#' 0<-0   O     O     O\n#' O     1<-1   O     O\n#' O     O    2<-2    O\n#' O \t   O      O   3<-3\n#'\n#' @param DispersalProbabilities The dispersal probabilities from each cell to\n#' every other cell in the landscape\n#' @param p Number of cells in the landscape\n#' @param S Number of life-stages in the model (currently needs to be 4)\n#' @param M_sub A template matrix of the appropriate dimensions to fill in.\n#' @return returns a dispersal matrix for controlling seed dispersal.\n#' @author Jakob Gerstenlauer and Alexander \"Sasha\" Keyel\n#' @references Hunter, C.M. & Caswell, H. (2005). The use of the vec-permutation\n#' matrix in spatial matrix population models.\n#' Ecological modelling, 188, 15-21.\n#' @note WARNING While S is an input, this function will ONLY work for S = 4.\n#'\nCreateCompositeDispersalMatrix = function(DispersalProbabilities,p,S,M_sub){\n    #create a sparse matrix with dimensions 1 and dim (a vector!) for the dispersal matrix M\n    Dim<-S*S*p^2\n    M <- sparseMatrix(dims = c(1,Dim), i={}, j={},x=rep(0.0,Dim))\n        \n    #Calculate the indices which have to be added for all p^2 indices of M_ii\n    index1 <- seq(1,p * p);\n    xpos <- (index1 - 1) - ((index1 -1) %/% p) * p   \n    ypos  <- (index1 - 1) %/% p;\n    index2 <- xpos + ypos * S * p\n    \n    #assign 1<-1 submatrix (i=1)\n    #z<-1+(1-1)*(S*p^2+p)\n    z <- 1\n    M[z+index2] <- DispersalProbabilities[index1]\n    \n    #SS# This would break if you changed the number of stages in the code right now.\n    \n    #assign 2<-2 submatrix (i=2)\n    z <- 1 + S*p^2 + p\n    M[z+index2] <- M_sub[index1]\n    \n    #assign 3<-3 submatrix (i=3)\n    z <- 1 + 2 * (S*p^2+p)\n    M[z+index2] <- M_sub[index1]\n    \n    #assign 4<-4 submatrix (i=4)\n    z <- 1 + 3 * (S*p^2+p)\n    M[z+index2] <- M_sub[index1]\n\n    dim(M)<-rep(S*p,2)\n        \n    #check the resulting matrix\n    #image(M)\n    \n    return(M)\n    }\n\n#' Write table for timing function\n#' \n#' Simple version to get write.table to behave properly\n#' @param in.vec the vector to be written to table\n#' @param timefile the file to write to.\n#' @param do.append Whether or not to append to an existing file\n#'\nwrt = function(in.vec, timefile, do.append = TRUE){\n    in.vec = matrix(in.vec, nrow = 1)\n    write.table(in.vec, file = timefile, sep = \",\", row.names = FALSE, col.names = F, append = do.append)\n    }\n\n#' Get model timing\n#'\n#' This function takes a start time, and different run times,\n#' and outputs the timing to a file.  The purpose is to allow one to see \n#' how long different model processes take, and prioritize sections of code for\n#' optimization or for implementation in C++.\n#'\n#' @param start.time The starting time for the model run\n#' @param run.times A list of intermediate times during the model run\n#' @param run.lbl A list of labels for each of the intermediate times\n#' @param timefile The file (including path) to be created\n#' @param write.timefile An indicator for whether or not to write to file. If 0, no file will be output, if 1 only the total model time will be output, if 2 all timing will be output.\n#' @param Model.Name The model being timed\n#' @return Nothing is returned, function is run to create a file with run times.\n#' @note run.times and run.lbl need to be the same length and in the same order,\n#' or you will get corrupted/strange results!\n#'\nGetTimes = function(start.time,run.times,run.lbl,timefile, write.timefile, Model.Name){\n\n    #Note: this function changed on 2015-02-05.\n    \n    #if (write.timefile == 0){ # Do nothing }\n        \n    if (write.timefile == 1){\n        if (!file.exists(timefile)){\n            wrt(c('Model','ElapsedTime'),timefile, FALSE)\n            }\n        elapsed.time = run.times[length(run.times)] - start.time #last item minus first item\n        wrt(c(Model.Name,elapsed.time),timefile)\n        } \n     \n    if (write.timefile == 2){         \n        total.times = run.times - start.time\n        elapsed.times = c()\n        prev.item = start.time\n        for (i in 1:length(run.times)){\n            item = run.times[i]\n            item.time = item - prev.item\n            elapsed.times = c(elapsed.times, item.time)\n            prev.item = item\n            }\n  \n        #Set up model run header\n        out.lbl = c(\"Model.Name\",\"Model.Time\",run.lbl)\n        wrt(out.lbl,timefile)\n\n        #Set up elapsed time output\n        et.hdr = sprintf(\"%s_elapsed\", Model.Name)\n        elapsed.time = run.times[length(run.times)] - start.time #last item minus first item\n        elapsed.times = c(et.hdr, elapsed.time, elapsed.times)\n        wrt(elapsed.times,timefile)\n\n        #Set up total time output\n        tot.hdr = sprintf(\"%s_total\", Model.Name)\n        tot.time = run.times[length(run.times)] - start.time\n        total.times = c(tot.hdr, tot.time, total.times)\n        wrt(total.times,timefile)        \n        }\n    }\n\n    \n#' Set up initial population sizes\n#'\n#' Set up initial population sizes in the model\n#'\n#' @param n0.lst A list of initial population sizes for each species (will be empty on input, will be returned with values)\n#' @param spe The total number of species in the species pool\n#' @param species.locs A list of which cells are occupied by each species\n#' @param S The number of life stages\n#' @param n.seed The number of seeds to assign to each occupied cell\n#' @param n.juv The number of juveniles to assign to each occupied cell\n#' @param n.adult The number of adults to assign to each occupied cell\nOccSetup = function(n0.lst,spe,species.locs,S,n.seed,n.juv,n.adult){\n\n    #Loop through each species (#**# Is this the most efficient approach?  Seems reasonable)\n    for (sp in 1:spe){\n\n        #Translate species.locs to Occupied patches for each species\n        to.find = sprintf(\"\\\\b%s\\\\b\",sp) #\\b looks for boundaries - so this makes sure only the search term matches, and not larger numbers that include the search term.  The \\ needs a \\ in order for R to interpret it as a \\, and not as something else (i.e., an escape character). Otherwise a search for species 1 will return wrong matches, e.g., 41 or 14!\n        OccupiedPatches = grep(to.find,species.locs) #This gives the location in the list, not in the specific vector in the list - which is exactly what I want.\n        \n        #If length == 0, there are no occupied patches, and no assignment is necessary\n        if (length(OccupiedPatches > 0)){\n        \n            #Assign number of individuals to n0.lst for each species\n            #Note - no point in assigning mobile seeds - the first transition matrix will kill them all.\n            adult.Indices <- OccupiedPatches * S\n            juv.Indices <- OccupiedPatches * S - 1\n            seed.Indices <- OccupiedPatches * S - 2\n            \n            \n            n0.lst[[sp]][seed.Indices]<- n.seed[sp]\n            n0.lst[[sp]][juv.Indices]<- n.juv[sp]\n            n0.lst[[sp]][adult.Indices]<- n.adult[sp]\n            }\n        }\n    \n    return(n0.lst)\n    }\n\n#' Implement invasion in MetaComeSE model\n#'\n#' Manage invasion in the model.  A certain number of species (num.invaders) are\n#' chosen to invade a certain number of cells in the landscape (cells.to.invade)\n#' at a particular propagule pressure (related to the species' reproductive\n#' rates).\n#'\n#' @param nt1a.lst A list giving the locations of each species in each cell\n#' @param spe The number of species in the regional species pool\n#' @param p The number of cells in the landscape\n#' @param S The number of stages in the population model (= 4)\n#' @param SpTraits A dataframe containing the species traits\n#' @param num.invaders The number of species to have invade the landscape\n#' @param cells.to.invade The number of cells in the landscape to be invaded\n#' @param repro.proportion The proportion of a species' normal reproduction to\n#' assign to the landscape.  E.g., if a species normally makes 1000 seeds, and\n#' repro.proportion is set to 0.5, 500 seeds will be assigned to each invaded\n#' cell.  Similarly, a repro.proportion of 1.5 would lead to 1500 seeds.\n#' @return An updated n0.lst to include the invaders\n#'\ndo.invasion = function(nt1a.lst,spe,p,S,SpTraits,num.invaders = 1,cells.to.invade = 5,repro.proportion = 1){\n\n    # For testing purposes\n    #spe = 100\n    #num.invaders = 1\n    #cells.to.invade = 5\n    #repro.proportion  = 1 #proportion of one individual's normal reproduction to assign to the invaded cell \n\n    #Draw [num.invaders] species to invade\n    invaders = sample(spe,num.invaders)\n    \n    #For each invader...\n    for (invader in invaders){\n        #Select [cells.to.invade] cells for each species to invade\n        invaded.cells = sample(p,cells.to.invade)\n        \n        #Assign Z seeds to invade each cell (numbers proportional to the species seed production in optimal habitat)\n        sp.txt = sprintf(\"%s\",invader)\n        n.new.seeds = SpTraits[sp.txt,\"p30\"] * repro.proportion * SpTraits[sp.txt, \"p01\"]  #Take normal fecundity * proportion of reproduction * proportion of mobile seeds that survive to get number of invaders\n        seed.Indices <- invaded.cells * S - 3 #Goal is to index which values in nt1a.lst (approach copied from OccSetup, could also be applied to juveniles and adults, if invasion at these stages is preferred!)\n        n.old.seeds = nt1a.lst[[invader]][seed.Indices]\n        nt1a.lst[[invader]][seed.Indices]<- n.new.seeds + n.old.seeds #Some cells may be already colonized, in this case just increase the number of seeds present.\n        }\n    \n    return(nt1a.lst)\n    }\n\n#' Implement seed competition\n#'\n#' Idea is that seeds will compete for microsites. Currently three types of competition possible:\n#' 0 = no competition, 1 = within-species K (excess seeds die), 2 = deterministic\n#' multi-species K (seeds are assigned to microsites proportional to the number of seeds\n#' of each species), and 3 = stochastic multi-species K (seeds are assigned to microsites\n#' via a lottery approach, where each seed has a chance to occupy a microsite.\n#' NOTE: Seeds already in the seedbank occupy microsites, juveniles and adults do not.\n#' WARNING: My implementation of this may be computationally intensive for large numbers of seeds!\n#'\n#' @param competitiontype The type of competition (see description)\n#' @param microsites.vec A vector giving the number of microsites in each cell.\n#' @param nt1a.lst A list giving the abundances of each of the four stages for each species\n#' @param spe The number of species in the regional species pool\n#' @param ISeedBank An index for which entries for each species in nt1a.lst correspond to stage 1 individuals.\n#' @param ISeedlings An index for which entries for each species in nt1a.lst correspond to stage 0 individuals.\n#' @param p Number of cells in the landscape\n#'\ndo.competition = function(competitiontype, microsites.vec, nt1a.lst, spe, ISeedBank, ISeedlings, p){\n        \n    #Within-species competition scenario\n    if (competitiontype == 1){\n        for (sp in 1:spe){\n            #Get number of seeds already in the seedbank, subtract from overall carrying capacity (those microsites are already full)\n            new.microsites = microsites.vec - nt1a.lst[[sp]][ISeedBank]\n            \n            #Prevent negative numbers of new microsites!\n            new.microsites = ifelse(new.microsites < 0, 0, new.microsites)\n    \n            #Reduce number of mobile seeds to the carrying capacity for the cell.  Mobile seeds includes seeds dispersing to the same cell (but not already present in the seedbank)\n            nt1a.lst[[sp]][ISeedlings]<-ifelse(nt1a.lst[[sp]][ISeedlings] > new.microsites, new.microsites, nt1a.lst[[sp]][ISeedlings])\n            }\n        }\n    \n    #Across-species competition scenario\n    if (competitiontype == 2){\n        \n        #Compute number of available microsites\n        ms.out = compute.microsites(microsites.vec,nt1a.lst, spe, ISeedBank, ISeedlings,p)\n          new.microsites = ms.out[[1]]\n          TotalMobileSeeds = ms.out[[2]]\n        \n        # Reduce the number of mobile seeds for each species to its share of the carrying capacity\n        for (sp in 1:spe){\n            #Divide the number of seeds of this species by the total number of seeds from all species\n            sp.proportion = nt1a.lst[[sp]][ISeedlings] / TotalMobileSeeds\n            #Calculate the number of spots assigned to this species.  May want to put restrictions on how small of a decimal it can be.\n            spots = sp.proportion * new.microsites\n            nt1a.lst[[sp]][ISeedlings] <-ifelse(nt1a.lst[[sp]][ISeedlings] > spots, spots, nt1a.lst[[sp]][ISeedlings])\n            }\n        }\n    \n    #Lottery approach to microsites (stochastic version of type 2)\n    if (competitiontype == 3){\n        #Compute number of available microsites\n        ms.out = compute.microsites(microsites.vec,nt1a.lst, spe, ISeedBank, ISeedlings,p)\n          new.microsites = ms.out[[1]]\n          TotalMobileSeeds = ms.out[[2]] #Note: not actually needed for this competition type!\n        \n        #Create a list to contain seed vectors\n        cells.lst = rep(list(NA),p)\n        \n        #Create vectors labeled by species of all seeds for each cell\n        for (sp in 1:spe){\n            sp.cell.vec = nt1a.lst[[sp]][ISeedlings]\n            \n            #Loop through and extract from cells\n            for (cell in 1:p){\n                this.sp.val = sp.cell.vec[cell]\n                #NOTE: This step drops fractional seeds!\n                sp.vals = rep(sp, this.sp.val)\n                \n                #Need special behavior to avoid adding an NA on the first time.\n                if (cell == 1 & sp == 1){\n                    old.vals = c() #Note: this will come up as NULL\n                }else{\n                    old.vals = cells.lst[[cell]] \n                    }\n                new.vals = c(old.vals, sp.vals)\n                cells.lst[[cell]] = new.vals\n                }\n            }\n\n        #Create a vector to hold number of mobile seeds per cell\n        base.spots = rep(0,p)\n        # Use the template vector for each species\n        spots = rep(list(base.spots),spe)\n        \n        #Sample the requisite number of seeds from the vector\n        for (i in 1:length(new.microsites)){            \n            sites = new.microsites[i]\n            pool = cells.lst[[i]]\n\n            #If there are fewer seeds than microsites, all seeds find microsites\n            if (length(pool) <= sites){\n                winners = pool\n            #otherwise, sample from the seed pool\n            }else{\n                winners = sample.fixed(pool, sites)\n                }\n            \n            #Get counts of # seeds per cell as a vector\n            winners.table = table(winners)\n            \n            #Update the spots list for each species\n            for (rec in names(winners.table)){\n                sp = as.num(rec)\n                spots[[sp]][i] = winners.table[[rec]] #Fill in the appropriate cell value with the entry matching the table.\n                # This should be more efficient than looping over species, as only records in the table are used.\n                # Note that the default value for each species and cell is 0, so this approach should work well.\n                # However, optimization here will likely be necessary for larger models or large numbers of seeds!\n                }\n            }\n        \n        #Assign to nt1a.lst\n        for (sp in 1:spe){\n            nt1a.lst[[sp]][ISeedlings] = spots[[sp]]\n            }        \n        }\n    \n    #Unequal across species competition #This could also be very cool!\n    #if (competitiontype == X{USE YOUR IMAGINATION!} \n    \n    #Might even be able to make a selective species competition scenario.  This could get cool! (e.g., if species A can establish if species B is at a microsite, but species B can't establish if A is present at the microsite #CAN YOU THINK OF ANY REAL EXAMPLES OF THIS?\n    return(nt1a.lst)\n    }\n\n#' Compute number of available microsites\n#'\n#' Helper function to calculate number of available microsites\n#'\n#' @param microsites.vec A vector giving the number of microsites in each cell.\n#' @param nt1a.lst A list giving the abundances of each of the four stages for each species\n#' @param spe The number of species in the regional species pool\n#' @param ISeedBank An index for which entries for each species in nt1a.lst correspond to stage 1 individuals.\n#' @param ISeedlings An index for which entries for each species in nt1a.lst correspond to stage 0 individuals.\n#' @param p Number of cells in the landscape\n#'\ncompute.microsites = function(microsites.vec,nt1a.lst, spe, ISeedBank, ISeedlings,p){\n\n    #Get total number of seeds already in the seedbank\n    SeedsinSeedbank = rep(0,p) #Create a separate entry for each cell\n    TotalMobileSeeds = rep(0,p) #Separate entry for each cell\n    for (sp in 1:spe){\n        SeedsinSeedbank = SeedsinSeedbank + nt1a.lst[[sp]][ISeedBank]\n        TotalMobileSeeds = TotalMobileSeeds + nt1a.lst[[sp]][ISeedlings]\n        }\n    #Subtract occupied microsites from overall carrying capacity\n    new.microsites = microsites.vec - SeedsinSeedbank\n    \n    #Prevent negative numbers of new microsites!\n    new.microsites = ifelse(new.microsites < 0, 0, new.microsites)\n\n    return(list(new.microsites, TotalMobileSeeds))\n    }\n\n#' Calculate model functional diversity\n#'\n#' This function calculates functional diversity at the end of the model\n#' simulation and updates the Results dataframe.\n#'\n#' @param Results The results file to be updated\n#' @param SpTraits A dataframe containing the Species Trait values\n#' @param abund.mat A matrix giving abundances for each species and cell\n#' @param spe The total number of species in the regional species pool\n#' @param resolution The number of decimal places to round functional traits\n#' @param log.trans Whether or not to log-transform functional traits (this may be broken)\n#' @param sv An indicator parameter\n#' @param num.tp An indicator to assist in updating the correct row of the Results\n#' @note The intention is to add an option to allow this to be calculated at\n#' intermediate model steps\n#'\ncalc.fd = function(Results,SpTraits,abund.mat,spe,resolution,log.trans, sv, num.tp){ \n\n    SP.mod = SpTraits\n    SP.mod$is.error = NULL #Drop is.error column. NOTE: can drop this code, because the column is already gone\n\n    #Convert character fields (Response traits) to factor fields to avoid crashing the code later\n    for (a.field in colnames(SP.mod)){\n        if (typeof(SP.mod[[a.field]]) == \"character\"){\n            SP.mod[[a.field]] = as.factor(SP.mod[[a.field]])\n            }\n        }\n        \n    #NOTE: I should probably should drop the na columns regardless.\n    if (log.trans != 0){ \n        na.zero = apply(SP.mod,2,function(.col){all(is.na(.col))  || all(.col == 0)})\n        SP.mod = SP.mod[ ,!na.zero]\n        }\n    \n    #Do the actual calculations\n    Results = getfd(Results,SP.mod,abund.mat,resolution,log.trans,sv, num.tp)\n        \n    return(Results)\n    }\n                  \n#' Calculate functional diversity (helper function to calc.fd)\n#' \n#' Calculate functional diversity for calc.fd & place values in Results dataframe\n#' Choose what metrics to calculate based on what is set up in Results.\n#' Calculate appropriate functional trait diversity\n#' Calculate for both functional traits & just for response traits\n#'\n#' @param Results The results file to be updated\n#' @param SP.mod Species Traits, but with transformations and changes in format\n#' @param abund.mat A matrix giving abundances for each species and cell\n#' @param resolution The number of decimal places to round functional traits\n#' @param log.trans Whether or not to log-transform functional traits (this may be broken)\n#' @param sv An indicator parameter\n#' @param num.tp An indicator to assist in updating the correct row of the Results\n#'\ngetfd = function(Results,SP.mod,abund.mat, resolution,log.trans, sv, num.tp){\n\n    #Get names from results\n    res.nam = names(Results)\n\n    #Calculate overall functional diversity & response trait diversity\n    div.types = c(\"FTD\",\"RTD\")\n    for (div.type in div.types){\n\n        #Create a species matrix that can be modified without changing the original\n        sp.mat = SP.mod\n                \n        #Drop non-response traits (i.e., in this example, those labeled \"Max\"\n        if (div.type == \"RTD\"){\n            drop.lst = c(\"p01\",\"p02\",\"p11\",\"p12\",\"p22\",\"p23\",\"p30\",\"p32\",\"p33\",\"biomass.adult\",\"biomass.juv\",\"biomass.seed\")\n            #**# Could be optimized or done better.\n            for (item in drop.lst){\n                sp.mat[[item]] = NULL\n                }\n           \n            }\n\n        #Convert from dataframe to matrix (Note: as.matrix does not work here, because it makes everything character, due to fields that should be interpreted as factors\n\n        sp.mat = data.matrix(sp.mat) #Note that neither matrix or as.matrix give appropriate results!\n\n        td.to.calc = grep(div.type,res.nam,value = T) #Get any things in results identified as \"FTD\" functional trait diversity\n        #s.term = sprintf(\"landscape.%s.\", div.type)\n        s.term = sprintf(\"%s.\", div.type)\n        td.to.calc = sub(s.term,\"\",td.to.calc) #Strip off prefixes\n        td.to.calc = unique(td.to.calc) #Remove duplicates.\n        \n        #**# Consider improving this code: idea is to go through ftd.to.calc, and then calculate the appropriate metrics.  But need to avoid redundancy of calculations & do things sensibly\n        did.mvfd = 0 #indicator variable for my multivariate measures\n        did.dbfd = 0 #indicator variable for Laliberte package\n        did.pgfd = 0 #indicator variable for Petchey & Gaston's 2002,2006 measure    \n    \n        for (item in td.to.calc){\n            #**# This approach could be improved / optimized\n            if (item == \"UTC\"){\n                if (did.mvfd != 1){\n                    if(!require(multirich)){ stop(\"Please install multirich: install.packages('multirich')\") }\n                    utc.out = multirich::mvfd(sp.mat,abund.mat,resolution = resolution, log.trans = log.trans, calc.ovr = 0) #**# Need to deal with resolution problem!\n                    did.mvfd = 1\n                    }\n                    \n                i.val = utc.out$utc[1] #initial UTC\n                f.val = utc.out$utc[2] #final UTC\n                }\n    \n            if (item == \"PGFD\"){\n                if (did.pgfd != 1){\n                    stop(\"PGFD has not yet been added as an option\")\n                    #**# script out petchey & Gaston measure\n                    did.pgfd = 1\n                    }\n                }\n    \n            if (item == \"FRIC\"){\n                if (did.dbfd != 1){\n                    if(!require(FD)){ stop(\"Please install FD: install.package('FD')\") }\n                    fun.div = FD::dbFD(sp.mat,abund.mat,calc.FRic = T)\n                    did.dbfd = 1\n                    }\n                }\n            \n            #Write to appropriate output in Results\n            ii = (sv - 1) * num.tp + 1\n            fi = (sv - 1) * num.tp + 2\n            \n            field = sprintf(\"%s.%s\", div.type,item)\n            Results[[field]][ii] = i.val\n            Results[[field]][fi] = f.val\n            \n            #Write to appropriate output in Results.\n            #i.term = sprintf(\"landscape.%s.%s.Initial\",div.type,item) #Could make it so landscape and initial could be changed too!\n            #f.term = sprintf(\"landscape.%s.%s.Final\",div.type,item)\n            #Results[[i.term]] = i.val \n            #Results[[f.term]] = f.val\n            }\n        }\n    \n    return(Results)\n    }\n\n#' Convert abundance to occupancy\n#'\n#' Abundances > 0 are coded as present (1),\n#' abundances == 0 are coded as absent (0).\n#'\n#' @param x Input a number >= 0.\n#' @return Outputs a recoded number: 0 (absent) or 1 (present).\n#'\nrecode = function(x){\n    if (x > 0){\n        y = 1\n        }\n    if (x == 0){\n        y = 0\n        }\n    if (x < 0){\n        print(\"x < 0.  You have a problem, as there is no such thing as negative abundance!\")\n        y = NA\n        }\n        \n    return(y)\n    }\n\n#' Target recode\n#'\n#' Recode such that all target values are 1 and all other values are 0\n#' @param x An input number\n#' @param target the target to be matched\n#'\ntarget.recode = function(x, target){\n    y = 0\n    if (x == target){ y = 1 }\n    \n    return(y)\n    }\n\n#' Drop fractional individuals\n#'\n#' Abundances >= 1 remain as they were\n#' Abundances < 1 are recoded as 0\n#' Negative inputs are not allowed.\n#'\n#' @param x A number >= 0 (corresponds to abundance)\n#' @return Either the original number (if x >= 1) or 0 (x < 1).\n#'\ndrop.partial = function(x){\n    if (x >= 1){\n        y = x\n        }\n    if (x < 1){\n        y = 0\n        }\n    if (x < 0){\n        print(\"x < 0.  You have a problem, as there is no such thing as negative abundance!\")\n        y = NA\n        }\n    return(y)\n    }\n\n#' Calculate output metrics\n#' \n#' Calculates output metrics for the simulation.\n#' E.g., species richness, beta diversity, biomass, and functional diversity\n#'\n#' @param Results A dataframe to contain the results\n#' @param timepoint The timepoint (initial, final, etc.) for which to calculate the metrics\n#' @param n0.lst A list of the abundances of each stage for each species\n#' @param IAdults An index of which stages correspond to adults\n#' @param spe The total number of species in the species pool\n#' @param p The number of cells in the landscape\n#' @param SpTraits A dataframe containing species traits\n#'\ncalc.metrics = function(Results,timepoint,n0.lst,IAdults,spe,p,SpTraits){\n\n    # Get adult abundances for the scenario, calculate species richness, alpha diversity, and biomass\n    tot.occ = 0\n    sp.richness = 0\n    abund.vec = c()\n    nam.vec = c()\n    biomass = 0\n    sp.extinct = 0\n    for (sp in 1:spe){\n        sp.abund = n0.lst[[sp]][IAdults] #n0.lst is the list of abundances.  sp indexes which species is considered, and [IAdults] is an index that gets only values for adults.\n        sp.abund = sapply(sp.abund,drop.partial)\n\n        #Set up species richness and alpha diversity\n        sp.occ = sapply(sp.abund,recode)\n        #If at least one adult of a species is present somewhere, increase species richness by 1.\n        if (sum(sp.occ) > 0){\n            sp.richness = sp.richness + 1\n            }\n        if (sum(sp.occ) == 0){\n            sp.extinct = 1\n            }\n        tot.occ = tot.occ + sp.occ\n\n        abund.vec = c(abund.vec,sum(sp.abund)) #sum of sp.abund because it is the abundance for every cell in the landscape.  Right now we're ignoring that level of diversity, because I'm feeling overwhelmed.\n        nam.vec = c(nam.vec,sprintf(\"%s\",Digit(sp,2)))\n        sp.txt = sprintf(\"%s\",sp)\n        sp.biomass = sum(sp.abund) * SpTraits[sp.txt,\"biomass.adult\"] #Biomass = number of individuals * biomass of an adult individual\n        biomass = biomass + sp.biomass\n        }\n\n    #Write species richness to results\n    sp.r.lbl = sprintf(\"landscape.Sp.Rich.%s\",timepoint)\n    Results[[sp.r.lbl]][1] = sp.richness # = gamma diversity  #Could also use nbsp from the nbFD output.\n    \n    mean.richness = sum(tot.occ) / p  #alpha diversity = sum of species richness of each cell divided by the number of cells\n      #p is the extent ^ 2, which is equal to the number of cells.  But you should know that by this point in the code!+\n    \n    # Calculate beta-diversity of species richness at start of simulation\n    #B = Y/A  Y = total species diversity, A = average diversity across landscape\n      #B is the number of sub-units, if units shared no species in common.\n    beta.div = sp.richness/mean.richness  # This should be 1 for my initial scenario!\n    beta.div.lbl = sprintf(\"landscape.Beta.Div.%s\",timepoint)\n    Results[[beta.div.lbl]][1] = beta.div\n            \n    #Write biomass to results\n    biomass.lbl = sprintf(\"landscape.Biomass.%s\",timepoint)\n    Results[[biomass.lbl]][1] = biomass\n    \n    abund.vec = matrix(abund.vec,nrow = 1, dimnames = list(\"community\",nam.vec))\n        \n    return(list(Results,abund.vec))\n    }\n\n#' Extract Scale Cells\n#'\n#' Extract the indices of cells to keep (indicated by T) and those to exclude (indicated by F).\n#' Basically, the vectors that will be extracted from will have S elements for\n#' each cell. Therefore the initial scale.cells entry needs to be expanded to accomodate this.\n#'\n#' @param scale.cells.lst A list of cells to be kept\n#' @param sv An indicator\n#' @param S The number of life stages in the model\nextract.scale.cells = function(scale.cells.lst, sv, S){\n    scale.cells.vec = scale.cells.lst[[sv]]\n    scale.cells = c()\n    for (sc in scale.cells.vec){\n        scale.cells = c(scale.cells, rep(sc,S))\n        }    \n    return(scale.cells)\n    }\n\n#' Create a subset for scale cells\n#'\n#' Select just a particular value of an environmental layer for evaluating\n#' biodiversity metrics\n#'\n#' @param scale.cells.lst In this case, a text field with three parts. The first\n#' part is the word subset, the second part is the landscape.identifier to select\n#' the landscape layer, and the third part is the target value from that landscape layer\n#' @param landscape.identifiers A vector of landscape.identifiers\n#' @param landscape The landscape consisting of environmental layers\n#'\nscl.subset = function(scale.cells.lst, landscape.identifiers, landscape){\n    parts = strsplit(scale.cells.lst,\";\")[[1]]\n      this.lbl = parts[2]\n      this.val = parts[3]\n    \n    #Go to environmental layer\n    for (y in 1:length(landscape.identifiers)){\n        lbl = landscape.identifiers[y]\n        if (lbl == this.lbl){\n            this.lyr = landscape[[y]]\n            #Create a vector where values that match the target value are 1 and the rest are 0.\n            this.lyr = sapply(this.lyr, target.recode, this.val)\n            scale.cells.lst = list(this.lyr)\n            }\n        }\n        \n    return(scale.cells.lst)\n    }\n\n\n#' Convert double T's to T, otherwise set to F\n#'\n#' I'm sure this exists as a function!\n#'\n#' @param x the input to be recoded\nIA.recode = function(x){\n    y = F\n    if (x == 2){\n        y = T\n        }\n    return(y)\n    }\n\n#' Calculate output metrics\n#' \n#' Calculates output metrics for the simulation.\n#' E.g., species richness, beta diversity, biomass, and functional diversity\n#' \n#' @param Results A dataframe to contain the results\n#' @param timepoint The timpoint being calculated\n#' @param n0.lst A list of abundances of each stage for each species\n#' @param IAdults An index indicating which entries correspond to adults\n#' @param spe The total number of species in the species pool\n#' @param p The number of cells in a square landscape\n#' @param SpTraits A dataframe containing species traits\n#' @param scale.cells A list of cells to restrict the calculation to.\n#' @param sv An indicator\n#' @param num.tp An indicator for the timepoint\ncalc.metrics.v2 = function(Results,timepoint,n0.lst,IAdults,spe,p,SpTraits, scale.cells, sv, num.tp ){\n\n    #Subset the IAdults vector to only apply to the cells listed in scale.cells\n    IAdults = IAdults + scale.cells #0 = F, 1 & 2 = T, use recode & change back to T/F\n    IAdults = sapply(IAdults, IA.recode)\n\n    #Set index to be correct for timepoint and sv\n      # NOTE: This will need to change if you actually use numbered timepoints (i.e. a system other than Initial, Final, Change.\n    if (timepoint == \"Initial\"){ timepoint = 1 }\n    if (timepoint == \"Final\"){ timepoint = 2 }\n    if (timepoint == \"Change\"){ stop(\"Somehow a timepoint associated with Change entered calc.metrics.v2. This should not happen.\") }\n    \n    #ri for short!\n    ri = result.index = (sv - 1) * num.tp + timepoint  #sv - 1 makes it a multiplier of 0 for the first sv, 1 for the second, etc. Multiply by number of timepoints to get the correct offset. then add the specific timepoint information.\n\n    # Get adult abundances for the scenario, calculate species richness, alpha diversity, and biomass\n    tot.occ = 0\n    sp.richness = 0\n    abund.vec = c()\n    nam.vec = c()\n    biomass = 0\n    sp.extinct = 0\n    for (sp in 1:spe){\n        sp.abund = n0.lst[[sp]][IAdults] #n0.lst is the list of abundances.  sp indexes which species is considered, and [IAdults] is an index that gets only values for adults.\n        sp.abund = sapply(sp.abund,drop.partial)\n\n        #Set up species richness and alpha diversity\n        sp.occ = sapply(sp.abund,recode)\n        #If at least one adult of a species is present somewhere, increase species richness by 1.\n        if (sum(sp.occ) > 0){\n            sp.richness = sp.richness + 1\n            }\n        if (sum(sp.occ) == 0){\n            sp.extinct = 1\n            }\n        tot.occ = tot.occ + sp.occ\n\n        abund.vec = c(abund.vec,sum(sp.abund)) #sum of sp.abund because it is the abundance for every cell in the landscape.  Right now we're ignoring that level of diversity, because I'm feeling overwhelmed.\n        nam.vec = c(nam.vec,sprintf(\"%s\",Digit(sp,2)))\n        sp.txt = sprintf(\"%s\",sp)\n        sp.biomass = sum(sp.abund) * SpTraits[sp.txt,\"biomass.adult\"] #Biomass = number of individuals * biomass of an adult individual\n        biomass = biomass + sp.biomass\n        }\n\n    #Write species richness to results\n    sp.r.lbl = \"Sp.Rich\"\n    Results[[sp.r.lbl]][ri] = sp.richness # = gamma diversity  #Could also use nbsp from the nbFD output.\n    \n    mean.richness = sum(tot.occ) / length(sp.abund)  #alpha diversity = sum of species richness of each cell divided by the number of cells (p is replaced by length(sp.abund) because some cells may be dropped from the calculations. The length of sp.abund vector should remain the same, only the values should differ between species\n      #p is the extent ^ 2, which is equal to the number of cells.  But you should know that by this point in the code!+\n    \n    # Calculate beta-diversity of species richness at start of simulation\n    #B = Y/A  Y = total species diversity, A = average diversity across landscape\n      #B is the number of sub-units, if units shared no species in common.\n    beta.div = sp.richness/mean.richness  # This should be 1 for my initial scenario!\n    beta.div.lbl = \"Beta.Div\"\n    Results[[beta.div.lbl]][ri] = beta.div\n            \n    #Write biomass to results\n    biomass.lbl = \"Biomass\"\n    Results[[biomass.lbl]][ri] = biomass\n    \n    abund.vec = matrix(abund.vec,nrow = 1, dimnames = list(\"community\",nam.vec))\n        \n    return(list(Results,abund.vec))\n    }\n\n\n#Function to systematically calculate change in metrics.\n#' Calculate metric change\n#'\n#' Calculate changes in metrics from beginning of simulation\n#' E.g., change in species richness, or change in functional diversity\n#'\n#' @param Results The results dataframe to store the computed changes\n#' @param out.metrics The fields for which change needs to be calculated\n#' @param scale.vec A vector of indicators\ncalc.delta.metrics = function(Results,out.metrics,scale.vec){\n\n    #Simple example to get concept, then need to make it more automatic\n    #Results$Change.Num.Species = Results$Final.Num.Species - Results$Initial.Num.Species \n\n    #Calculate change for metrics in out.metrics\n    for (m in out.metrics){\n        for (sv in scale.vec){\n            im = sprintf(\"%s.%s.Initial\",sv,m)\n            fm = sprintf(\"%s.%s.Final\",sv,m)\n            dm = sprintf(\"%s.%s.Change\",sv,m)\n        \n            Results[[dm]][1] = Results[[fm]][1] - Results[[im]][1]\n            }\n        }\n    \n    # Update when re-enabling community weighted means\n    #Calculate change for metrics in lbl.lst & TraitNames\n    #for (tr in TraitNames){\n    #    for (i in lbl.lst){\n    #        im = sprintf(\"%s.I.%s\",i,tr)\n    #        fm = sprintf(\"%s.F.%s\",i,tr)\n    #        dm = sprintf(\"%s.C.%s\",i,tr)\n    #        \n    #        Results[[dm]][1] = Results[[fm]][1] - Results[[im]][1]\n    #        }\n    #    }\n\n    return(Results)\n    }\n\n#Function to systematically calculate change in metrics.\n#' Calculate metric change\n#'\n#' Calculate changes in metrics from beginning of simulation\n#' E.g., change in species richness, or change in functional diversity\n#'\n#' @param Results A dataframe containing the results to be output\n#' @param out.metrics A list of the fields for which change should be calculated\n#' @param sv an indicator\n#' @param num.tp An indicator for the timepoints\ncalc.delta.metrics.v2 = function(Results,out.metrics,sv, num.tp){\n\n    ii = initial.index = (sv - 1) * num.tp + 1  #sv - 1 makes it a multiplier of 0 for the first sv, 1 for the second, etc. Multiply by number of timepoints to get the correct offset. then add the specific timepoint information.\n    fi = final.index = (sv - 1) * num.tp + 2\n    ci = change.index = (sv -1) * num.tp + 3\n\n    #Calculate change for metrics in out.metrics\n    for (m in out.metrics){\n        Results[[m]][ci] = Results[[m]][fi] - Results[[m]][ii]\n        }\n\n    return(Results)\n    }\n\n\n#' Create base environmental layer\n#' \n#' Create a base environmental layer that can then be arranged into different\n#' configurations.\n#' %%Add details to explain different options & link to where functions are defined.\n#' \n#' @param env.info A list with three parts: one function and two parameters\n#' @param p The number of cells in the landscape\n#' @param to.round Number of decimal places in the resulting environmental layer\n#' @return returns a created environmental layer (a vector)\n#' @note Note that the created environmetnal layer is converted to a matrix by\n#' rows, rather than by columns.\n#'\nget.base.env.lyr = function(env.info,p, to.round = 1){\n    funct = env.info[[1]]\n    par1 = env.info[[2]]\n    par2 = env.info[[3]]\n\n    if (funct != \"cover\"){\n        out.base.lyr = compute.funct(p,funct,par1,par2, to.round = to.round)\n        }\n\n    #Assign based on specified cover thresholds.\n      #In this case, par1 is a list giving the cover levels for integer cover codes\n        #for example, if grassland, forest and row crops were 50%, 25% and 25% of landscape cover,\n          #this would need to be c(.5,.25,.25), and grassland would be coded 1, forest = 2, row crop = 3.\n        #par2 gives the starting number, and will ordinarily be 1.  but sometimes 0 is desired.\n    \n    if (length(par2) != 1){\n        stop(\"Environmental_layers param1 must be a single number (start of sequence)\")\n        }\n    \n    s.p = as.num(par2) - 1 #pre-cursor to the cover value - takes the starting number (par2) and subtracts 1 (because you will add at least 1 to it later)\n    #NOTE: consider moving this to compute.funct, if you think it will be used by another function (I don't think it needs an additional input, but am not positive.)\n    if (funct == \"cover\"){\n        out.base.lyr = c()\n        \n        for (cc in 1:length(par1)){ \n            \n            prop.cov = par1[cc]\n            #cov.val = par2[cc]\n\n            #check that prop.cov <= 1\n            if (prop.cov > 1){\n                stop(\"Cover proportion cannot exceed 1\")\n                }\n\n            n.cells = p * prop.cov #Get number of cells that should be of this cover type.\n    \n            #Check that this.cov is not fractional!\n            if (n.cells != round(n.cells,0)){\n                stop(\"Error: Cover levels cannot be assigned to the landscape in those proportions!\")\n                }\n\n            #Get the value to assign to this cell based on cov.val & cc\n            #s.p = cov.val - 1\n            this.cov.val = s.p + cc\n\n            add.cover = rep(this.cov.val,n.cells)\n            out.base.lyr = c(out.base.lyr,add.cover)\n            }        \n        }\n\n    return(out.base.lyr)\n    }\n\n#' Create environmental layer configuration\n#'\n#' Takes the layer generated by get.base.env.lyr and draws a sample from it\n#' to create a new environmental layer configuration\n#'\n#' @param base.lyr An environmental layer (as a vector)\n#' @return An environmental layer (as a vector)\n#' @note Note that the vectors are converted to a matrix by rows, rather than by\n#' columns\n#'\nget.env.lyr = function(base.lyr){\n    p = length(base.lyr) #This is the same as the extent^2, but redefined here, to keep the function self-contained\n    #If the landscape is 1, then sample will fail and give wrong results, so just assign the landscape\n    if (p == 1){\n        out.lyr = base.lyr\n    }else{\n        out.lyr = sample(base.lyr,p)\n        }\n\n    return(out.lyr)\n    }\n\n#Function to draw an environmental layer that requires particular conditions of another environmental layer\n#' Create conditional environmental layer\n#'\n#' Generates an environmental layer, taking into account the values of another\n#' environmental layer.  The new layer will be assigned only for particular\n#' values of the other layer, for all other values, the new layer will have the\n#' value of zero.\n#'\n#' @param env.info A list with three parts: one function code and two parameters\n#' @param p The number of cells in the landscape\n#' @param other.lyrs The other layer (or layers) to take into account\n#' @param other.lyrs.info The values in the other layer that represent suitable\n#' habitat\n#' @return An environmental layer with a value for each cell in the landscape\n#' (as a vector)\n#' @note WARNING: Not tested for conditioning on more than one layer.  It should work, but needs testing\n#'\nget.cond.env.lyr =function(env.info,p,other.lyrs,other.lyrs.info){\n\n    #Unpack env. info\n    funct = env.info[[1]]\n    par1 = env.info[[2]]\n    par2 = env.info[[3]]\n    \n    this.lyr = rep(NA,p) #Create a layer, use NA's as placeholders\n    \n    #Variable to hold suitable cells from all layers\n    suit.cells = rep(1,p) #1 indicates all are suitable\n    for (o in 1:length(other.lyrs)){\n        cur.lyr = other.lyrs[[o]]\n        cur.info = other.lyrs.info[[o]] #contains acceptable values to find\n        \n        #Create a vector to hold suitable cells from this layer (because the below will need a different join\n          #I.e. here if one value is 0 and one is 1, I want it to be 1.  But if one layer is 0 and one layer is 1, I want it to be 0.\n        layer.cells = rep(0,p)\n        \n        #Need to loop through values in cur.info, this allows more than one value to be useful\n        for (c.val in cur.info){\n            #Return index of positions in cur.lyr that match values in c.val = #Suitable cells from this \n            cell.index = which(cur.lyr == c.val)\n            layer.cells[cell.index] = 1 #Assign 1's to suitable cells\n            }\n        \n        #Change suitable cells to unsuitable #Could also do the above index approach!\n        suit.cells = suit.cells * layer.cells #This does pairwise multiplication, so a 0 anywhere will convert a suit.cell to a zero)\n        \n        }\n    \n    #Get index of positions of suitable cells\n    suit.index = which(suit.cells == 1)\n    not.suit.index = which(suit.cells == 0)\n\n    #get number of suitable cells\n    num.suit = sum(suit.cells)\n\n    #Get base values for suitable cells only\n    base.lyr = get.base.env.lyr(env.info,num.suit)\n    \n    #Draw random order for suitable cells only\n    val.lyr = get.env.lyr(base.lyr)\n    \n    #Where suit.cells == 1, assign appropriate values (these can include 0)\n    this.lyr[suit.index] = val.lyr\n\n    # otherwise, assign 0\n    this.lyr[not.suit.index] = 0 #I tried this, thinking it would be simpler, but it did not work: this.lyr[!suit.index] = ...\n\n    return(this.lyr)\n    }\n\n#' Read landscape layer\n#'\n#' Read in a landscape layer from a .csv.  Used when initially reading in a layer\n#' and if c.type == \"from.file\".\n#'\n#' @param landscape.dir The path for this model run\n#' @param lbl The name of the landscape layer being read in\n#' @param lnd.lbl A scenario specific label identifying the landscape layers to be used.\n#' @param change.count An indicator for the current environmental change step.\n#' @param p Number of cells in the landscape\n#'\nread.landscape.lyr = function(landscape.dir,lbl,lnd.lbl,change.count,p){\n\n    #Set up and read in the file\n    infile = sprintf(\"%s%s_%s.csv\",landscape.dir,lbl,lnd.lbl)\n    prep.lyr = read.table(infile, header = T, sep = \",\", row.names = 1) \n\n    #extract the layer pertaining to the current change.count\n    act.lyr = as.num(prep.lyr[as.character(change.count), ]) #change.count should indicate the appropriate row.  as.character ensures that the rowname is used, instead of the index (in case the file is reordered)\n    \n    #Check that the current layer was read in from file\n    if (is.na(act.lyr[1])){\n        stop(sprintf(\"Landscape layer read in as NA for %s change count %s.  Perhaps a record corresponding to the current ChangeStep in the landscape file is missing?\",lnd.lbl, change.count))\n        }\n            \n    #Check that the current layer has the required extent\n    if (length(act.lyr) != p){\n        stop(sprintf(\"Specified number of cells in landscape (extent^2) does not match the length of the input landscape layer %s\",lbl))\n        }\n    \n    return(act.lyr)\n    }\n\n#DD# add in ' again\n# # Read landscape layer (old)\n# #\n# # Read in a landscape layer from a .csv.  Used when initially reading in a layer\n# # and if c.type == \"from.file\".\n# #\n# # @param inpath The path for this model run\n# # @param lbl The name of the landscape layer being read in\n# # @param s.lbl A label for the scenario being considered\n# # @param change.count An indicator for which environmental change is being used.\n# #\n# read.landscape.lyr = function(inpath,lbl,s.lbl,change.count,p){\n# \n#     #Set up and read in the file\n#     infile = sprintf(\"%s%s_%s_%s.csv\",inpath,lbl,s.lbl,change.count)\n#     prep.lyr = read.csv(infile, header = F) #When written, byrows = T, so this needs to be taken into account when unpacking\n#     \n#     # Re-order the file to be in proper order and of proper type\n#     # There has to be a better way to script this\n#     act.lyr = c()\n#     for (a.row in 1:nrow(prep.lyr)){\n#         this.row = as.num(prep.lyr[a.row, ]) #As num converts it to numeric and takes it out of the weird list format - otherwise setup.matrices will crash!\n#         act.lyr = c(act.lyr,this.row)\n#         }\n#        \n#    #Check that the current layer has the required extent\n#    if (length(act.lyr) != p){\n#        stop(sprintf(\"Specified number of cells in landscape (extent^2) does not match the length of the input landscape layer %s\",env.lbl[y]))\n#        }\n#    \n#    return(act.lyr)\n#    }\n\n#' Function to set up copula\n#'\n#' This function sets up a copula for the model. A copula is a set of variables\n#' generated with a certain level of correlation.\n#'\n#' @param my.env Information about the environmental layers\n#' @param MaxTime The number of timesteps the model will be run for\n#' @param p The number of cells in a square landscape\n#' @param include.copula The number of copulas to create\n#' @param run.path The path for the analysis\n#' @param env.lbl A label\n#' @param s.lbl A label\n#'\nsetup.copula = function(my.env,MaxTime,p,include.copula,run.path,env.lbl,s.lbl){\n\n    cop.element = list(c(),c(),c(),c())\n    cop.lst = rep(list(cop.element),include.copula) #Create a list object for each copula setup.\n    #Loop through environmental layers & see which ones require the copula\n    for (y in 1:nrow(my.env)){\n        #Extract info needed for the copula & put in a list.\n        #c.mag will have:\n          # copula number (which copula this variable is part of)\n          # copula correlation (this will need to be the same & redundant between all variables with a shared copula)\n          # variable's function\n          # variable's mean\n          # variable's variance\n          \n          #e.g. 1;0.3;lnorm;2;1\n        #Extract from c.mag\n        c.mag = as.character(my.env[y, \"env.change.mag\"])\n        c.mag = strsplit(c.mag,\";\")[[1]]\n        \n        cop.num = as.num(c.mag[1])\n        this.cor = as.num(c.mag[2])\n        this.fx = c.mag[3]\n        this.mean = as.num(c.mag[4])\n        this.var = as.num(c.mag[5])\n        \n        #update copula list values\n        this.cop = cop.lst[[cop.num]]\n        cop.cor = this.cop[[1]]         #extract list\n        cop.cor = c(cop.cor, this.cor)  #append to list\n        this.cop[[1]] = cop.cor         #update list value\n        \n        cop.fxs = this.cop[[2]]         #extract list\n        cop.fxs = c(cop.fxs,this.fx)    #append to list\n        this.cop[[2]] = cop.fxs         #update list value\n        \n        cop.means = this.cop[[3]]       #extract list\n        cop.means = c(cop.means,this.mean) #append to list\n        this.cop[[3]] = cop.means       #update list\n        \n        cop.vars = this.cop[[4]]        #extract list\n        cop.vars = c(cop.vars, this.var) #append to list\n        this.cop[[4]] = cop.vars        #update list\n        \n        cop.lst[[cop.num]] = this.cop   #update copula list\n        }\n\n    #loop through each desired copula\n    for (a.cop in cop.lst){\n        #Extract values to use for the copula\n        n = MaxTime\n        correlations = a.cop[[1]]\n\n        #check that all correlation values were assigned properly (and redundantly)\n        correlation = unique(correlations)\n        if (length(correlation) != 1){\n            stop(\"Error: More than one correlation value given for a single copula\")\n            }\n\n        fxs = a.cop[[2]]              #e.g., c(\"lnorm\",\"beta\")\n        fxs.means = a.cop[[3]]\n        fxs.vars = a.cop[[4]]\n\n        # Create landscape files for stochastic variables according to a copula\n        create.stochastic.landscape(run.path,env.lbl,s.lbl,correlation,n,p,fxs,fxs.means,fxs.vars)                \n        }\n    }\n\n\n#' Create stochastic landscape\n#'\n#' Create a stochastic landscape for the stochastic plants model using a copula function\n#' In this case, it creates correlated distributions between a log-normal function\n#' (fertility) and a beta distribution (stochastic survival)\n#'\n#' @param run.path Path for the model run\n#' @param my.lyrs Layers to include in the landscape\n#' @param s.lbl A label\n#' @param n Number of samples to generate (1 per time step)\n#' @param p Number of cells in the landscape\n#' @param correlation Desired correlation level (will not be exact)\n#' @param fxs Vector of functions for the copula\n#' @param fxs.means Vector of means for the copula, in same order as functions\n#' @param fxs.vars = Vector of variances/sd for the copula, in same order as above\n#' @note Requires copula package.  Cells in the landscape will be generated independently of one another.\n#' @references Sklar 1959, others? #DD#\ncreate.stochastic.landscape = function(run.path,my.lyrs,s.lbl,correlation,n,p,fxs,fxs.means,fxs.vars){\n\n    #Get number of points needed \n    np = (n + 1) * p #need one point for every cell at every timestep (plus one for starting conditions)\n\n    #Get copula values\n    out.vals = do.copula(correlation,np,fxs,fxs.means,fxs.vars)\n    \n    #Loop through output columns - these will be the output values for each input variable\n    for (a.col in 1:ncol(out.vals)){\n        \n        this.col = out.vals[ ,a.col]\n    \n        #Loop through and output values\n        is.first = 1  #Indicator for whether this is the first time through the loop (for file creation purposes)\n        timestep = 1\n        c.start = 1\n        c.end = c.start + p - 1\n        while(c.end <= np){\n            \n            #Write to files in blocks of p\n            out.data = this.col[c.start:c.end] #Select only the values corresponding to this block\n            outdir = sprintf(\"%slandscape/\",run.path)\n            dir.create(outdir, recursive = T, showWarnings = F)\n            outfile = sprintf(\"%s%s_%s.csv\",outdir,my.lyrs[a.col],s.lbl)\n\n            write.env.lyr(out.data,timestep,sqrt(p),outfile,is.first)\n            #write.table(out.data, file = outfile, col.names = F, row.names = F, sep = \",\")\n\n            #Update variables\n            c.start = c.start + p\n            c.end = c.end + p\n            timestep = timestep + 1\n            is.first = 0\n            }\n        }\n    }\n\n\n#' Function to implement copula\n#' \n#'\n#' @param np Number of samples to generate\n#' @param correlation Desired correlation level (will not be exact)\n#' @param fxs Vector of functions for the copula\n#' @param fxs.means Vector of means for the copula, in same order as functions\n#' @param fxs.vars = Vector of variances/sd for the copula, in same order as above\n#' @note Currently only works for log-normal and beta distributions.\n#' @author Jakob Gerstenlauer & Sasha Keyel\n#' @references Sklar 1959 %DD%\n#'\ndo.copula = function(correlation,np,fxs,fxs.means,fxs.vars){\n    if (!require(copula)) { stop(\"Please install copula: install.packages('copula')\") }\n\n    marg.list = list()\n    #Set up list objects for mvdc function of the copula\n    for (f in 1:length(fxs)){\n        fx = fxs[f]\n        \n        if (fx == \"lnorm\"){\n            new.item = list( meanlog = log(fxs.means[f]), sdlog = log(fxs.vars[f]))\n            }\n\n        if (fx == \"beta\"){\n            fxs.mean = fxs.means[f]\n            fxs.var = fxs.vars[f]\n                        \n            #convert mean/var to alpha/beta of beta distribution\n            Alpha<- fxs.mean * ( (1 - fxs.mean)* fxs.mean * (1/fxs.var) - 1)\n            Beta<- (Alpha / fxs.mean) - Alpha\n            \n            new.item = list(  shape1=Alpha,    shape2=Beta)\n            }\n\n        if (fx != \"lnorm\" & fx != \"beta\"){\n            stop(\"SpatialDemography is not yet setup to incorporate copula options other than lnorm and beta\")\n            }\n\n        #WARNING:  Watch for errors in list structure if modifying!\n        #Add new list object to the margins list\n        marg.list = append(marg.list, list(new.item))\n        }\n\n    #do copula\n    #Create a new archimedean copula of family frank for two dimensions (whatever that means!)\n    n.dim = length(fxs)\n    Copula.normal<-copula::ellipCopula(family=\"normal\", dim= n.dim, dispstr=\"un\", param=correlation)\n    \n    #Create a new multivariate distribution based on the copula and two marginals\n    MultivarDist<-copula::mvdc(copula=Copula.normal, margins= fxs, paramMargins = marg.list)   \n                      \n    #Create and plot random numbers from the multivariate distribution\n    x <- copula::rMvdc(np,MultivarDist) #rmvdc in Jakob's original example is deprecated.  The new version switches the order\n\n    return(x)\n    }\n\n#DD# Do I want to add documetation for each of the inputs & outputs?  Might not be a bad idea.\n\n#' Set up model matrices\n#'\n#' This function sets up the core matrices for the matrix diagnostics and the\n#' simulation model.\n#'\n#' @param K_g Carrying capacity in grams\n#' @param spe Total number of species in the species pool\n#' @param SpTraits A dataframe containing species traits\n#' @param p The number of cells in a square landscape\n#' @param S The number of stages in the matrix model\n#' @param landscape a list of environmental layers, each with a value for each cell in the landscape\n#' @param landscape.identifiers A list of single-letter identifiers for each environmental layer\n#' @param distances Distances between each cell in the landscape\n#' @param B1.template A template for the B1 demography matrix\n#' @param B2.template A template for the B2 demography matrix\n#' @param P The vec-permutation matrix\n#' @param M_sub The M matrix template\n#' @param DispPath The path to the dispersal tables\n#' @param vdb.data An indicator for whether or not to create visual debugger data\n#' @param change.count The change step\n#' @param outpath.base The base output path.\n#' @param num.sim The number of simulations to use in creating dispersal probabilities\n#' @param run.times (optional, defaults to NA) For timing the function\n#' @param run.lbl = (optional, defaults to NA) For labeling the timing of the function\n#' @param multi.species.K (default is 0) An indicator for whether a multispecies carrying capacity is desired\n#' @param edge.type (default is \"TORUS\") An indicator for what type of landscape edge is desired.\n#'\nsetup.matrices = function(K_g,spe,SpTraits,p,S,landscape,landscape.identifiers,distances,B1.template,B2.template,P,M_sub,DispPath,vdb.data,change.count,outpath.base,num.sim,run.times = NA,run.lbl = NA,multi.species.K = 0, edge.type = \"TORUS\"){\n\n    #**# Modify to incorporate visual debugger system\n    \n    #Set up some model inputs that depend on species\n    \n    #Set up carrying capacity.  Multi-species carrying capacity is dealt with in another location\n    if (multi.species.K == 0){\n        K.lst = list()\n        for (sp in 1:spe){\n            sp.txt = sprintf(\"%s\",sp)\n            sp.biomass = SpTraits[sp.txt, \"biomass.adult\"] #Look up species adult biomass\n            K<- floor( K_g / sp.biomass )                  # Get species carrying capacity for adults in number of individuals\n            K.lst = append(K.lst,K)\n            }\n    } else {\n        K.lst = NA\n        }\n              \n    #Create the composite demography matrices B1 and B2.  Call composite.demography.matrix.description() for more information \n    ccdm.out = CreateCompositeDemographyMatrix(B1.template,B2.template,spe,SpTraits,p,S,landscape,landscape.identifiers)        \n      B1.lst = ccdm.out[[1]]\n      B2.lst = ccdm.out[[2]]\n\n      run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"composite demography matrix completed\")              \n\n    # Add eigenvalue debugger here\n    if (vdb.data == 1){\n        # NOT YET SCRIPTED\n        #EigenVis(B1.lst)\n        }\n\n    #**# Consider changing this approach to remove the species loop.\n    DispersalProbabilities.lst = list()\n    SeedDispersalRatio.lst = list()\n    M.lst = list()\n    \n    for (sp in 1:spe){\n        \n        #Get dispersal probabilities and seed dispersal ratio\n        dir.create(DispPath,showWarnings = F)\n        cdispmat.out = get.disp.prob(sp,SpTraits,p,distances,DispPath,num.sim,edge.type)\n          #DispersalProbabilities= cdispmat.out[[1]]\n          DispersalProbabilities.lst = append(DispersalProbabilities.lst,cdispmat.out[[1]])\n          #SeedDispersalRatio = cdispmat.out[[2]]           \n          SeedDispersalRatio.lst = append(SeedDispersalRatio.lst,cdispmat.out[[2]])\n          #run.times = c(run.times,gettime()); run.lbl = c(run.lbl,sprintf(\"DispersalProbabilitiesGenerated_%s\",sp))\n    \n          if (sp == 1){\n              run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Dispersal probabilities generated\")              \n              }\n        \n        #Create the composite dispersal matrix M:\n        this.M = CreateCompositeDispersalMatrix(DispersalProbabilities.lst[[sp]],p,S,M_sub)\n        M.lst = append(M.lst,this.M) \n          #run.times = c(run.times,gettime()); run.lbl = c(run.lbl,sprintf(\"Composite.Dispersal.Matrix.made_%s\",sp))\n    \n          if (sp == 1){\n              run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"composite dispersal matrix completed\")              \n              }\n        }        \n    \n    #Output data for visualizing dispersal and reporting overall eigenvalues for the matrix\n    if (vdb.data == 1){\n        # NOTE: Add dispersal visual debugger here.\n        #DispersalVis(STUFF) #NOT YET SCRIPTED\n        \n        # Calculate eigenvalue for overall landscape\n          # BROKEN, need to do checks to make sure it can be calculated (or figure out how to deal with the failed calculations\n        #CalcA(B1.lst,B2.lst,P,M.lst,change.count,outpath.base)\n        \n        #NOTE Perturbation analysis could be added here.\n        \n        }\n    \n    \n    mat.info = list(K.lst,B1.lst,B2.lst,DispersalProbabilities.lst,SeedDispersalRatio.lst,M.lst,run.times,run.lbl)\n    \n    return(mat.info)\n    }\n\n#' Create results file\n#'\n#' Set up the output results file and results dataframe\n#'\n#' @param ResultsFile The file that results will be written to.\n#' @param out.metrics The fields to be calculated\n#' @param scale.vec An indicator vector\n#' @param do.cwm An indicator for whether community weighted means should be calculated. (Needs testing, may be broken)\nsetup.results = function(ResultsFile,out.metrics,scale.vec, do.cwm = 0){\n    \n    ## Set up header for results file\n    r.hdr = c(\"Scenario.Number\",\"LastTime\")\n    tp.vec = c(\"Initial\",\"Final\",\"Change\")\n    for (k in out.metrics){\n        for (sv in scale.vec){\n            for (m in tp.vec){\n                new.item = sprintf(\"%s.%s.%s\",sv,k,m)\n                r.hdr = c(r.hdr,new.item)\n                }\n            }\n        }\n\n    if (do.cwm == 1){\n        print(\"This function is broken & cannot be implemented without script changes\")\n        }\n    \n    ## Results will be stored in a dataframe that can be updated as the script goes.\n    Results = data.frame(Scenario = NA)\n    \n    for (item in r.hdr){\n        Results[[item]] = NA\n        }\n        \n    if (!file.exists(ResultsFile)){\n        #Only output results file if one does not already exist\n        cat(file = ResultsFile,sprintf(\"Scenario,%s\\n\",(listtotext(r.hdr,separator = ','))))\n        }\n    \n    return(Results)\n    }\n\n#' Create results file in a new format\n#'\n#' Set up the output results file and results dataframe, with a row for each content type, and a row for initial, final and change\n#'\n#' @param ResultsFile The file that results will be written to.\n#' @param out.metrics The fields to be calculated\n#' @param nrow.results Number of rows in the final results file\nsetup.results.v2 = function(ResultsFile,out.metrics,nrow.results){\n    \n    #Set up header for results file\n    r.hdr = c(\"Scenario.Number\",\"Scale\",\"Timepoint\",\"LastTime\", out.metrics)\n      #Scale = what scale the metrics are calculated over\n      #Timepoint - initial, final, change, etc. (could add options for more timepoints here)    \n\n    #Set up rows for results file (& set up columns for which you already have sufficient information\n    ## Results will be stored in a dataframe that can be updated as the script goes.\n    Results = data.frame(Scenario = rep(NA, nrow.results)) \n    \n    for (item in r.hdr){\n        Results[[item]] = rep(NA, nrow.results)\n        }\n        \n    if (!file.exists(ResultsFile)){\n        #Only output results file if one does not already exist\n        cat(file = ResultsFile,sprintf(\"Scenario,%s\\n\",(listtotext(r.hdr,separator = ','))))\n        }\n    \n    return(Results)\n    }\n\n\n#' Generate species\n#'\n#' This function generates species based on the instructions given in two input\n#' files.\n#'\n#' sp.base.file contains the base vital rates and how they should be distributed\n#' in the regional species pool, while resp.traits contains information on \n#' species response traits.  This creates a regional species pool that contains\n#' a realization of a defined distribution of base vital rates and response\n#' traits.\n#' \n#' @param sp.base.file An input file containing base vital rates.\n#' See Appendix S1 (ODD protocol) for file setup & details\n#' @param sp.resp.instr.file A file containing details on the species response\n#' traits, and how they should be distributed.  Currently these are independent\n#' of the underlying base vital rates.\n#' @param sp.out.file The species file to be created\n#' @param tot.sp.num The total number of species to be generated\n#' @note Currently does not support creation of constrained species traits,\n#' although the intention is to add that functionality in future versions.\n#' WARNING There appears to be a bug in R (3.1.0) that is affecting the way\n#' some column headers are being displayed during troubleshooting. (this will\n#' not affect function users and only matters for those modifying the functions)\n#' %% Notes on function development in 2014_05_MC.docx file,\\\n#' %% under 2014-05-06 (the second one)\n#'\ngen.spp = function(sp.base.file,sp.resp.instr.file,sp.out.file,tot.sp.num){\n\n    #Set up base vital rates (may or may not be correlated/constrained\n      #External input should provide mean, standard deviation, functional form of variation\n   #Read in species base file (or not, if it is already assumed to be an R object)\n    if (typeof(sp.base.file) == \"character\"){\n        sp.base = read.csv(sp.base.file)\n    }else{\n        sp.base = sp.base.file\n        }\n    \n    #Convert first column (vital rates) to row names\n    row.names(sp.base) = sp.base$VitalRate\n    sp.base$VitalRate = NULL\n    vrs = row.names(sp.base) #Create a variable of the row names\n    \n    #Need to put the created vital rates in some sensible format.\n    vrs.out = data.frame(sp = seq(1,tot.sp.num))\n    \n    vrs.out = get.vrs(vrs.out,vrs, sp.base,tot.sp.num)\n    \n    #Check that created species are valid\n    vrs.out = check.spp(vrs.out)\n    \n    loop.counter = 0\n        \n    #Remake invalid species\n    while(max(vrs.out$is.error) > 0){\n\n        #Add emergency break if code cannot create valid species\n        loop.counter = loop.counter + 1\n        if (loop.counter == 100000){\n            stop(\"Valid species of the requisite number could not be generated.\\n Please check input species generation parameters for accuracy and whether they produce possible results\") \n            }\n            \n        #Keep valid species\n        vrs.good = vrs.out[vrs.out$is.error == 0, ]\n        \n        #Reassign values to problem species\n        vrs.bad = vrs.out[vrs.out$is.error == 1, ]\n        to.redo = nrow(vrs.bad)\n        redo.lbls = vrs.bad$sp #use species as labels\n        \n        vrs.redo = data.frame(sp = redo.lbls)\n        rownames(vrs.redo) = redo.lbls #make row names match species\n        vrs.redo = get.vrs(vrs.redo,vrs,sp.base,to.redo)\n\n        #Check that created species are valid\n        vrs.redo = check.spp(vrs.redo)\n        \n        # merge vrs.good & vrs. redo to get a single new dataframe\n        vrs.out = merge(vrs.good,vrs.redo,all = T)\n        \n        }\n\n    #Read in response traits to generate (unless it is assumed to already be an R object\n    if (typeof(sp.resp.instr.file) == \"character\"){\n        resp.traits = read.csv(sp.resp.instr.file)\n    }else{\n        resp.traits = sp.resp.instr.file\n        }\n\n    for (e.row in 1:nrow(resp.traits)){\n        resp.trait = resp.traits[e.row, ]\n    \n        #Unpack environmental layer\n        lbl = as.character(resp.trait[\"Label\"][[1]]) #apparently this is a list object, and when you do as.character, you get numbers instead of the letters!\n        opt.fun = as.num(resp.trait[\"DistributionFunction\"][[1]])\n        par1 = as.num(resp.trait[\"distfunpar1\"][[1]])\n        par2 = as.num(resp.trait[\"distfunpar2\"][[1]])\n\n        #Currently resp.fun and parameters are fixed for all species\n        resp.fun = as.num(resp.trait[\"ResponseFunction\"][[1]])\n        resp.par1 = as.num(resp.trait[\"respfunpar1\"][[1]])\n        resp.par2 = as.num(resp.trait[\"respfunpar2\"][[1]])\n                \n        #Generate optima for species\n            #No checks are included here to ensure that they are valid.  Note that all functions will be effectively truncated at 0 & 1 by a later step which will drop any species outside this range # These are truncated distributions in that sense.\n        sp.vals = compute.funct(tot.sp.num,opt.fun,par1,par2, to.round = 3)\n        vrs.out[lbl] = sprintf(\"%s;%s;%s;%s\",sp.vals,resp.fun,resp.par1,resp.par2)\n                \n        }\n\n    #Apply constraints, if any\n    #Not Scripted\n\n    #Remove internal is.error column from species file.\n    vrs.out$is.error = NULL \n\n    #Write species information to file\n    write.table(vrs.out, file = sp.out.file, sep = \",\",row.names = F)\n\n    #Convert species column to row names to use in lookups\n    rownames(vrs.out) = vrs.out$sp\n    vrs.out$sp = NULL\n\n    \n    #Return species information in R usable form\n    return(vrs.out)\n    }\n\n#' Get vital rates\n#'\n#' Function to loop through vital rates and get values\n#' @param vrs.out A vector to contain the final vital rates\n#' @param vrs A vector of vital rates\n#' @param sp.base Information about the vital rates and their distribution for species generation\n#' @param tot.sp.num Total number of species (== spe)\n#'\nget.vrs = function(vrs.out,vrs, sp.base,tot.sp.num){\n\n    #Loop through vital rates\n    for (vr in vrs){\n\n        #Assign values for each species\n        funct = sp.base[vr,1]\n        par1 = sp.base[vr,2]\n        par2 = sp.base[vr,3]\n        \n        #assign vital rates\n          #No checks are included here to ensure that they are valid.  Note that all functions will be effectively truncated at 0 & 1 by a later step which will drop any species outside this range # These are truncated distributions in that sense.\n        sp.vals = compute.funct(tot.sp.num,funct,par1,par2,to.round = 3)\n        vrs.out[vr] = sp.vals #Assign to the dataframe containing species  \n        }\n\n    return(vrs.out)\n    }\n\n#Function implement standard functions.  Used by get.base.env.lyr, gen.spp and get.vrs\n#' Implement standard functions\n#'\n#' This function implements one of several functions, based on an input code.\n#'\n#' Function codes are as follows:\n#' 1 = log-normal distribution (par1 = mean, par2 = sd)\n#' 2 = normal distribution (par1 = mean, par2 = sd)\n#' 3 = constant (par1 = value, par2 = NA)\n#' 4 = uniform distribution, continuous values\n#' (par1 = lower bound, par2 = upper bound)\n#' 5 = uniform distribution, only integer values\n#' (par1 = lower bound, par2 = upper bound, par1 & 2 must be integers!)\n#' SEE Appendix S1 ODD description for more information\n#'\n#' @param num.reps The number of values to be created\n#' @param funct The function to use to create the values\n#' @param par1 See details for chosen function\n#' @param par2 See details for chosen function\n#' @param to.round Number of decimal places to round output values\n#' @return A vector of values with length equal to num.reps\n#'\ncompute.funct = function(num.reps,funct,par1,par2 = NA,to.round = 3){\n    #If funct == 3, make the variable constant, using only par1\n    if (funct == 3){\n        out.vals = rep(par1,num.reps)\n        }\n\n    #If funct == 4, apply a uniform sampling, with par1 as the lower bound and par2 as the upper bound\n    if (funct == 4){\n        out.vals = runif(num.reps,par1,par2)\n        }\n    \n    #If funct == 5, apply uniform sampling but round to nearest integer\n    if (funct == 5){\n        \n        #check that par1 and par2 are integers. as.num ensures that character inputs are treated appropriately.\n        if (as.num(par1) != round(as.num(par1),0) | as.num(par2) != round(as.num(par2),0)){\n            stop(\"non-integer input to compute.funct is not allowed for funct == 5 (round to nearest integer)\")\n            }\n        \n        #Subtracting and adding 0.5 ensures that there is an even range around the integers.\n        out.vals = runif(num.reps,(par1 - 0.5),(par2 + 0.5))\n        out.vals = round(out.vals,0)\n        }\n\n    #If funct == 6, apply a beta distribution based on mean and variance (Not alpha and beta as is normal)\n    if (funct == 6){\n        out.vals = calc.beta(num.reps,par1,par2)\n        }\n\n    #If funct == 1, apply a log-normal distribution        \n    if (funct == 1){\n        out.vals = rlnorm(num.reps,par1,par2)\n        }\n    \n    #If funct == 2, apply a normal distribution\n    if (funct == 2){\n        out.vals = rnorm(num.reps,par1,par2)\n        }\n  \n    #Round so that you do not have a ridiculous number of digits.  to.round can be specified as NA to prevent this step.\n    if (!is.na(to.round)){\n        out.vals = round(out.vals,to.round)\n        }\n\n    #0 = none, but this currently is not supported by the code.\n    #if (funct == 0){\n        #If you wish to turn off seed dispersal, you must choose a dispersal function where all seeds remain in the cell.\n        #}\n\n\n    return(out.vals)\n    }\n\n#' Check species\n#'\n#' Check that the species that were generated are valid and realistic\n#' (e.g. no spontaneous generation)\n#'\n#' @param vrs.out The vital rates produced during species generation\n#'\ncheck.spp = function(vrs.out){\n    #Add a column to indicate whether a species is valid or not.\n    vrs.out$is.error = rep(0,nrow(vrs.out))\n\n    #Check that p01,p02,p11,p12,p22,p23,p33 each are constrained by 0 <= p <= 1\n    vr.to.check = c(\"p01\",\"p02\",\"p11\",'p12','p22','p23','p33')\n    \n    #**# Consider replacing with an apply function for speed\n    for (tc in vr.to.check){\n        #**# THIS IS RENAMING MY IS.ERROR column (when I use head(vrs.out), except that names still return is.error, and vrs.out$is.error still gives me the correct column!\n          #Very bizarre, and appears to be a bug in R?\n          #For now, just know that the second p33 is actually is.error and will respond as such!\n        vrs.out$is.error = ifelse(vrs.out[tc] < 0 | vrs.out[tc] > 1 ,1,vrs.out$is.error)\n        }\n\n    #Check that p01 + p02 <= 1 AND p11 + p12 <= 1 AND p22 + p23 <= 1\n    vr.check.p1 = c(\"p01\",'p11','p22')\n    vr.check.p2 = c(\"p02\",'p12','p23')\n    for (i in 1:length(vr.check.p1)){\n        if (length(vr.check.p1) != length(vr.check.p2)){\n            stop(\"There is an error in the error checking function check.spp\")\n        }else{\n            tc1 = vr.check.p1[i]\n            tc2 = vr.check.p2[i]\n            vrs.out$is.error = ifelse(vrs.out[tc1] + vrs.out[tc2] > 1,1,vrs.out$is.error)\n            }        \n        }\n\n    return(vrs.out)\n    }\n\n#' Set up species abundances in the landscape\n#'\n#' Set up species abundances in the landscape\n#'\n#' @param n0.lst A list of abundances for each stage for each species\n#' @param spe The total number of species in the species pool\n#' @param species.locs The locations of each species in the landscape\n#' @param S The number of life stages in the model\n#' @param initial.n A setting for initial number of species desired\n#' @param ic The initial conditions read in from the Initial Conditions File\n#' @param SpTraits The species traits, read in from the species file\nsetup.abund = function(n0.lst, spe, species.locs, S, initial.n, ic, SpTraits){\n\n    #Assign initial numbers for each species\n    #if the initial.n column is missing, set it to run the default do default assignment\n    if (length(initial.n) == 0){\n        initial.n = 1 # 1 is the default setting\n        }\n\n    #do default assignment if initial.n is 1\n    if (initial.n == 1){\n        num.adult = as.num(ic[[\"num.adults\"]]) \n        n.adult = rep(num.adult,spe) #this is the number of adults, assuming the species is initially assigned to a cell\n        n.juv = rep( (num.adult * 10) ,spe) # x10 is arbitrary\n        n.seed = rep( (num.adult * 100) ,spe) #x100 is arbitrary\n        }\n        \n    #do even biomass assignment if initial.n is 2\n    if (initial.n == 2){\n        starting.biomass = as.num(ic[[\"starting.biomass\"]])\n        n.adult = c()\n        n.juv = c()\n        n.seed = c()\n        for (sp in 1:spe){\n            stage.biomass = starting.biomass / (S - 1) #Divide biomass evenly among non-dispersing stages\n            this.ad.n = stage.biomass %/% SpTraits[sp, \"biomass.adult\"] # %/% does floor division\n            this.juv.n = stage.biomass %/% SpTraits[sp, \"biomass.juv\"]\n            this.seed.n = stage.biomass %/% SpTraits[sp, \"biomass.seed\"]\n\n            n.adult = c(n.adult, this.ad.n)\n            n.juv = c(n.juv, this.juv.n)\n            n.seed = c(n.seed, this.seed.n)\n            }\n        }\n        \n    #do approximate stable stage distribution if initial.n is 3\n    if (initial.n == 3){\n        stop(\"Option for initial.n = 3 has not yet been scripted.\")\n        }\n    \n    n0.lst = OccSetup(n0.lst,spe,species.locs,S,n.seed,n.juv,n.adult)\n    \n    return(n0.lst)\n    }\n\n\n#' Set up species locations in the landscape\n#'\n#' Function to implement one of several options for species assignment\n#' @param n0.lst An initial abundance vector containing abundances of every species at every stage for every cell\n#' @param spe The total number of species in the landscape\n#' @param p The number of cells in a square landscape\n#' @param S The number of stages in the matrix model\n#' @param ic The initial conditions read in from the initial conditions file\n#' @param settings The initial settings, read in from the initial settings file\n#' @param locations.file A file giving the species locations. If no such file exists, this parameter should be set to \"none\".\n#' @param SpTraits The Species traits, read in from the species file\n#' @param rtd.c An indicator identifiying response traits. Currently broken\n#' @param run.path The path for the analysis.\nsetup.locations = function(n0.lst, spe, S, p, ic, settings, locations.file, SpTraits, rtd.c, run.path){\n    #Test code\n    #locations = \"C:/docs/beplants/Scripts/BEO_proof_of_concept/Analysis1/Analysis1/SpeciesData.csv\"\n\n    #Old format:\n      #Locations gives the file name. The file needs to be in the inputs folder\n    #New format:\n      #locations should give a path to the file with the locations in it.\n      #This may include complicated paths, using .. for root directory options (or is it just \".\").\n\n    #locations = as.character(settings[[\"locations\"]])\n    initial.n = settings[[\"initial.n\"]] # An indicator for how the initial number of each life stage should be assigned.\n\n    is.predef = 0\n    #Check if locations field exists & is not NA\n    if (locations.file[1] != \"none\"){\n        is.predef = 1\n        }\n\n    #If SpatialDemography is assigning locations\n    if (is.predef == 0){\n        ignore.rtd = as.num(settings[[\"ignore.rtd\"]])\n        \n        land.sp.num = as.num(ic[[\"Land.sp.rich\"]])\n        patch.sp.num = as.num(ic[[\"Loc.sp.rich\"]])\n        target.tot.rtd = as.num(ic[[\"Tot.rtd\"]]) #NOTE: the actual total will be determined by species generation, but this can be used as a criteria to reject inappropriate species draws\n        land.rtd = as.num(ic[[\"Land.rtd\"]])\n        loc.rtd = as.num(ic[[\"Loc.rtd\"]])        \n        \n        #Assign species with specified levels of response trait diversity\n        if (ignore.rtd == 0){\n            rtd.setup.out = setup.rtd(SpTraits,rtd.c)\n              SpTraits = rtd.setup.out[[1]]\n              tot.rtd = rtd.setup.out[[2]]\n              unq.rtds = rtd.setup.out[[3]]\n    \n            #Check that the desired level of total.rtd was acheived\n            if (tot.rtd != target.tot.rtd){\n                warning(\"Total Response Trait Diversity does not match the level specified!\")\n                }\n    \n            #Check inputs for validity\n            check.inputs(spe,land.sp.num,patch.sp.num,tot.rtd,land.rtd,loc.rtd,p)\n    \n            #Assign species to landscape\n            species.locs = assign.spp.v3(p,loc.rtd,land.rtd,land.sp.num,patch.sp.num,unq.rtds,SpTraits)\n            }\n\n        #Assign species without respect to response trait diversity            \n        if (ignore.rtd == 1){\n            species.locs = assign.spp.v2(p,SpTraits,land.sp.num,patch.sp.num)\n            }\n        \n        #Combine species.locs with abundances to get n0.lst values for each species\n        n0.lst = setup.abund(n0.lst, spe, species.locs, S, initial.n, ic, SpTraits)        \n        }\n\n    #If using predefined locations:\n    if (is.predef == 1){\n        ex.type = as.num(settings[[\"loc.extraction\"]])\n\n        ## 2015-02-05 Dropping support for the old locations file format.\n        #If using the old locations file format\n        #if (ex.type == 0){\n        #    species.locs = old.style.locs(settings, run.path)\n        #    n0.lst = setup.abund(n0.lst, spe, species.locs, S, initial.n, ic, SpTraits)\n\n        ##Otherwise, use one of the more recent settings (structured this way because the other settings use some common inputs/code\n        #}else{\n        #Have new format of file be: LifeStage, Species, Timestep, Cells...\n          #Then a row for each (present) species\n                      \n        #p gives number of cells\n        #TimeStep = 1\n        #locations = C:/docs/beplants/Scripts/BEO_proof_of_concept/Analysis1/Analysis1/SpeciesData.csv\"\n        TimeStep = as.num(settings[[\"timestep.extraction\"]])\n\n        if (typeof(locations.file) == \"character\"){\n            in.dat = read.table(locations.file, header = T, sep = \",\")        #Read in file\n        }else{\n            #Assume the file is in R object format.\n            in.dat = locations.file\n            }\n\n        #Create a lifestage/species/timestep ID\n        in.dat$ID = sprintf(\"%s_%s\", in.dat$LifeStage, in.dat$TimeStep)\n        in.dat$LifeStage = NULL\n        in.dat$TimeStep = NULL\n        \n        Missing.Values.Seeds = 0 #Create an indicator if any year is missing.\n        Missing.Values.Juvs = 0\n        Missing.Values.Adults = 0\n        \n        #If assigning abundance via SpatialDemography, then set up species.locs list\n        #It will be length p (one entry for each cell)\n        if (ex.type == 2){ species.locs = make.species.locs(p) }\n                            \n        #Loop through lifestages & species and extract information\n        for (sp in 1:spe){\n            #Subet in.dat to only correspond to this species\n            sub.dat = in.dat[in.dat$Species == sp, ]\n            sub.dat$Species = NULL #Drop the now unnecessary column\\\n\n            #Extract information for this species\n            seed.abund = id.extract(\"Seeds\", TimeStep, sub.dat)\n            juv.abund = id.extract(\"Juveniles\", TimeStep, sub.dat)\n            adult.abund = id.extract(\"Adults\", TimeStep, sub.dat)\n\n            #Check that all extracted information extracted correctly\n            if (ex.type == 1 | ex.type == 2){\n                #If a record is missing, it will come in as NULL, with length 0.\n                  #Only give the message once\n                if (length(seed.abund) == 0){\n                    #reset vector\n                    seed.abund = rep(0,p) #Set all cell entries to 0\n                    #Warn user (once)\n                    Missing.Values.Seeds = extract.message(seed.abund, Missing.Values.Seeds, \"Seeds\", TimeStep)\n                    }\n                if (length(juv.abund) == 0){\n                    #Set up vector as 0's\n                    juv.abund = rep(0,p)\n                    #Warn user (once)\n                    Missing.Values.Juvs = extract.message(juv.abund, Missing.Values.Juvs, \"Juveniles\", TimeStep)\n                    }\n                }\n            \n            #Check that an adult abundance was read in, otherwise set adult abundance to 0.\n            if (length(adult.abund) == 0){\n                #Set up vector as 0's\n                adult.abund = rep(0,p)\n                #Warn user (once)\n                Missing.Values.Adults = extract.message(adult.abund, Missing.Values.Adults, \"Adults\", TimeStep)\n                }   \n                                            \n            #Create indices - first place is blank - mobile seeds, second is seeds, third is juveniles, fourth is adults\n              #n0.lst is a list by species (so loop through by species first.\n                #within that list, is a p & S vector\n                # elements correspond to:\n                # S = adults\n                # S - 1 = juveniles\n                # S - 2 = seeds\n                # S - 3 = mobile seeds, needs to be initialized at 0.\n            len = p * S\n            s.indices = seq((S-2),(len-2),S)\n            j.indices = seq((S-1),(len-1),S)\n            a.indices = seq(S,len,S)\n\n            #If using extracted abundances, assign to cell\n            if (ex.type == 1){\n                #n0.lst = list(rep(0, p *S), rep(0, p*S)) #For testing purposes\n                n0.lst[[sp]][s.indices] = seed.abund\n                n0.lst[[sp]][j.indices] = juv.abund\n                n0.lst[[sp]][a.indices] = adult.abund\n                }\n            \n            #If using presences & predefined abundances, calculate presences, and then handle as above.\n            if (ex.type == 2){\n                pres = seed.abund + juv.abund + adult.abund\n                proto.locs = sapply(pres,recode)\n                \n                #Loop through cells and set up species.locs based on presences\n                for (cell in 1:length(proto.locs)){\n                    this.val = species.locs[[cell]] #Get previous list of species\n\n                    #Add species if present\n                    if (proto.locs[cell] == 1){\n                        this.val = c(this.val, sp) \n                        }\n                    species.locs[[cell]] = this.val\n                    }\n                }     \n\n            #If using only adult numbers in a hybrid approach:\n              #At some point expand, and see if you can use common functions with setup.abund to streamline functionality.\n            if (ex.type == 3){\n                n0.lst[[sp]][a.indices] = adult.abund\n\n                if (length(initial.n) == 0){ initial.n = 1 } #Set default behavior to be 1\n\n                #Set up juvenile and seed abundances in a simplified manner                    \n                if (initial.n == 1){\n                    n0.lst[[sp]][j.indices] = adult.abund * 10\n                    n0.lst[[sp]][s.indices] = adult.abund * 100\n                    }\n                \n                if (initial.n == 2){\n                    a.bio = SpTraits[sp, \"biomass.adult\"]\n                    j.bio = SpTraits[sp, \"biomass.juv\"]\n                    s.bio = SpTraits[sp, \"biomass.seed\"]\n                    tot.biomass = a.bio + j.bio + s.bio\n                    #Get starting overall biomass with equal biomass in each stage\n                      #adult.abund = (a.bio / tot.bio) * start.bio\n                    start.bio = (tot.biomass / a.bio ) * adult.abund\n                    \n                    n0.lst[[sp]][j.indices] = start.bio / j.bio\n                    n0.lst[[sp]][s.indices] = start.bio / s.bio\n                    }\n                \n                if (initial.n != 1 & initial.n != 2){\n                    stop(\"That option has not yet been scripted for extraction type 3!\")\n                    }\n\n                }\n\n            }\n\n        #Finish processing outside species loop for extraction type 2.\n        if (ex.type == 2){\n            #Set up as for old.style.locs\n            n0.lst = setup.abund(n0.lst, spe, species.locs, S, initial.n, ic, SpTraits)\n            }\n\n        }\n    return(n0.lst)\n    }\n\n#' ID Extract\n#'\n#' Simple extraction function to streamline code\n#' @param Stage The lifestage to be extracted\n#' @param TimeStep The timestep to be extracted\n#' @param sub.dat The dataset containing the data to extract from.\nid.extract = function(Stage, TimeStep, sub.dat){\n\n    ex.id = sprintf(\"%s_%s\",Stage, TimeStep)\n    this.abund = sub.dat[sub.dat$ID == ex.id, ]\n    this.abund = this.abund[1:(length(this.abund) - 1)] #Drop ID field\n    this.abund = as.num(as.matrix(this.abund)) #Convert from list (?!?) to matrix format.\n    return(this.abund)\n    }\n\n\n#' Give extraction message\n#'\n#' Give message if extraction failed for a lifestage and timestep (but only if a similar warning has not already been given.\n#'\n#' @param abund.vec A vector of abundances\n#' @param Missing.Values An indicator for whether or not there were missing values (prevents repeat messages)\n#' @param Stage The stage where the first missing value was detected\n#' @param TimeStep The timestep where the first missing value was detected.\nextract.message = function(abund.vec, Missing.Values, Stage, TimeStep){\n\n    if (Missing.Values == 0){\n        message(sprintf(\"Missing values detected for %s for TimeStep %s\", Stage, TimeStep))\n        Missing.Values = 1\n        flush.console()\n        }\n    return(Missing.Values)\n    }\n\n#' Make species locations element\n#'\n#' Helper function for extraction type 2\n#' The initial entry will be labeled \"none\", so as not to confuse the regex experession.\n#' \n#' @param p The number of cells in a square landscape\nmake.species.locs = function(p){\n    none = \"none\"\n    species.locs  = list() #Initialize a variable needed for extraction type 2\n    for (i in 1:p){\n        species.locs = append(species.locs,list(none))\n        }\n    \n    return(species.locs)\n    }\n\n#' Original format for locations file\n#'\n#' Preserves backwards compatibility, will probably be deprecated at some point.\n#'\n#' @param settings The settings from the read-in settings file\n#' @param run.path The path for the analysis run\nold.style.locs = function(settings, run.path){\n    #Pull up species info using locations setting\n    locations = as.character(settings[[\"locations\"]])\n    loc.file = sprintf(\"%sinputs/%s\",run.path,locations) #run.path gives the path for the run folder and locations should give info pointing to the specific file to use\n    species.locs.raw = read.table(loc.file, header = F, sep = \",\")        #Read in file\n\n    #Format of species.locs is a list entry for each cell, and the list gives the species present in the cell.\n    #So, the locations file needs to have a row for each cell, and in each row, should give species values separated by commas.       \n    #Reformat input to match species.locs format\n    species.locs = list()\n    for (a.row in 1:nrow(species.locs.raw)){\n        this.row = species.locs.raw[a.row, ]\n        this.row = this.row[!is.na(this.row)]\n        species.locs = append(species.locs,list(this.row))\n        }\n    \n    return(species.locs)\n    }\n\n\n\n#' Assign species to the landscape (v2)\n#'\n#' Function to assign species to the landscape randomly (without respect to\n#' response trait diversity.\n#' @param p The number of cells in a square landscape\n#' @param in.spp SpTraits object\n#' @param land.sp.num Number of species in the landscape\n#' @param patch.sp.num Number of species in each patch\n#'\nassign.spp.v2 = function(p,in.spp,land.sp.num,patch.sp.num){\n    #Subsample from the species pool\n    sp.vec = as.num(rownames(in.spp))\n    land.sp = sample.fixed(sp.vec,land.sp.num)\n        \n    #Loop through cells, assign the requisite number of species (?why not use apply here?    \n    a.out = assign.loop(land.sp,patch.sp.num,p)\n      spp.lst = a.out[[1]]\n      spp.check = a.out[[2]]\n    \n    #Add check that appropriate number of species ended up in landscape,\n    loop.count = 0\n    while (spp.check != land.sp.num){\n\n        #increment loop counter and break if you reach 1000 iterationc\n        loop.count = loop.count + 1\n        if (loop.count >= 1000){\n            stop(\"Error: Could not assign species to landscape\")\n            }\n            \n        #if not, redo        \n        a.out = assign.loop(land.sp,patch.sp.num,p)\n          spp.lst = a.out[[1]]\n          spp.check = a.out[[2]]\n        \n        }\n        \n    return(spp.lst)\n    }\n\n#' Assign loop\n#'\n#' Helper function for randomly assigning species to the landscape\n#'\n#' @param land.sp Species drawn for the landscape\n#' @param patch.sp.num Number of species to draw for each patch\n#' @param p The number of cells in a square landscape\nassign.loop = function(land.sp,patch.sp.num,p){\n\n    spp.lst = list()\n    spp.check = c()\n\n    #Deal with special case that each cell requires unique species\n      #(the randomization approach below is slow and often fails in this circumstance)\n    if (patch.sp.num * p == length(land.sp)){\n\n        index1 = 1\n        index2 = patch.sp.num\n        for (cell in 1:p){\n            patch.sp = land.sp[index1:index2] #Take the first n species, where n is the number of species in each patch\n            spp.lst = append(spp.lst,list(patch.sp))\n            spp.check = c(spp.check,patch.sp)\n\n            #Increment the indices for the next run\n            index1 = index1 + patch.sp.num\n            index2 = index2 + patch.sp.num\n            }    \n\n    # Otherwise, do species assignment through a randomized approach\n    }else{\n        for (cell in 1:p){\n            patch.sp = sample.fixed(land.sp,patch.sp.num)\n            spp.lst = append(spp.lst,list(patch.sp))\n            spp.check = c(spp.check,patch.sp)\n            }\n        }\n    \n    #Find out how many unique species are in the landscape\n    spp.check = length(unique(spp.check))\n    \n    return(list(spp.lst,spp.check))\n    }\n\n#Function to check that inputs are valid and logical\n#' Check inputs\n#'\n#' Function to check that inputs for random species assignment are valid and\n#' logical.  For example, local patch diversity cannot exceed landscape diversity\n#' @param tot.sp.num total number of species in the species pool\n#' @param land.sp.num Number of species in the landscape\n#' @param patch.sp.num Total number of species in each patch\n#' @param tot.rtd total response trait diversity in the species pool\n#' @param land.rtd total response trait diversity in the landscape\n#' @param loc.rtd Response trait diversity in each patch\n#' @param p The number of cells in a square landscape\n#'\ncheck.inputs = function(tot.sp.num,land.sp.num,patch.sp.num,tot.rtd,land.rtd,loc.rtd,p){\n\n    #Check that species numbers are legitimate\n    if (tot.sp.num < land.sp.num){\n        stop(\"Total species number cannot be less than landscape species number!\")}\n    if (land.sp.num < patch.sp.num){\n        stop(\"Landscape species number cannot be less than patch species number!\")}\n    if (tot.rtd < land.rtd){\n        stop(\"Total response trait diversity cannot be less than landscape response trait diversity\")}\n    if (land.rtd < loc.rtd){\n        stop(\"Landscape response trait diversity cannot be less than patch response trait diversity\")}\n    if (land.sp.num > (p * patch.sp.num)){\n        stop(\"Landscape species number cannot exceed number of cells times patch species number\")}\n    if (land.rtd > (p * loc.rtd)){\n        stop(\"Landscape response trait diversity cannot exceed number of cells times patch response trait diversity\")}\n    if (land.rtd > land.sp.num){\n        stop(\"Landscape response trait richness cannot exceed landscape species number!\")}\n    if (loc.rtd > patch.sp.num){\n        stop(\"Patch response trait richness cannot exceed patch species number!\")}\n\n    #NOTE: Are there other criteria that need to be included?\n    }\n\n#' Estimate Response Trait Diversity\n#'\n#' This function takes a dataframe with species information, and calculates\n#' the response trait diversity present (giving each species a response trait\n#' diversity number that corresponds to a unique combination.  Some formatting\n#' caveats apply. Dispersal traits need to be in columns 11 - 13, and any\n#' remaining response traits in columns 14+\n#'\n#' @param SpTraits A dataframe with species information\n#' @param rtd.c Currently non-functional input\n#' @return The SpTraits dataframe with a unique code assigned to each response\n#' type\n#'\nsetup.rtd = function(SpTraits,rtd.c = 0){\n\n      #Identify response traits\n        #**# Sub-optimal approach to start with for selecting response traits (because it is hardwired to column position\n      #If there are other response traits, include them\n      if (ncol(SpTraits) > 13){\n          rtd.index = c(11,12,13,14:ncol(SpTraits))\n      #If not, only include mandatory dispersal traits\n      }else{\n          rtd.index = c(11,12,13)\n          }\n      \n      rtd.mat = SpTraits[ , rtd.index]\n\n      #NOTE: Consider adding code to classify response traits into categories\n\n      #Create a funcitonal unit matrix\n      rtd.fu.mat = rtd.mat[!duplicated(rtd.mat), ]\n\n      #Get unique response trait values\n      tot.rtd = nrow(rtd.fu.mat)\n      unq.rtds = seq(1,nrow(rtd.fu.mat))\n\n      #Assign numbers to it\n      rtd.fu.mat[\"RTD_ID\"] =  unq.rtds\n      \n      #Assign those numbers to species matching the functional unit\n      #**# This could be optimized\n      #Join back to rtd.mat\n      rtd.id = c()\n      for (a.row in 1:nrow(rtd.mat)){\n          this.row = listtotext(rtd.mat[a.row, ],\",\")\n          \n          for (b.row in 1:nrow(rtd.fu.mat)){\n              e.p = ncol(rtd.fu.mat) - 1 #Set the endpoint to exclude the added column\n              test.row = listtotext(rtd.fu.mat[b.row,1:e.p],\",\")\n              \n              if (this.row == test.row){\n                  rtd.val = rtd.fu.mat[b.row,ncol(rtd.fu.mat)] #Take value from last column (added - has RTD_ID)\n                  rtd.id = c(rtd.id,rtd.val)\n                  break #End this loop and go to the next row in rtd.mat\n                  }\n              }\n          }\n                \n      #Join from rtd.mat to SpTraits\n      #NOTE: This requires that SpTraits is in the same order as rtd.id. This is suboptimal, and could be broken by upstream changes.\n      SpTraits[\"RTD_ID\"] = rtd.id \n\n    return(list(SpTraits,tot.rtd,unq.rtds))\n    }\n\n#DD# Figure out how to have the documentation for this and v2 appear together\n#' Assign species to the landscape (v3)\n#'\n#' Assign species to the landscape, meeting certain response trait diveristy\n#' constraints.\n#'\n#' @param p The number of cells in a square landscape\n#' @param loc.rtd The response trait diversity in each patch\n#' @param land.rtd The response trait diversity in the landscape\n#' @param land.sp.num The number of species in the landscape\n#' @param patch.sp.num The number of species in each patch\n#' @param unq.rtds unq.rtds\n#' @param SpTraits Species trait information from species file\n#' @note This is not an optimal implementation, and could benefit from some\n#' optimization.  This is especially a problem when there is only one or a few\n#' valid configurations of species.  This is because species are chosen and\n#' removed randomly, so it takes a long time (if ever) to find the valid\n#' configuration(s).\n#' @return Returns a list of species locations in the landscape\n#'\nassign.spp.v3 = function(p,loc.rtd,land.rtd,land.sp.num,patch.sp.num,unq.rtds,SpTraits){\n\n    #Set up two lists to contain warning messages.  List 1 is whether the warning occurred at all, List 2 is whether the warning occured on the last iteration\n    warn.lst1 = list(0,0,0,0,0,0)\n\n    #Function setup\n    do.over = 1         #Indicator variable to determine whether a new draw is needed\n    d.o.count = 0\n    while (do.over == 1){\n\n        #Reset warning list 2\n        warn.lst2 = list(0,0,0,0,0,0)\n\n    \n        d.o.count = d.o.count + 1\n        if (d.o.count > 10){\n            #Issue warnings\n            do.warn(warn.lst1,warn.lst2)\n            stop(\"Assign.spp.v3 failed for one or more reasons.  See warnings for more details.\")\n            }\n    \n        #Get a list of the cells in the landscape\n        species.locs = rep(list(\"NI\"),p) #NI for not initialized\n        #Create a vector of which response traits were used and in which cells they were used\n        # note: this will increase by increments of loc.rtd, so when random cells are replaced, the appropriate part of this vector can be replaced simultaneously\n        used.rt.vec = c()    \n        #Create a vector of used species to assess whether all species have been assigned\n        used.spp.vec = c()\n        \n        #Select a subset of response traits based on specificed landscape response trait diversity levels\n        rtds.to.use = sample.fixed(unq.rtds, land.rtd)\n    \n        #Create a subset of species that correspond to the subset of response traits present\n        sp.subset = SpTraits[SpTraits$RTD_ID %in% rtds.to.use, ] #Gets species where the response type matches the ones selected for use\n    \n        s.a.out = s.a.check(SpTraits,sp.subset,land.sp.num,land.rtd,unq.rtds,rtds.to.use,\"landscape\",warn.lst1,warn.lst2)\n          rtds.to.use = s.a.out[[1]]\n          sp.subset = s.a.out[[2]]\n          do.over = s.a.out[[3]]\n          warn.lst1 = s.a.out[[4]]\n          warn.lst2 = s.a.out[[5]]\n    \n        if (do.over != 1){\n            #Go through each cell in the landscape\n            for (cell in 1:p){\n        \n                p.a.out1 = patch.assign.v2(rtds.to.use,loc.rtd,sp.subset,patch.sp.num,warn.lst1,warn.lst2)\n                  loc.spp = p.a.out1[[1]]\n                  rtds.pres = p.a.out1[[2]]\n                  do.over = p.a.out1[[3]]\n                  warn.lst1 = p.a.out1[[4]]\n                  warn.lst2 = p.a.out1[[5]]\n\n                #If the patch.assign.v2 fails, try a new version of the loop - break out of for loop and reset\n                if (do.over == 1){\n                    break\n                    }\n                \n                species.locs[cell] = list(loc.spp)\n                used.rt.vec = c(used.rt.vec, rtds.pres)\n                used.spp.vec = c(used.spp.vec, loc.spp)               \n                }\n            }\n\n        if (do.over != 1){\n            #Check to make sure all response traits selected at the landscape level have been assigned to the landscape\n            rt.test = unique(used.rt.vec)\n            us.test = unique(used.spp.vec)\n            wcount = 0\n            while (length(rt.test) != land.rtd | length(us.test) != land.sp.num){\n                warn.message5 = \"Some cells needed to be resampled to meet landscape requirements.  Data are no longer truly random\"\n                warn.lst1[[5]] = warn.lst2[[5]] = warn.message5\n                #warning(\"Some cells needed to be resampled to meet landscape requirements.  Data are no longer truly random\")\n                #Select a random cell\n                ctr = cell.to.replace = sample(p,1) #note: this use of sample pulls a number from 1:p\n                #Replace its values\n                pa.out2 = patch.assign.v2(rtds.to.use,loc.rtd,sp.subset,patch.sp.num,warn.lst1,warn.lst2) #These are from the old version: (loc.rtd,patch.sp.num,rt.lst,rt.types)\n                species.locs[[ctr]] = pa.out2[[1]]\n                used.rt = pa.out2[[2]] #Get used response traits\n                used.spp = pa.out2[[1]] #Get used species\n                do.over = pa.out2[[3]]\n                warn.lst1 = pa.out2[[4]]\n                warn.lst2 = pa.out2[[5]]\n                \n                #If patch assign fails, break out of loop, and try again\n                if (do.over == 1){\n                    break\n                    }\n                \n                #update rt.test & us.test\n                #The logic for the start and end points is as follows:\n                  # 1 will make it so the starting cell is 1\n                  # (ctr - 1) * loc.rtd will offset the starting cell based on the cell number multiplied by the number of local response traits (in the vector being used).  it is ctr - 1 so that when ctr is 1, this quantity is zero, and no offset is employed.\n                  # The end point is the same as the start point, plus (loc.trd - 1).  Add local response trait diversity, but subtract one because the range includes the first number of the index\n                  # Same logic applies to patch.sp.num        \n                aa = used.rt.index.start = 1 + (ctr - 1) * loc.rtd\n                bb = used.rt.index.end = 1 + (ctr - 1) * loc.rtd + (loc.rtd - 1)\n                cc = used.spp.index.start = 1 + (ctr - 1) * patch.sp.num\n                dd = used.spp.index.end = 1 + (ctr - 1) * patch.sp.num + (patch.sp.num - 1)\n                used.rt.vec[aa:bb] = used.rt #Replace the old cell's values with the new values\n                used.spp.vec[cc:dd] = used.spp #Replace the old cell's values with the new values\n                #Update criteria used to test the while loop\n                rt.test = unique(used.rt.vec)\n                us.test = unique(used.spp.vec)\n                        \n                #repeat loop until conditions are satisfied or loop fails.\n                \n                # Add a break to avoid getting infinitely stuck for impossible conditions\n                wcount = wcount + 1\n                if (wcount >= 1000){\n                    warn.message6 = \"Something went wrong when trying to assign landscape-wide response trait diversity or total species numbers\"\n                    warn.lst1[[6]] = warn.lst2[[6]] = warn.message6\n                    #warning(warn.message6)\n                    do.over = 1\n                    break\n                    }\n                }\n            }\n        }\n    \n    #Issue warnings\n    do.warn(warn.lst1,warn.lst2)\n        \n    return(species.locs)\n    }\n\n#DD# Figure out how this is different from check.inputs & decide if the two should be documented together\n#' Check species availability\n#'\n#' Check that the number of species available is greater than the number of\n#' species needed based on response trait diversity\n#' If not, re-draw until the criteria is reached or until the code gives up.\n#'\n#' @param my.set my.set\n#' @param my.subset my.subset\n#' @param target.sp.num target.sp.num\n#' @param target.rtd target.rtd\n#' @param draw.pool draw.pool\n#' @param my.draw my.draw\n#' @param chk.type chk.type\n#' @param warn.lst1 A list of warnings\n#' @param warn.lst2 A second list of warnings\n#'\ns.a.check = function(my.set,my.subset,target.sp.num,target.rtd,draw.pool,my.draw,chk.type,warn.lst1,warn.lst2){\n  #(SpTraits,sp.subset,land.sp.num,land.rtd,unq.rtds,rtds.to.use,\"landscape\") #For landscape check\n  #sp.subset,loc.sp.subset,patch.sp.num,loc.rtd,rtds.to.use,loc.rtds.to.use,\"patch\" #For species check\n    do.over = 0 #If there is an error, this will change to 1, and a new draw will be tried\n\n    #If entered, hopefully only restriction will occur.  If a new draw occurs, issue a warning about non-randomness.\n    w.count = 0\n    d.count = 0 #I want a counter \n    while (nrow(my.subset) != target.sp.num){\n        w.count = w.count + 1\n        \n        if (w.count > 10){\n            warn.message1 = sprintf(\"s.a.check could not assign species. \\n Not enough species per response type to get required %s species numbers and meet landscape response trait diversity target\\n based on %s draws. \\n Will try again with a different main draw\",chk.type,w.count)\n            warn.lst1[[1]] = warn.lst2[[1]] = warn.message1            \n            #warning(warn.message1)\n            \n            #break out of the loop and try a new overall draw\n            do.over = 1\n            break\n            }\n        if (nrow(my.subset) < target.sp.num){\n            #Do a new draw\n            d.count = d.count + 1\n            my.draw = sample.fixed(draw.pool, target.rtd)\n            my.subset = my.set[my.set$RTD_ID %in% my.draw, ] #Gets species where the response type matches the ones selected for use\n            }\n        \n        #Restrict down to appropriate species number & check that RTD is still appropriate\n        if (nrow(my.subset) > target.sp.num){\n            spp.subset.out = spp.subset(my.subset,target.rtd,target.sp.num,warn.lst1,warn.lst2)\n             my.subset = spp.subset.out[[1]]\n             do.over = spp.subset.out[[2]]\n             warn.lst1 = spp.subset.out[[3]]\n             warn.lst2 = spp.subset.out[[4]]           \n            }        \n        }\n\n    #Issue warning that a new draw(s) was taken (i.e., the draws are no longer completely random)\n    if (d.count >= 1){\n        warn.message2 = \"Species assignment not completely random as initial response trait type draws did not contain sufficient species to meet required landscape level species diversity\"\n        warn.lst1[[2]] = warn.lst2[[2]] = warn.message2 \n        #warning(sprintf(\"%s. %s new draws taken\",warn.message2,d.count))\n        }\n\n    return(list(my.draw,my.subset,do.over,warn.lst1,warn.lst2))\n    }\n\n#' Species subset\n#'\n#' Function to reduce species number from a regional species pool to the target\n#' species number.\n#'\n#' @param my.subset A subset\n#' @param target.rtd a response trait diversity target\n#' @param target.sp.num The target species number\n#' @param warn.lst1 A list of warnings\n#' @param warn.lst2 A second list of warnings\n#'\nspp.subset = function(my.subset,target.rtd,target.sp.num,warn.lst1,warn.lst2){\n\n    do.over = 0\n\n    #If subset has too many species, restrict this subset to the desired number of species\n    spp.draw = sample.fixed(rownames(my.subset),target.sp.num)\n    my.subset2 = my.subset[rownames(my.subset) %in% spp.draw, ]\n\n    ms2.rtd = unique(my.subset2$RTD_ID)\n    ww.count = 0\n    while (length(ms2.rtd) != target.rtd){\n        ww.count = ww.count + 1\n        if (ww.count > 100){\n            warn.message3 = sprintf(\"spp.subset function could not successfully subset species \\n and maintain response trait diversity after %s iterations.\\n so a new draw was evaluated\",ww.count)\n            warn.lst1[[3]] = warn.lst2[[3]] = warn.message3\n            #warning(warn.message3)\n            do.over = 1\n            my.subset2 = data.frame() #Set it as a blank dataframe, this will give nrow = 0, so will fail the while loop criteria in s.a.check and lead to a new draw\n            break\n            }\n            \n        spp.draw = sample.fixed(rownames(my.subset),target.sp.num)\n        my.subset2 = my.subset[rownames(my.subset) %in% spp.draw, ]\n\n        #Check that desired response trait diversity is still present in sub-setted species, if not, try again.\n        ms2.rtd = unique(my.subset2$RTD_ID)\n        }\n\n    return (list(my.subset2,do.over,warn.lst1,warn.lst2))\n    }    \n\n#ll# Left off here in updating documentation. Just couldn't take it anymore!\n\n#' Patch level species assignment\n#'\n#' Function to do local assignment\n#' (function so that it can be invoked at multiple points in the code)\n#' @param rtds.to.use rtds.to.use\n#' @param loc.rtd Local response trait diversity level\n#' @param sp.subset sp.subset\n#' @param patch.sp.num Number of species in a patch\n#' @param warn.lst1 First warning list\n#' @param warn.lst2 Second warning list\n#'\npatch.assign.v2 = function(rtds.to.use,loc.rtd,sp.subset,patch.sp.num,warn.lst1,warn.lst2){\n\n    do.over = 0\n\n    #Draw a subset of response traits to indicate which should be present at this patch\n    loc.rtds.to.use = sample.fixed(rtds.to.use,loc.rtd)\n    \n    #For each patch, select a subset of response traits to match specified patch levels of response trait diversity levels\n    loc.sp.subset = sp.subset[sp.subset$RTD_ID %in% loc.rtds.to.use, ]        \n\n    #check that loc.sp.subset has enough species\n    s.a.out2 = s.a.check(sp.subset,loc.sp.subset,patch.sp.num,loc.rtd,rtds.to.use,loc.rtds.to.use,\"patch\",warn.lst1,warn.lst2)\n      loc.rtds.to.use = s.a.out2[[1]]\n      loc.sp.subset = s.a.out2[[2]]\n      do.over = s.a.out2[[3]]\n      warn.lst1 = s.a.out2[[4]]\n      warn.lst2 = s.a.out2[[5]]\n\n    if (do.over != 1){\n\n        #Then for each patch/cell, draw species from the pool restricted by chosen response traits until the required species number is reached\n        species.pool = row.names(loc.sp.subset) #Get list of potential species as a vector\n        #Set initial conditions to be changed by while loop\n        obs.rtd = 0\n        w.count = 0\n        \n        #Run loop until desired response trait diveristy is acheived\n          #because obs.rtd is initially defined as 0, the loop will be entered the first time & executed at least once\n        while (obs.rtd != loc.rtd){\n            w.count = w.count + 1\n            if (w.count >= 1000){\n                warn.message4 = sprintf(\"patch.assign.v2: Unable to assign response trait diversity to local patch in %s attempts.\\n Possible error in code (e.g., patch species number lower than required response trait diversity),\\n or code requires optimization or an increase in the number of allowed iterations.\\n Will try a new rtd combination\",w.count)\n                warn.lst1[[4]] = warn.lst2[[4]] = warn.message4\n                #warning(warn.message4)\n                do.over = 1\n                break\n                }\n                           \n            loc.spp = sample.fixed(species.pool,patch.sp.num) #Get the desired number of species from the species pool\n            patch.subset = loc.sp.subset[rownames(loc.sp.subset) %in% loc.spp, ]  #Subset the dataframe to the selected species\n            rtds.pres = unique(patch.subset$RTD_ID)  #Get a vector of their RTD's\n            obs.rtd = length(rtds.pres) #Find out how many of the rtd values are unique to check that the patch has the right amount of rtd\n            }\n        }\n\n    #Code needs something to return for loc.spp, otherwise it will complain that it was undefined.\n    if (do.over == 1){\n        rtds.pres = NA\n        loc.spp = NA\n        }\n\n    return(list(loc.spp,rtds.pres,do.over,warn.lst1,warn.lst2))\n    }\n\n#' Issue warnings\n#'\n#' Function to issue warnings\n#'\n#' @param warn.lst1 First warning list\n#' @param warn.lst2 Second warning list\ndo.warn = function(warn.lst1,warn.lst2){\n\n    #Convert warning lists to text\n    warn.lst1.out = listtotext(warn.lst1,\"\\n\")\n    warn.lst2.out = listtotext(warn.lst2,\"\\n\")\n\n    no.warn = listtotext(rep(0,6),\"\\n\")\n\n    #Set up warning output message\n    warn.out1 = sprintf(\"The following overall warning messages were issued:\\n%s\", warn.lst1.out)    \n    warn.out2 = sprintf(\"The following warnings apply to the last model run:\\n%s\", warn.lst2.out)\n\n    #Actually issue warnings here (but only if there actually are warnings!)\n    if (warn.lst1.out != no.warn){\n        warning(warn.out1)\n        }\n    if (warn.lst2.out != no.warn){\n        warning(warn.out2)\n        }\n    }\n\n#' Check for environmental change\n#'\n#' Test if there will ever be environmental changes in a model run\n#' @param env.c.freq Frequency of environmental change\n#'\nchange.check = function(env.c.freq){\n    is.change = 0\n    if (max(env.c.freq) > 0){\n        is.change = 1\n        }\n    return(is.change)\n    }\n\n#' Get conditioning layer\n#'\n#' Function to get the values from the conditioning layer\n#' @param target.cond.lyr The layer to use for creating conditional values\n#' @param landscape A list object containing the environmental layer values for each cell in the landscape\n#' @param landscape.identifiers A list of single letter identifiers for each environmental layer\n#'\ncv.setup = function(target.cond.lyr, landscape,landscape.identifiers){\n    to.find = sprintf(\"\\\\b%s\\\\b\",target.cond.lyr) #\\b looks for boundaries - so this makes sure only the search term matches, and not larger numbers that include the search term.  The \\ needs a \\ in order for R to interpret it as a \\, and not as something else (i.e., an escape character). Otherwise a search for species 1 will return wrong matches, e.g., 41 or 14!\n    cond.lyr.id = grep(to.find,landscape.identifiers)\n    cond.lyr = list(landscape[[cond.lyr.id]]) #Get the actual layer from the landscape.  Obviously, this requires it to have already been created.\n    return(cond.lyr)\n    }\n\n#' Set up env.info variable\n#'\n#' Function to set up env.info and reduce code redundancy and increase\n#' streamlining\n#' @param env.type An indicator for what type of environmental values are present (e.g., cover, normal random) \n#' @param my.env Information about the environmental layers\n#' @param index An index\n#'\nsetup.env.info = function(env.type,my.env,index){\n\n    param1 = my.env[index,\"param1\"]\n    param2 = my.env[index,\"param2\"]\n\n    if (env.type == \"cover\"){\n        cover.levels = as.character(my.env[index,\"cover.levels\"])\n        cover.levels = as.num(strsplit(cover.levels,\";\",fixed = T)[[1]]) #The [[1]] is because strsplit puts the vector I want in a list.\n        \n        param1 = as.num(param1)\n        env.info = list(env.type,cover.levels,param1)\n        }\n    # NOTE: This is an artifact, as it could be set up using the function codes\n    if (env.type == \"rnorm\"){\n        env.info = list(2,as.num(param1),as.num(param2))\n        }\n        \n    #Catch-all to handle numeric codes\n    if (env.type != \"cover\" & env.type != \"rnorm\"){\n        env.info = list(as.num(env.type),as.num(param1),as.num(param2))\n        }\n\n    return(env.info)\n    }\n\n#DD# Think about how to best document the below suite of functions\n#' Update my.env settings\n#'\n#' Function to change my.env due to environmental change\n#'\n#' @param my.env Information about the environmental layers\n#' @param ev an index for which environmental layer to change\n#' \nchange.cover.my.env = function(my.env,ev){\n    #Get previous cover levels\n    old.cover.levels = as.character(my.env[ev,\"cover.levels\"])\n      old.cover.levels = as.num(strsplit(old.cover.levels,\";\")[[1]])\n    #Get magnitude of change\n    c.mag = as.character(my.env[ev, \"env.change.mag\"])\n      c.mag = as.num(strsplit(c.mag,\";\")[[1]])\n    #Get new cover levels\n    new.cover.levels = old.cover.levels + c.mag\n    \n    #check that new cover levels == 1\n    if (sum(new.cover.levels) != 1){\n        new.cover.levels = old.cover.levels\n        warning(\"Change in cover levels resulted in impossible values, no change was made\")\n        }\n    \n    #Update my.env\n    my.env[ev,\"cover.levels\"] = listtotext(new.cover.levels,\";\")\n    \n    return(my.env)\n    }\n\n#DD# See note on change.cover.my.env\n#' Markov change\n#'\n#' Function to do environmental change via a markov chain (transition probabilities)\n#'\n#' @param l.lyr The current landscape layer values\n#' @param my.env Information about the environmental layers\n#' @param ev An indicator for which environmenal layer to use\n#' @param p The number of cells in the landscape\n#' @param cond.lyr Another layer to use for conditional setup\n#' @param cond.vals Values in the other layer to use as suitable\nmarkov.change = function(l.lyr,my.env,ev,p,cond.lyr = NA,cond.vals = NA){\n    #test vals\n    # l.lyr = c(0,1,0,0,1,0,1,0,1)\n    # c.mag = \"0:1;0.681:1:0.275:1\"\n    # cond.lyr = c(1,1,2,1,2,1,1,2,1)\n    # cond.vals = list(1)\n\n    new.l.lyr = l.lyr #Create a new layer to store the results\n    \n    c.mag = as.character(my.env[ev, \"env.change.mag\"])\n      c.mag = strsplit(c.mag,\";\")[[1]]\n    l.values = c.mag[1]\n      l.values = as.num(strsplit(l.values,\":\")[[1]])\n    t.probs = c.mag[2]\n      t.probs = as.num(strsplit(t.probs,\":\")[[1]])\n      t.probs = matrix(t.probs,nrow = length(l.values),byrow = T) #Makes a matrix, where each row corresponds to transition probabilities for a value\n      \n    #Go through values in the landscape, and do transitions\n    for (cell in 1:p){\n        cell.val = l.lyr[cell]\n\n        #Indicator variable for whether or not to update this cell\n        do.trans = 1        \n        #If conditioning on another layer, check that the other layer is of a suitable type\n\n        if (!is.na(cond.lyr[1])){\n            do.trans = 0\n            cond.lyr.cell.val = cond.lyr[cell]\n            #Go through the list of acceptable values\n            for (test.val in cond.vals){\n                #If the conditioning layer's cell value is in the list of acceptable values, do the transition\n                if (cond.lyr.cell.val == test.val){\n                    do.trans = 1\n                    }\n                }\n            }\n        \n        #If the cell is not of a suitable type, set it's value to 0 (regardless of what it was before - if the conditioning layer has changed, this prevents unsuitable values present here\n        if (do.trans == 0){\n            new.l.lyr[cell] = 0\n        }else{\n        \n            l.v.count = 0\n            #Go through values indexing transition rates\n            for (l.v in l.values){\n                l.v.count = l.v.count + 1\n                #If the cell value matches the transition value index, do the transition\n                if (cell.val == l.v){\n                    #Draw a random number from a uniform distribution\n                    rand.val = runif(1,0,1)\n                    t.probs.for.val = t.probs[l.v.count, ]\n                    lower = 0\n                    upper = 0\n                    count = 0\n                    #min/max is to use the values from the values list as indices\n                      #Note that gaps between values are not allowed! e.g. 0,1,2 is okay, but 0,2 is not\n                    for (j in min(l.values):max(l.values)){\n                        count = count + 1\n                        upper = t.probs.for.val[count]\n                        if (rand.val < upper & rand.val >= lower){\n                            new.l.lyr[cell] = j #j corresponds to the value for the given transition probability\n                            break #No sense evaluating the rest of the loop once an appropriate match is found\n                            }\n                        lower = upper # Reset the lower value to be one increment higher\n                        }\n                    break #If a match was found above, no need to continue the for loop.\n                    }\n                }\n            }\n        }\n\n    return(new.l.lyr)\n    }\n\n#' Validity Check\n#' \n#' Check that probabilities of environmental change are actually probabilities\n#' (and if not, adjust them)\n#' @param x An input probability to be checked\n#'\nvalidity.check = function(x){\n    if (x > 1){\n        x = 1\n        warning(\"A probability exceeded 1, and was set to 1 instead\")\n        }\n    if (x < 0){\n        x = 0\n        warning(\"A probability went below 0, and was set to 0 instead\")\n        }\n    return(x)\n    }\n\n#DD# See note on change.cover.my.env\n#' Change Transition Rates\n#'\n#' Function to change the transition rates used for landscape change \n#'\n#' @param my.env Information about the environmental layers\n#' @param ev An indicator for which environmenal layer to use\nchange.transition.rates = function(my.env,ev){\n\n    #unpack c.mag\n    c.mag = as.character(my.env[ev, \"env.change.mag\"])\n        c.mag = strsplit(c.mag,\";\")[[1]]\n    t.probs = c.mag[2]\n      t.probs = as.num(strsplit(t.probs,\":\")[[1]])\n    t.probs.change = c.mag[3]\n      t.probs.change = as.num(strsplit(t.probs.change,\":\")[[1]])            \n    #Update transition probabilities\n    t.probs = t.probs + t.probs.change\n\n    #If any probs < 0, or > 1, reset to 0 & 1 and issue a warning\n    t.probs = sapply(t.probs,validity.check)\n\n    #Update c.mag[2]\n    c.mag[2] = listtotext(t.probs,\":\")\n\n    #Update my.env to include the changed transition probabilities\n    my.env[ev, \"env.change.mag\"] = listtotext(c.mag,\";\")\n\n    return(my.env)\n    }\n\n#DD# Think about routing change.transition.rates & other sub-functions to this documentation\n#' Implement environmental change\n#'\n#' Make environmental changes to a landscape layer according to a set of change\n#' instructions.  The instructions are in the my.env input, which contains the\n#' following elements \"env.change.type\", \"env.change.mag\", and \"cond.lyr\".\n#' \"env.change.type\" contains the type of change to take place, \"env.change.mag\"\n#' contains details on the magnitude of those changes, and \"cond.lyr\" contains\n#' information on what other layers might affect the change.  The change types\n#' depend on whether or not another layer is being used to inform the change\n#' process (if so, it is a conditional landscape element). See\n#' \\link[spatialdemography]{env.change.type} for more details.\n#'\n#' @param my.env A dataframe containing instructions for how the environment is\n#' to change. See \\link[spatialdemography]{env.file} for details.\n#' @param ev An indicator variable indicating which landscape element is being\n#' modified\n#' @param landscape A list of environmental layers\n#' @param landscape.identifiers A list of identifiers for the environmental\n#' layers\n#' @param p The number of cells in the landscape\n#' @param run.path The path for this model run (only applicable if c.type == \"from.file\")\n#' @param env.lbl A vector containing each environmental layer name in order (only applicable if c.type == \"from.file\")\n#' @param s.lbl A label for the scenario being considered(only applicable if c.type == \"from.file\")\n#' @param landscape.dir The directory containing the landscape layers for when changes are read in from file\n#' @param lnd.lbl A scenario specific label identifying the landscape layers to be used.\n#' @param change.count An indicator for which environmental change is being used.\n#' Note that this will refer to the change PREVIOUS to the current change, as it\n#' is updated at the END of the change process. (only applicable if c.type == \"from.file\")\n#'\ndo.env.change = function(my.env,ev,landscape,landscape.identifiers,p,run.path = NA,env.lbl = NA,s.lbl = NA,landscape.dir = NA,lnd.lbl = NA, change.count = NA){\n\n    #Set up for implementing the change\n    l.lyr = landscape[[ev]]\n    c.type = as.character(my.env[ev, \"env.change.type\"])\n    cond.lyr = as.character(my.env[ev, \"cond.lyr\"]) #Determines whether landcover depends on another landcover\n\n    my.env$env.change.mag = as.character(my.env$env.change.mag) #Convert from factor to character to avoid problems.  May want to do this earlier in the code?\n    \n    #If there is no layer to condition on, do normal change\n    if (is.na(cond.lyr)){\n    \n        #This will rearrange the elements in the landscape, but not change their values.\n        # Seems desirable under some circumstances - can have environmental change, but maintain landscape properties.\n        if (c.type == \"swap\"){\n            new.l.lyr = sample(l.lyr,length(l.lyr)) \n            }\n\n        #Stochastic change modeled with a markov chain\n          #Transition probabilities govern environmental change\n        if (c.type == \"markov\"){\n            #c.mag needs to have transition probabilities for each layer\n              #layer values are given first, followed by transitions for first layer value (to first, to second, etc), then transitions for the second layer value (to first, to second, etc)\n                #Transitions should be cumulative probabilities\n              #e.g., 0:1;0.681:1:0.275:1\n            new.l.lyr = markov.change(l.lyr,my.env,ev,p)\n            }\n                \n        #Systematic change with stochastic variation modeled with a markov chain\n          #Here, the transition probabilities also change with time\n        if (c.type == \"markov.changing.transitions\"){\n            #here c.mag needs to have 3 main elements\n              #values potentially found in the landscape (need to be consecutive\n              #transition probabilities for these values to all other values\n              #how the transition probabilities change with time\n                #e.g., 0:1;0.681:1:0.275:1;-0.05:0:-0.025:0\n                #this would lead to a decrease of 0.05 in the transition probability of going from 0 to 0 (which will lead to a corresponding increase in going from 0 to 1, since there are only two\n                #And there would be an decrease in going from 1 to 0, with a corresponding increase in going from 1 to 1.\n                  #This would correspond to landuse intensification, with mowing becoming more frequent with time.\n            #Change my.env to reflect new changed environmental transition rates\n            my.env = change.transition.rates(my.env,ev)\n            \n            #implement markov chain process\n            new.l.lyr = markov.change(l.lyr,my.env,ev,p)\n            }\n          \n        #This changes the cover proportions, then re-assigns cover values to the landscape randomly\n        if (c.type == \"cover.change.and.swap\"){\n        \n            #Update my.env\n            my.env = change.cover.my.env(my.env,ev)\n            \n            #Update layer\n            env.info = setup.env.info(\"cover\",my.env,ev)\n            base.lyr = get.base.env.lyr(env.info,p)\n            new.l.lyr  = get.env.lyr(base.lyr) #This was separated into two steps to allow for multiple configurations of the same underlying values.  I've broken that functionality in the code rewrite at the moment.\n            }\n\n        #This is basically the same approach as a markov chain, but with a continuous state variable\n        if (c.type == \"rnorm.prob\"){\n            c.mag = as.character(my.env[ev, \"env.change.mag\"])\n            c.mag = as.num(strsplit(c.mag,\";\")[[1]])\n        \n            new.l.lyr = l.lyr #Set the output layer to be equal to the input layer. It will then be updated.\n        \n            p.change = c.mag[1]\n            delta.mean = c.mag[2]\n            change.sd = c.mag[3]\n            #c.mag format:\n              #probability a cell will change\n              #change in mean for a cell that changes\n              #standard deviation around the mean for a cell that changes\n              #e.g., 0.8;0.25;1\n\n            test.probs = runif(p,0,1)\n\n            for (a in 1:p){\n                new.val = l.lyr[a]\n                #Test if cell changes\n                if (test.probs[a] <= p.change){\n                    \n                    new.mean = new.val + delta.mean\n                    new.val = rnorm(1,new.mean,change.sd)\n                    }\n                new.l.lyr[a] = new.val #Stays the same if new.val is not reassigned, otherwise it changes to the new value (which can be the same as the old value)\n                }\n            }\n  \n        #Based on the temperature data, it looks like the relative rankings of sites remained the same, while the values changed\n          #Consequently, the plan is to apply a change to the entire landscape based on c.mag\n        if (c.type == \"landscape.wide.change\"){\n            c.mag = as.character(my.env[ev, \"env.change.mag\"])\n              c.mag = as.num(strsplit(c.mag,\";\")[[1]])\n            o.mean = c.mag[[1]] #This gives the overall mean for the landscape.  It will be incremented by c.mean, each time there is change\n            o.sd = c.mag[[2]]   #This gives the overall standard deviation for the variable draw\n            c.mean = c.mag[[3]] #This gives the change in overall mean\n            c.sd = c.mag[[4]]   #This gives the change in overall standard deviation\n\n            #change o.mean and o.sd based on long-term change trends\n            o.mean = o.mean + c.mean\n            o.sd = o.sd + c.sd\n            \n            #Make sure sd does not go below 0!\n            if (o.sd < 0){\n                o.sd = 0\n                warning(\"overall standard deviation was reduced below zero.  Set to zero instead\")\n                }\n            \n            #update my.env to reflect changed means\n            c.mag = c(o.mean,o.sd,c.mean,c.sd)\n            c.mag = listtotext(c.mag,\";\")\n            my.env[ev, \"env.change.mag\"] = c.mag\n        \n            #The change is based on a mean of 0, because the mean is already added to the landscape, and this just gives the random change component\n            change = rnorm(1,0,o.sd)\n            \n            #Get deviations from landscape mean for each cell\n            old.l.mean = mean(l.lyr)\n            l.resid = l.lyr - old.l.mean #Get residuals for cells, so that higher cells remain higher and lower cells remain lower\n            #New layer is the landscape mean, plus the site's local idiosyncracities, plus the random draw based on the change\n            new.l.lyr = round((rep(o.mean,p) + l.resid + change),2)\n            }\n        \n        #Draw a random value from a log-normal distribution\n        #NOTE: This could be replaced with the numeric codes and \"fx\" type\n        if (c.type == \"logn\"){\n            c.mag = as.character(my.env[ev, \"env.change.mag\"])\n              c.mag = as.num(strsplit(c.mag,\";\")[[1]])\n            ln.mean = c.mag[[1]] #This gives the mean\n            ln.var = c.mag[[2]]   #This gives the sd\n        \n            new.l.lyr = rlnorm(p,ln.mean,ln.var)\n            }\n        \n        #Draw a random value from a beta value with mean and variance specified in c.mag\n        if (c.type == \"beta\"){\n            c.mag = as.character(my.env[ev, \"env.change.mag\"])\n              c.mag = as.num(strsplit(c.mag,\";\")[[1]])\n            b.mean = c.mag[[1]] #This gives themean for the beta distribution (NOT alpha)\n            b.var = c.mag[[2]]   #This gives the variance for the beta distribution.  This is not the same as a standard deviation or sd^2\n            \n            new.l.lyr = calc.beta(p,b.mean,b.var) #calc.beta is a custom function from Jakob\n            }\n\n        #Use one of the functions from compute.funct\n        if (c.type == \"fx\"){\n            c.mag = as.character(my.env[ev, \"env.change.mag\"])\n              c.mag = as.num(strsplit(c.mag,\";\")[[1]])\n            #funct = c.mag[[1]]\n            #par1 = c.mag[[2]]\n            #par2 = c.mag[[3]]\n            \n            new.l.lyr = get.base.env.lyr(c.mag,p)\n            }\n       \n        #Read landscape in from file\n        if (c.type == \"from.file\"){\n            lbl = env.lbl[ev]\n            c.count = change.count + 1 #change.count + 1 is to get the file from the current change, as change count has not yet been updated\n            new.l.lyr = read.landscape.lyr(landscape.dir,lbl,lnd.lbl,c.count,p)\n            }\n\n    #Otherwise, include the conditional layer in implementing change\n    }else{\n        #Re-setup env.info\n        env.type = as.character(my.env[ev,\"env.type\"])\n        env.info = setup.env.info(env.type,my.env,ev)\n\n        cond.vals = as.character(my.env[ev, \"cond.vals\"]) #Determines which values of the landcover depend on the other landcover\n          cond.vals = list(as.num(strsplit(cond.vals,\";\",fixed = T)[[1]])) #what an awful piece of code.  Outside nesting is it needs to be a list at the end.  Next level is as.num, which requires a non-list input.  Hence the [[1]] after strsplit, because strsplit creates a list!  Splits on \";\"        \n        cond.lyr = cv.setup(cond.lyr,landscape,landscape.identifiers) #This reassigns cond.lyr!\n\n        if (env.type == \"rnorm\"){\n            stop(\"This option has not yet been scripted\")\n            }           \n            \n        #This will rearrange the elements in the landscape, but only for cells where they can be appropriately assigned\n          #And different code would be needed or random generation - there re-creating values will not work.\n        if (c.type == \"swap\" & env.type == \"cover\"){\n            #Just re-assign the layer - it will have the same values, because there was no random component.\n            #This assumes the conditioning layer has not changed\n            new.l.lyr = get.cond.env.lyr(env.info,p,cond.lyr,cond.vals)\n            }\n        \n        #This will change each element according to a set of transition probabilities, but only for elements in a valid type of another layer\n        if (c.type == \"markov\"){\n            #NOTE: cond.lyr is a list to allow for the future possibility of conditioning on multiple layers            \n            new.l.lyr = markov.change(l.lyr,my.env,ev,p,cond.lyr[[1]],cond.vals)\n            \n            }\n\n        #Same as above, except the transition probabilities can change over time as well.\n        if (c.type == \"markov.changing.transitions\"){\n            #here c.mag needs to have 3 main elements\n              #values potentially found in the landscape (need to be consecutive\n              #transition probabilities for these values to all other values\n              #how the transition probabilities change with time\n                #e.g., 0:1;0.681:1:0.275:1;-0.05:0:-0.025:0\n                #this would lead to a decrease of 0.05 in the transition probability of going from 0 to 0 (which will lead to a corresponding increase in going from 0 to 1, since there are only two\n                #And there would be an decrease in going from 1 to 0, with a corresponding increase in going from 1 to 1.\n                  #This would correspond to landuse intensification, with mowing becoming more frequent with time.\n            #Change my.env to reflect new changed environmental transition rates\n            my.env = change.transition.rates(my.env,ev)\n            \n            #implement markov chain process\n            # NOTE: cond.lyr is a list to allow the future possibility of conditioning on more than one layer\n            new.l.lyr = markov.change(l.lyr,my.env,ev,p,cond.lyr[[1]],cond.vals)\n            }\n            \n        if (c.type == \"from.file\"){\n            lbl = env.lbl[ev]\n            c.count = change.count + 1 #change.count + 1 is to get the file from the current change, as change count has not yet been updated\n            new.l.lyr = read.landscape.lyr(landscape.dir,lbl,lnd.lbl,c.count,p)\n            }\n        \n        }\n   \n    return(list(new.l.lyr,my.env))\n    }\n\n#DD# add in ' again when reenabling the code\n# # Write environmental layer to file (old version)\n# #\n# # Write an environmental layer to file (for visual debugging purposes)\n# #\n#write.env.lyr.old = function(in.lyr,extent,outfile){\n#    in.lyr = matrix(in.lyr, nrow = extent, byrow = T)\n#    write.table(in.lyr, file = outfile,sep = \",\",row.names = F,col.names = F)\n#    }\n\n#' Write environmental layer to file\n#'\n#' Write an environmental layer to file (for visual debugging purposes)\n#' Input is a landscape as a vector.  The landscape can be visualized by putting it into a matrix format (nrow = extent) and using the byrows = T option\n#'\n#' @param in.lyr The input layer values\n#' @param change.count An indicator for the current environmental change step.\n#' @param extent One sided length of the landscape\n#' @param outfile File to be created\n#' @param create.new (default to 0) An indicator for whether to write header info & start a new file\n#'\nwrite.env.lyr = function(in.lyr,change.count,extent,outfile, create.new = 0){\n    if (length(in.lyr) != extent ^ 2){\n        stop(\"Length of landscape layer is not equal to the extent squared.\")\n        }\n\n    if (create.new == 1){\n        #Add header to landscape file\n        n.cells = seq(1,extent^2)\n        cell.lbls = sprintf(\"Cell%s\",n.cells)\n        cell.lbls = listtotext(cell.lbls, \",\")\n        hdr = sprintf(\"ChangeStep,%s\\n\",cell.lbls)\n        cat(hdr, file = outfile) #Creates a new file because append != T\n        }\n\n    in.lyr = listtotext(in.lyr,\",\")\n    in.lyr = sprintf(\"%s,%s\\n\",change.count,in.lyr) #Add a step label and a hard return\n    cat(in.lyr, file = outfile, append = T) #Write to file\n    }\n\n#' Write header for species data\n#'\n#' Like the title says.\n#' @param outfile The file to be written to\n#' @param p The number of cells in a square landscape\n#'\nwrite.sp.hdr.data = function(outfile, p){\n    \n    n.cells = seq(1,p)\n    cell.lbls = sprintf(\"Cell%s\",n.cells)\n    cell.lbls = listtotext(cell.lbls, \",\")\n    hdr = sprintf(\"LifeStage,Species,TimeStep,%s\\n\",cell.lbls)\n    cat(hdr, file = outfile) #Creates a new file because append != T\n    }\n\n#' Write species locations to file\n#' \n#' Write the locations of a species to a file\n#' Input is species abundances as a vector.  The species abundances on the landscape can be visualized by putting it into a matrix format (nrow = extent) and using the byrows = T option\n#'\n#' @param LifeStage The life stage of interest\n#' @param sp the current species\n#' @param RunTime The current timestep\n#' @param in.sp.dat in.sp.dat\n#' @param extent The one-sided length of the landscape\n#' @param outfile the file to be written to\n#'\nwrite.sp.data = function(LifeStage,sp,RunTime,in.sp.dat,extent,outfile){\n\n    if (length(in.sp.dat) != extent ^ 2){\n        stop(\"Length of species vector is not equal to the extent squared.\")\n        }\n\n    in.sp.dat = listtotext(in.sp.dat,\",\")\n    in.sp.dat = sprintf(\"%s,%s,%s,%s\\n\",LifeStage,sp,RunTime,in.sp.dat) #Add a step label and a hard return\n    cat(in.sp.dat, file = outfile, append = T) #Write to file\n    }\n\n#DD# add in ' again when reenabling the code\n# # Write species locations to file (old)\n# # \n# # Write the locations of a species to a file\n# #\n#write.sp.mat.data.old = function(in.matrix, in.path,in.lbl,sp,RunTime){\n#    out.file = sprintf(\"%s%s_%s_%s.csv\",in.path,in.lbl,sp,RunTime)\n#    write.table(in.matrix, file = out.file, sep = \",\", row.names = F, col.names = F)\n#    }\n#\n\n#' Calculate log lambda and dispersion of log lambda\n#'\n#' Like the title says. %%DD%%\n#'\n#' @param in.file an input file\n#' @param lbl a label\n#'\nget.log.lambda = function(in.file, lbl){\n    \n    #Calculate log lambda for overall\n    my.dat = read.csv(in.file)\n    \n    #Sort data (in case someone sorted it into a different order -just to be safe\n    my.dat = my.dat[order(my.dat$RunTime), ]\n\n    sp.names = names(my.dat)[2:ncol(my.dat)]  #column 1 is RunTime, all others should correspond to a species\n\n    #Create a header & column in my.dat for each species\n    sp.hdrs = sprintf(\"log.lambda.%s\",sp.names)\n    for (hdr in sp.hdrs){\n        my.dat[[hdr]] = NA\n        }\n\n    #Start with 2nd row (first row doesn't have anything to compare to)\n    for (a.row in 2:nrow(my.dat)){\n        p.row = a.row - 1\n        this.time = as.num(my.dat[a.row, \"RunTime\"])\n        last.time = as.num(my.dat[p.row, \"RunTime\"])\n        \n        #only calculate log-lambda if there is a 1 unit change between time steps (again, don't know how it wouldn't be, but want to be safe)\n        if ((this.time - last.time) == 1){\n        \n            #loop through species and do calculations\n            for (sp in 1:length(sp.names)){\n                sp.lbl = sp.names[sp]\n                sp.hdr = sp.hdrs[sp]\n                \n                this.val = as.num(my.dat[a.row, sp.lbl])\n                last.val = as.num(my.dat[p.row, sp.lbl])\n                \n                lambda = this.val / last.val\n                log.lambda = log(lambda) #This does log base e.  I'm assuming this is what Jakob used?  Does it matter?\n                \n                my.dat[[sp.hdr]][this.time] = log.lambda\n                }\n            }\n        }\n\n    #Update in.file to have log.lambdas\n    new.file = substr(in.file,1,(nchar(in.file) - 4)) #Remove .csv\n    new.file = sprintf(\"%s_v2.csv\",new.file)          #add _v2.csv\n    \n    write.table(my.dat, file = new.file, sep = \",\", row.names = F)\n    unlink(in.file) #Delete the original file as it has been replaced (not just overwriting it, in case the code gets run more than once in a weird way)\n\n    \n    #Calculate geometric mean of log.lambda & dispersion\n    mean.lambda.vec = c()\n    sd.lambda.vec = c()\n    for (sp.hdr in sp.hdrs){\n        #overall.lambda = (prod(my.dat$log.lambda)) ^ (1/length(my.dat$log.lambda)) # NOTE: in log space, you want the arithmetic mean.  if you were in normal space, you would use a geometric mean\n        overall.lambda = mean(my.dat[[sp.hdr]], na.rm = T)\n        sd.lambda = sd(my.dat[[sp.hdr]], na.rm = T) #What formula did Jakob use?  Should it still be a geometric mean when measured on a log scale? (yes)    \n\n        mean.lambda.vec = c(mean.lambda.vec, overall.lambda)\n        sd.lambda.vec = c(sd.lambda.vec, sd.lambda)\n        }\n    \n    return(list(sp.names,lbl,mean.lambda.vec,sd.lambda.vec))    \n    }\n\n#' Write log lambdas to file\n#'\n#' Take several calculations of log lambda, and place them into a single file\n#' with species as rows, and values as columns.\n#'\n#' @param in.lists One or more lists to be written to file.  Each list should \n#' have four components: A vector with species headers, a label for the list, a vector with mean log\n#' lambdas, and a vector with sd of log lambda.\n#' @param out.file The file to be written\n#'\n#' @note Should change from vec1 and vec2 to take a list of lists as a more robust approach\ncompile.log.lambdas = function(in.lists,out.file){\n\n    for (i in 1:length(in.lists)){\n        \n        my.lst = in.lists[[i]]\n        \n        #Create a data frame on the first time through the code\n        if (i == 1){\n            my.dat = data.frame(Species = my.lst[[1]])\n            list.len = length(my.lst[[1]]) #get a length to use as a check against all other lists - they should be the same length (hmm, how will this work with the cell lists?)\n            }\n        \n        if (length(my.lst[[1]]) != list.len){\n            stop(\"The lists you are trying to compile are not of the same length.\")\n            }\n        \n        mean.lbl = sprintf(\"mean.%s\",my.lst[[2]])\n        sd.lbl = sprintf(\"sd.%s\",my.lst[[2]])\n        \n        my.dat[[mean.lbl]] = my.lst[[3]]\n        my.dat[[sd.lbl]] = my.lst[[4]]\n        }\n    write.table(my.dat, file = out.file, row.names = F, sep = \",\")\n    }\n\n#' Make final graphs\n#'\n#' THIS FUNCTION IS IN PROGRESS\n#'\n#' @param in.pdf The file to be generated\n#' @param ResultsFile The file that results will be written to.\n#' @param cover.levels The percent cover of each layer type\n#' @param s.lbl a label\n#'\nmake.final.graphs = function(in.pdf,ResultsFile,cover.levels,s.lbl){\n    \n    stop(\"This function has not been  updated and should not be used\")\n    \n    if (!require(Hmisc)){ stop(\"Please install Hmisc: install.packages('Hmisc')\") }\n    \n    # For testing purposes\n    #setwd(\"C:/docs/beplants/Scripts/\")\n    #ResultsFile = \"outputs/Results_RTD_for_graph.csv\"\n    #in.pdf = \"outputs/Plots_RTD_testing1.pdf\"\n    #cover.levels = c(100/p,50,100)\n    #s.lbl = c(\"TD\",\"L1L2\",\"L1L4\",\"L2L2\",\"L2L4\",\"L4L4\")\n    \n    trt = length(s.lbl) #number of different treatments/scenarios\n    \n    #Read in results written to file\n    all.data = read.csv(ResultsFile)\n\n    #These will not be aggregated properly and might as well be dropped:\n    all.data$Scenario = NULL\n    all.data$microsites = NULL #I don't care about this for now, and the NA's give me warnings\n\n    #Get limits for dependent variables for plotting purposes\n    mins = apply(all.data,2,min,na.rm = T)  # NOTE:  All fields need to be numeric, or R converts all of these to text, and botches the min/max calculations\n    maxes = apply(all.data,2,max, na.rm = T) #NOTE:  All fields need to be numeric, or R converts all of these to text, and botches the min/max calculations\n\n\n    #Subset all.data to get sample sizes by group of interest.  This really should be done by the aggregate function, but apparently it is defective!\n    n.mat = matrix(rep(NA,(trt * length(cover.levels))),nrow = trt) #hold results for sample sizes\n    for (r in 1:trt){\n        n.subset = all.data[all.data$Scenario.Number == r, ]\n        for (ec in 0:1){ #NOTE: Currently only set up for 2 levels of environmental change!\n            n.subset2 = n.subset[n.subset$Env.Change == ec, ]    \n            for (cc in 1:length(cover.levels)){\n                lvl = cover.levels[cc]\n                n.subset3 = n.subset2[n.subset2$Percent.Cover == lvl, ]\n                this.n = nrow(n.subset3)\n                n.mat[r,cc] = this.n\n                }\n            }\n        }\n            \n    # Note: all scenarios should be run for an equal number of times, so the n should be the same for all.\n    print(\"this matrix should have all the same number.  If not, the sample sizes are uneven, and the confidence intervals will be wrong!\")\n    print(n.mat) #Visually check assumption that all n are equal\n    n.actual = n.mat[1,1] \n           \n    #Aggregate data into data points by scenario and Percent Cover\n    scn.num = all.data$Scenario.Number\n    all.data$Scenario.Number = NULL #Remove from data frame after making a separate column for aggregation\n    frag = all.data$Percent.Cover\n    all.data$Percent.Cover = NULL #Remove data from data frame after making a separate column\n    enviro.change = all.data$Env.Change \n    all.data$Env.Change = NULL\n        \n    #Actually aggregate the data\n    mean.data = aggregate(all.data,list(scn.num,frag,enviro.change),mean)\n    sd.data = aggregate(all.data,list(scn.num,frag,enviro.change),sd)\n    #ci.data = (sd.data * 1.96)/sqrt(n.actual) #95% CI as (sd * 1.96) / sqrt(n).  I thought there was a sqrt(n-1) for something, but it is not given in Zar (or Wikipedia)\n    \n    #Create a pdf file to hold the graphical outputs\n    pdf(file = in.pdf)\n    \n    #Make a separate plot for each of the dependent variables of interest\n    iv.vec = c(\"landscape.Sp.Rich.Final\",\"landscape.Beta.Div.Final\",\"landscape.Biomass.Final\",\"landscape.FTD.UTC.Final\",\"landscape.RTD.UTC.Final\",\"landscape.RTD.UTC.Change\") #Change plotted for RTD, because initial conditions are not equal\n    for (iv in iv.vec){\n        \n        #Loop through environmental change\n        for (ec in 0:1){\n            #Subset data to be homogeneous for environmental change type\n            ec.mean.data = mean.data[mean.data$Group.3 == ec, ]\n            ec.sd.data = sd.data[sd.data$Group.3 == ec, ]\n            \n            #Make separate plots for each variable\n            first = 1\n            \n            #Loop through scenarios, and put in the same plot with a legend\n            for (r in 1:trt){\n                \n                #Subset data to only relevant data\n                mean.subset = ec.mean.data[ec.mean.data$Group.1 == r, ]\n                sd.subset = ec.sd.data[ec.sd.data$Group.1 == r, ]\n                xx = mean.subset$Group.2\n                yy = mean.subset[[iv]]\n                ci = (sd.subset[[iv]] * 1.96) /sqrt(n.actual)\n                \n                #Add in a slight off-set so points are not right on top of one another\n                xx = xx + (r - 3.5) #r - 3.5 is so that the points are centered around the actual value\n                \n                ymin = mins[[iv]]\n                ymax = maxes[[iv]]\n                \n                #Special legend plotting\n                legend.loc = \"bottomright\" #set this as default, will work for most plots\n                if (iv == \"landscape.Beta.Div.Final\"){\n                    legend.loc = \"topright\"\n                    }\n                \n                if (first == 1){\n                    my.xlab = sprintf(\"Habitat Cover (%s), Environmental Change = %s\",\"%\",ec) #NOTE: The % alone crashes the function, because it thinks you forgot a letter - hence why it is put in via substitution.\n                    plot(yy ~ xx,xlim = c(0,105),xlab = my.xlab,ylim = c(ymin,ymax),ylab = sprintf(\"%s\",iv), col = r) #Figure out how to fill backgrounds, think about drawing lines\n                    legend(x = legend.loc,legend = s.lbl, col = seq(1,trt,1),pch = 16)\n                } else {\n                    points(yy ~ xx, col = r)\n                    }\n                Hmisc::errbar(xx,yy, yy + ci, yy - ci, add = T, pch = 16, cap = .01,col = r, errbar.col = r) #errbar is from Hmisc\n                    \n                first = 0 #Control what happens on the first run through the loop - here it gets turned off until the next iv variable\n                }\n            }\n        }\n    #Stop writing to the pdf.\n    dev.off()\n    }\n\n#' Prep diagnostic output\n#'\n#' Reformats the matrix into a vector, and adds desired prefix information\n#'\n#' @param in.spar.mat in.spar.mat\n#' @param change.count An indicator for the current environmental change step.\n#' @param sp The species of interest (numeric)\n#' @param cell A cell label\nprep.output = function(in.spar.mat,change.count,sp,cell = \"\"){\n    #Convert from sparsematrix, so that I can write it to file\n    out.dat = as.matrix(in.spar.mat) # Note: after doing this step, the image command will no longer work using nicer method applied to sparsematrices\n    \n    #**# THIS IS LIKELY A SLOW STEP & SHOULD PROBABLY BE FIXED.\n    out.dat = matrix.as.vector(out.dat)\n\n\n    #Include cell, if cell is included as an input, otherwise exclude it.\n    cell.out = cell\n    if (cell != \"\"){\n        out.dat = c(change.count,sp,cell.out,out.dat)\n    }else{\n        out.dat = c(change.count,sp,out.dat)\n        }\n\n    out.dat = matrix(out.dat, nrow = 1) #Matrix format is required to get write.table to write it as a row!\n\n    #    cell.out = sprintf(\"%s,\", cell) #Add a comma to cell, if it is not blank\n    #    }\n    #    \n    #out.dat = listtotext(out.dat,\",\")\n    #out.dat = sprintf(\"%s,%s,%s%s\\n\",change.count,sp,cell.out,out.dat)\n    return(out.dat)\n    }\n\n#' matrix.as.vector\n#'\n#' Converts a matrix to a vector, but does so by rows (I don't know of a pre-existing option for this)\n#'\n#' @param in.mat A matrix\n#'\nmatrix.as.vector = function(in.mat){\n\n    #Transpose matrix, then convert to one column.\n    mat.out = t(in.mat)\n    mat.out = matrix(mat.out, nrow = 1)\n    \n    return(mat.out)\n    }\n\n#DD# This would be a good place for more documentation as well\n#' Compute Diagnostics\n#'\n#' Function to compute basic matrix diagnostics\n#'\n#' @param spe The number of species in the species pool\n#' @param B1.lst A list of the first demography matrices for each species\n#' @param B2.lst A list of the second demography matrices for each species\n#' @param M.lst A list of the dispersal matrices for each species\n#' @param P The vec-permutation matrix\n#' @param p The number of cells in a square landscape\n#' @param S The number of stages in the matrix model\n#' @param outpath.base The base path for outputs\n#' @param vdb.data An indicator for whether or not to create visual debugger data\n#' @param change.count An indicator for the current environmental change step.\n#' @param run.times A list of intermediate times during the model run\n#' @param run.lbl A list of labels for each of the intermediate times\n#' @param is.first An indicator for whether this is the first time the code is run (for timing purposes)\n#' @param Gave.Warn An indicator for whether a warning message has already been given. If so, a duplicate warning will NOT be reissued.\n#' @note The diagnostics DO NOT include effects of the carrying capacity or\n#' microsite competition!\n#' WARNING This function requires exactly 4 stages, with the first stage as\n#' the mobile dispersal stage. is stage specific, and requires 4 stages with the first stage as mobile seeds!\n#'\ncompute.diagnostics = function(spe,B1.lst,B2.lst,M.lst,P,S,p,outpath.base,vdb.data,change.count,run.times,run.lbl, is.first = 0, Gave.Warn = 0){\n\n    #setup path for diagnostics files\n    diagnostics.path = sprintf(\"%sDiagnostics/\",outpath.base)\n    dir.create(diagnostics.path, showWarnings = F)\n\n    #Set up output files    \n    Matrix.Diagnostics = sprintf(\"%sMatrixDiagnostics.csv\", diagnostics.path)\n    \n    if (vdb.data == 1){\n        A.Matrices = sprintf(\"%sAMatrices.csv\", diagnostics.path)\n        A.Matrices.Summary = sprintf(\"%sAMatricesSummaries.csv\", diagnostics.path)        \n        Transition.Matrices = sprintf(\"%sTransitionMatrices.csv\", diagnostics.path)\n    \n        if (is.first == 1){\n\n            #Set up header for overall transition matrices\n            #Uninformative labels, because I don't know how to properly label each transition rate, and that is not my highest priority.\n            n.entries = (S - 1)^2 * p^2\n            entries = seq(1,n.entries)\n            e.lbls = sprintf(\"Entry_%s\",entries)\n\n            A.mat.hdr = matrix(c(\"ChangeStep\",\"Species\",e.lbls),nrow = 1)\n            write.table(A.mat.hdr, file = A.Matrices, sep = \",\", append = F, col.names = F, row.names = F)\n            \n            #Set up header for overall transition matrices summaries\n            A.sum.hdr = matrix(c(\"ChangeStep\",\"Species\",\"Cell\",\"Dominant.EigenValue\",\"Per.Capita.Seeds.Exported\",\"Per.Capita.Seeds.Imported\",\"Prop.seeds.exported\"),nrow = 1)\n            write.table(A.sum.hdr, file = A.Matrices.Summary, sep = \",\", row.names = F, col.names = F, append = F)\n\n            #Set up header for local transition matrices\n            n.entries = (S - 1)                      #Get number of entries, excluding mobile seed stages\n            r.lbl = rep(seq(1,n.entries),n.entries)  #create an index for each row\n            c.lbl = sort(r.lbl)                      #create an index for each column\n            e.lbls = sprintf(\"p%s%s\",r.lbl,c.lbl)    #put them together using the notation I've been using elsewhere\n            \n            trans.hdr = matrix(c(\"ChangeStep\",\"Species\",\"Cell\", e.lbls), nrow = 1)\n            write.table(trans.hdr, file = Transition.Matrices, append = F, row.names = F, col.names = F, sep = \",\")\n            }\n        }\n\n    #Initialize dataframe to contain results\n    i = rep(NA, spe)  #i for initial, not i as an index.\n    diag.results.df = data.frame(ChangeStep = rep(change.count,spe),Species = seq(1,spe),A.Eigen = i, Is.Irreducible = i, Is.Ergodic = i,\n                                 Max.Local.Eigen = i, Median.Local.Eigen = i, Min.Local.Eigen = i,\n                                 Max.Seed.Export = i,Median.Seed.Export = i, Min.Seed.Export = i,\n                                 Max.Seed.Import = i, Median.Seed.Import = i, Min.Seed.Import = i,\n                                 Prop.Dispersing = i)\n\n    if (is.first == 1){\n        run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Compute Diagnostics Initialization complete\")\n        }\n\n    #Loop through each species\n    for (sp in 1:spe){\n\n        #Extract matrices for this species\n        B1 = B1.lst[[sp]]\n        B2 = B2.lst[[sp]]\n        M = M.lst[[sp]]\n        \n        #Calculate overall lambda for each species\n        A <- B2 %*% t(P) %*% M %*% P %*% B1\n\n        if (is.first == 1 & sp == 1){\n            run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"A matrix calculated for sp 1\")\n            }\n\n        #Drop mobile seeds (issue is that they are effectively dropped by the matrix algebra, but cause problems for the matrix diagnostics)        \n        #Mobile seeds correspond to the first row & column in the matrix, and +4 after that        \n        mobile.seed.index = seq(1,nrow(A),4) #Increment by 4's, row & column numbers are the same, so just using row here.\n        A2 = A[-mobile.seed.index,-mobile.seed.index] #The minus sign says to drop those [rows,columns]\n\n        if (is.first == 1 & sp == 1){\n            run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"A2 matrix calculated for sp 1\")\n            }\n\n        #Two step example with dropping rows & columns manually for a 2 x 2 landscape\n        #A2 = A[ ,c(-1,-5,-9,-13)]\n        #A2 = A2[c(-1,-5,-9,-13), ]\n\n        #Set up paths for outputting diagnostic data for the visual debugger\n        if (vdb.data == 1){\n            A2.out = prep.output(A2,change.count,sp)      #Prepare A2 for writing to file\n            write.table(A2.out, file = A.Matrices, append = T, row.names = F, col.names = F, sep = \",\")\n            }\n\n        #Overall eigen vector   #NOTE: at present, imaginary eigenvectors are ignored\n        A2.eigen<-eigen(A2) #Calculate eigenvalues for A2 (without mobile seeds). \n        dom.pos<-which.max(Re(A2.eigen$values)) #Get the position of the dominant eigenvalue. Re gets just the real component\n        A.dom.eigenv<-Re(A2.eigen$values[dom.pos]) #the dominant eigenvalue. Re gets just the real component\n        diag.results.df$A.Eigen[sp] = A.dom.eigenv\n\n        if (is.first == 1 & sp == 1){\n            run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Eigen values for A2 matrix calculated for sp 1\")\n            }\n    \n        #If sourcing stottmatrix version:\n        if (exists(\"is.irreducible\")){\n    \n            #Check reducibility\n            mat.red = is.irreducible(A2)\n            \n            #Convert to TRUE/FALSE instead of string\n            if (substr(mat.red,1,4) == \"TRUE\"){\n                mat.red = TRUE\n            }else{\n                if (substr(mat.red,1,5) == \"FALSE\"){\n                    mat.red = FALSE\n                }else{\n                    stop(\"Problem in compute.diagnostics function - unexpected output for mat.red\")\n                    }                    \n                }\n\n            if (is.first == 1 & sp == 1){\n                run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Irreducibility checked for sp 1\")\n                }\n                \n            #Check ergodicity # WARNING: this function may fail under some conditions\n              #May need to use is.primitive and blockmatrix functions for further diagnostics\n            mat.erg = is.ergodic(A2)\n            \n            mat.erg.p1 = mat.erg$ergodic\n            mat.erg.p2 = mat.erg$lefteigvec\n            if (mat.erg.p1 == 1){\n                mat.erg = TRUE\n            }else{\n                if (mat.erg.p1 == 0){\n                    mat.erg = F\n                }else{\n                    stop(\"problem in compute diagnostics function for ergodicity - unexpected output for mat.erg\")\n                    }\n                }\n            \n            if (is.first == 1 & sp == 1){\n                run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Ergodicity checked for sp 1\")\n                }\n            } # NOTE: REMOVE THIS '}' WHEN RE-ENABLING THE ELSE STATEMENT BELOW\n                        \n        #popdemo version\n        #  #**# Needs checking when popdemo is patched.\n        #}else{\n        #    if (!require(popdemo)){ stop(\"Please install popdemo: install.packages('popdemo')\") }\n        #    \n        #    #Check reducibility\n        #    mat.red = popdemo::is.matrix_irreducible(A2)\n        #    \n        #    #Check ergodicity #**# Warning, may need to specify a digits argument to round, to avoid small, approximately 0 answers\n        #    mat.erg = popdemo::is.matrix_ergodic(A2)\n        #    \n        #    }\n\n        #Update results for this species            \n        diag.results.df$Is.Irreducible[sp] = mat.red\n        diag.results.df$Is.Ergodic[sp] = mat.erg\n\n        #if reducible & non-ergodic, check which initial conditions matter\n        if (mat.red == F & mat.erg == F){\n\n            # According to Caswell 2001, a useful diagnostic is to\n            #block-permute the matrix, then compare the connections between blocks\n            #and look at the block eigenvalues. That should tell you the overall, long-term results.\n            #And the block structure will be of interest as well.\n\n            # NOTE: NOT YET SCRIPTED            \n            }\n\n            \n        #Local transition matrices\n          #This diagnostic shows which cells/cover types are performing best/worst for each species\n          #For this, need to have the eigenvalue, but also the environmental conditions leading to that eigenvalue          \n          #It excludes external dispersal\n          #Consequently a population may be viable (due to high dispersal rates) but show up as declining based on this diagnostic.\n\n          loc.mat.eigen = c()\n          exported.seeds.vec = c()\n          imported.seeds.vec = c()\n          prop.disp.vec = c()\n\n          #Patch to deal with situation where there is 0 reproduction\n          was.warn = 0\n\n          #Loop through cells\n          for (cell in 1:p){\n\n              #Extract the demographic matrices pertaining to this cell\n              #For 4 stages, 1 is dropped, so cells should be 3 x 3 along the diagonal\n              #1:3,1:3, 4:6,4:6, 7:9,7:9, 10:12,10:12\n              S2 = S - 1 # to account for the dropped stage\n              #Row and column indices are the same\n              start.index = (cell - 1) * S2 + 1 #cell - 1 makes it so that the first cell starts at 0, S2 increments by the number of stages, and + 1 ensures it starts at 1 \n              end.index = (cell - 1) * S2 + S2 #same logic as above, except the + S2 gives it the correct end point\n             \n              Local.Matrix = A2[start.index:end.index, start.index:end.index]\n\n              if (vdb.data == 1){\n                  #Write local transition matrices\n                  loc.mat.out = prep.output(Local.Matrix,change.count,sp,cell)                  \n                  write.table(loc.mat.out, file = Transition.Matrices, append = T, sep = \",\",row.names = F, col.names = F)\n                  }\n\n              #Calculate dominant eigenvalue for the local matrix (does not include imported seeds or seeds lost to dispersal)\n              Local.Matrix.eigen<-eigen(Local.Matrix) #Calculate eigenvalues for A2 (without mobile seeds)\n              dom.pos<-which.max(Re(Local.Matrix.eigen$values)) #Get the position of the dominant eigenvalue. Re just gets the real component\n              Local.Matrix.dom.eigenv<-Re(Local.Matrix.eigen$values[dom.pos]) #the dominant eigenvalue.  Re gets just the real component\n\n              loc.mat.eigen = c(loc.mat.eigen,Local.Matrix.dom.eigenv)\n\n              #Get number of seeds exported to landscape\n              export.col.index = cell * S2\n              seed.row.indices = seq(1,((p * S2) - (S2 - 1)),S2)\n              export.row.indices = seed.row.indices[-cell]\n              exported.seed.values = A2[export.row.indices, export.col.index]\n              exported.seeds = sum(exported.seed.values)\n          \n              exported.seeds.vec = c(exported.seeds.vec,exported.seeds)          \n              \n              #Get proportion of seeds dispersing (seeds dispersing / total seeds produced by cell)\n              all.seed.values = sum(A2[seed.row.indices, export.col.index]) #As above, except with all seed cells, and combined into one step\n              prop.seeds.dispersing = exported.seeds / all.seed.values\n              \n              #Check if all.seed.values is 0. If it is, there is no reproduction\n              if (all.seed.values == 0){\n                  was.warn = 1\n                  if (Gave.Warn == 0){\n                      warning(\"At least one species in one cell has 0 reproduction. Diagnostics on proportion dispersing will include NaN as this calculation would require dividing by 0.\")\n                      Gave.Warn = 1\n                      }\n                  }\n              \n              prop.disp.vec = c(prop.disp.vec,prop.seeds.dispersing)\n              \n              #Get number of seeds received from landscape\n              import.row.index = (cell - 1) * S2 + 1 #First row for first cell, 4th row for 2nd cell (for S2 = 3), etc.\n              seed.col.indices = seq(S2,ncol(A2),S2) #Start in S2 column, go through all columns in matrix, and do it by increments of S2                           \n              import.col.indices = seed.col.indices[-cell]  #seed.col.index, but without the seeds that remain within the cell.  Cell indexes the element that corresponds to the cell of interest.\n              \n              imported.seed.values = A2[import.row.index,import.col.indices]\n              imported.seeds = sum(imported.seed.values)\n              \n              imported.seeds.vec = c(imported.seeds.vec,imported.seeds)\n              \n              #Write dominant eigenvalues for local transition matrices, seeds exported, and seeds imported for each cell\n              if (vdb.data == 1){           \n                sum.info = matrix(c(change.count, sp, cell, Local.Matrix.dom.eigenv,exported.seeds,imported.seeds,prop.seeds.dispersing),nrow = 1)\n                write.table(sum.info, file = A.Matrices.Summary, append = T, sep = \",\", row.names = F, col.names = F)\n                }\n            }\n        \n        if (is.first == 1 & sp == 1){\n            run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Local transition matrices checked for sp 1\")\n            }\n                                    \n        #Summarize the results from ALL cells # NOTE: These are potentials - they will/may not be realized if cells are unoccupied\n        #Max, Median, and Min eigen value\n        diag.results.df$Max.Local.Eigen[sp] = max(loc.mat.eigen)\n        diag.results.df$Median.Local.Eigen[sp] = median(loc.mat.eigen)\n        diag.results.df$Min.Local.Eigen[sp] = min(loc.mat.eigen)\n        \n        #Max, Median, and Min exported seeds\n        diag.results.df$Max.Seed.Export[sp] = max(exported.seeds.vec)\n        diag.results.df$Median.Seed.Export[sp] = median(exported.seeds.vec)\n        diag.results.df$Min.Seed.Export[sp] = min(exported.seeds.vec) \n        \n        #Max, Median, and Min imported seeds\n        diag.results.df$Max.Seed.Import[sp] = max(imported.seeds.vec)\n        diag.results.df$Median.Seed.Import[sp] = median(imported.seeds.vec)\n        diag.results.df$Min.Seed.Import[sp] = min(imported.seeds.vec)\n        \n        # NOTE: This check was removed because the proportion dispersing was changing with an ABSORBING edge type (because some dispersers were not being counted because they fell off the edge of the world)\n            #Max, min & median for proportion dispersing\n            # NOTE: WEIRD BUG! as.character here patches very odd behavior where I had two numbers 0.086 and 0.086, and R was saying they were different, even though they looked exactly alike!\n            #check that proportion dispersing is constant (it should be - because it is per capita) #Oct 13 edit - removed NA values, because they legitimately can occur in the case where no seeds are produced.\n            #was.warn is a patch to avoid a situation that can legitimately cause this test to fail - when there is no reproduction.\n            #if (length(unique(as.character(na.omit(prop.disp.vec)))) != 1 & was.warn == 0){\n            #    stop(\"Proportion dispersing differed among cells.  Unless dispersal varies within species (currently not supported), this should not occur.\")\n            #    }\n        diag.results.df$Prop.Dispersing[sp] = median(prop.disp.vec)\n              \n        #Perturbation analysis\n          # NOTE: NOT YET SCRIPTED\n        \n        #Damping ratio?\n          # NOTE: NOT YET SCRIPTED\n\n        # Proportion of individuals in each cell based on the stable stage distribution \n          # because there are life-stage stages and spatial \"stages\"?\n          # NOTE: NOT YET SCRIPTED\n        \n        #Other diagnostics?\n          # NOTE: NOT YET SCRIPTED\n              \n        if (is.first == 1 & sp == 1){\n            run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"End of diagnostics loop for sp 1\")\n            }\n        \n        }\n\n    if (is.first == 1){\n        run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"End of diagnostics loop for all species\")\n        }\n\n    inc.col.names = F\n    do.append = T\n    if (is.first == 1){\n        inc.col.names = T\n        do.append = F\n        }\n\n    #Write results from matrix diagnostics # WARNING: Watch that header is in the same order as the dataframe - this could cause problems later if changes are made.\n    diag.results.df = as.matrix(diag.results.df) #Matrices are faster to write to file\n    write.table(file = Matrix.Diagnostics, diag.results.df, col.names = inc.col.names, row.names = F, sep = \",\", append = do.append)\n\n    if (is.first == 1){\n        run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Diagnostics written to file\")\n        }\n    return(list(run.times,run.lbl,Gave.Warn))\n    }\n\n\n#' Apply thinning law\n#'\n#' Calculate a component of transition rates based on a thinning law approach.\n#' Inputs may be vectors of values\n#'\n#' @details The thinning law here affects transition rates\n#' (biomass(t + 1) / biomass (t))** m, where m = -4/3 (reciprocal of the logarithmic self-thinning slope.\n#' The idea is that there are more individuals than can be supported by the environment\n#' and as individuals grow, they interfere with each other's ability to obtain resources.\n#' Some individuals die as a consequence of this competition (typically the smaller\n#' individuals, although size and competition is not directly modeled (hence\n#' assumption #3). \\cr\n#' Assumptions: \\tabular{ll}{\n#' (1) \\tab There are more individuals at time t than can reach time t + 1 \\cr\n#' (2) \\tab Even aged stand \\cr\n#' (3) \\tab Survival is probabilistic, and can be applied without knowledge of\n#' individual characteristics and/or identities. \\cr\n#' }\n#'\n#' @param initial.biomass Initial biomass\n#' @param final.biomass Final biomass\n#' @param m The thinning law, defaults to -4/3\n#'\n#' @note Thinning laws were developed in a single-species, even-aged stand context.\n#' Consequently, their application in a multi-species, uneven-age community context\n#' may violate critical assumptions.  See Gerstenlauer et al. for a more\n#' thorough discussion.\n#' @references Wiegand et al. unpubl. #DD# check if this is published (I think I have it)\n#' @template stochasticplants\ndo.thinning = function(initial.biomass,final.biomass,m = -4/3){\n\n    out.vr = (final.biomass / initial.biomass) ^ m\n    \n    return(out.vr)    \n    }\n    \n#' Calculate Beta Values\n#'\n#' Obtain values from a Beta Distribution based on an input mean and variance. \n#' Note that the mean and variance are NOT the same as the Alpha and Beta inputs.\n#' I added a check - if Var is 0, then just the mean is returned (and no Beta\n#' distribution is applied).  Note that the variance is not like a typical variance\n#' in that at low variance values close to the mean are much more likely, and at\n#' high values, values far from the mean are much more likely (and the mean itself\n#' will have a relatively low probability of being drawn.\n#'\n#' @details Derivation for constraint on variance based on the mean: \\cr\n#' Mean must be > 0, Var must be > 0 (if Var == 0, then just the mean will be returned).\n#' Addionally, Var must be <= mean * (1 - mean) in order to ensure that alpha is positive\n#' alpha and beta, the parameter inputs to the beta distribution are constrained to be\n#' >= 0.  Consequently, below, we solve for the equation that determines allowed\n#' values of Var depending on the value of the mean. \\cr\n#' mean * ( (1 - mean) * mean * (1 / Var) - 1) = alpha  \\cr\n#' mean * ( (1 - mean) * mean * (1 / Var) - 1) >= 0 #alpha must be >= 0 \\cr\n#' mean * ( mean * (1/Var) - mean^2 * (1 / Var) - 1) >= 0 #expand \\cr\n#' mean^2 / Var - mean^3 / Var - mean >= 0 #expand further \\cr\n#' mean^2 - mean^3 - mean * Var >= 0 #multiply by Var.  No change in direction of >= sign, because Var must be > 0 \\cr\n#' mean^2 - mean^3 >= mean * Var #Add mean * Var to both sides of equation \\cr\n#' mean - mean^2 >= Var #divide by mean.  No change in direction of >= sign because mean > 0 \\cr\n#' mean(1 - mean) >= Var #factor \\cr\n#' Var <= mean(1 - mean) #Re-arrange to be more intuitive \\cr\n#' Beta imposes the exact same constraint as alpha (can substitute alpha into the equation for beta\n#' then use algebra). Beta = alpha/mean - alpha  Not shown here.\n#' @param num.out The number of values to generate based on the beta distribution\n#' @param mu The desired mean for the distribution.  Must be between 0 and 1.\n#' @param Var The desired variance for the distribution\n#' @return Returns a vector of length num.out with values from the Beta distribution.\n#' @note From Jakob's ScriptA.2_BetaDistribution_2011_01_18.r\n#' @author Jakob L. K. Gerstenlauer (main function) and Sasha Keyel (error messages)\n#' @export calc.beta\ncalc.beta = function(num.out, mu, Var){\n\n    if (mu <= 0 | mu >= 1){\n        stop(\"Mean for beta distribution must be between 0 and 1\")\n        }\n    \n    if (Var < 0){\n        stop(\"Variance cannot be less than one\")\n        }\n      \n    if (Var >= (mu * (1 - mu))){\n        stop(\"Variance cannot equal or exceed: mean * (1 - mean)\")\n        }\n    \n    if (Var == 0){\n        out.vals = rep(mu,num.out)\n    }else{    \n        # I do not know the origin of these equations, other than from\n        # Jakob's script.  I assume they are correct.\n        Alpha<- mu * ( (1-mu)* mu * (1/Var) -1)\n        Beta<- (Alpha / mu) - Alpha\n        }\n\n    out.vals = rbeta(num.out,Alpha,Beta)\n    return(out.vals)\n    }\n\n#' Stochastic Plants Setup\n#'\n#' Set up latin hypercube sampling for plant traits used in stochastic plants simulation \n#' %% #DD# add documentation for env.param.file and sp.param.file\n#'\n#' @param SampleSize Number of species to generate\n#' @param ModelRuns  Number of scenarios to generate\n#' @param sp.param.file A file containing species parameters.  See \\link[spatialdemography]{sp.param.file} for details.\n#' @param env.param.file A file containing environmental parameters.  See \\link[spatialdemography]{env.param.file} for details.\n#' @param do.seed.clone.override 0 indicates that seed and clone number should be treated as dependent traits\n#' 1 allows these traits to be specified as independent traits.\n#' @param do.thinning.override 0 indicates that some demographi transitions should be dependent traits\n#' based on the thinning law.  1 indicates that these parameters may be independently speciefied.\n#' @param NumSVars Number of species variables in sp.param.file input.  Default is 7.\n#' @param NumEVars Number of environmental variables in env.param.file.  Default is 7.\n#' \n#' @export stoch.plant.setup\nstoch.plant.setup = function(SampleSize,ModelRuns,sp.param.file,env.param.file,do.seed.clone.override = 0,do.thinning.override = 0,NumSVars = 7, NumEVars = 7){\n\n    if(!require(lhs)){ stop(\"Please install lhs: install.packages('lhs')\") }\n\n    #NumSVars = 7: seed.disp.ratio, adult.longevity, proportion.clones, seed emergence, seed biomass, adult biomass, clone biomass    \n    if (do.seed.clone.override == 1){\n        NumSVars = NumSVars + 2 # two optional override values: seed.num and clone.num\n        }\n    \n    if (do.thinning.override == 1){\n        NumSVars = NumSVars + 3 # three optional thinning override values: d12, d23, dc1 \n        }\n    \n    #Sample species using latin hypercube design    \n    species.lhs = lhs::improvedLHS(n = SampleSize, k = NumSVars, dup = 1)\n    \n    #Read in species trait ranges from file    #**# Need documentation for this somewhere - probably near the setup.inputs function\n    sp.info = read.csv(sp.param.file, row.names = 1)\n    \n    #Setup species values based on the hypercube sample\n    sp.vals = setup.inputs(sp.info, species.lhs)\n   \n    #NumEVars = 7: cost of reproduction, seed mortality, seedling survival, variance of seedling survival, mean fertility, variance of fertility, correlation between seedling survival and fertility    \n    #Sample environmental conditions using a latin hypercube design    \n    env.lhs = lhs::improvedLHS(n = ModelRuns, k = NumEVars, dup = 1)\n    \n    #Read in environmental conditions ranges from file #**# Need documentation for this too.\n    env.cond.info = read.csv(env.param.file, row.names = 1)\n    \n    #Setup environmental conditions based on the hypercube sample\n    env.cond = setup.inputs(env.cond.info,env.lhs,in.lbl = \"Model.Run\")\n\n    return(list(sp.vals,env.cond))\n    }\n\n#' Set up species and environmental inputs for stochastic plants simulation\n#'\n#' For stochastic plants simulation.  Creates according to Gerstenlauer et al. (in prep).\n#'\n#' @param in.info A file containing data to be sampled according to the hypercube design\n#' @param in.lhs A latin hypercube sampling matrix\n#' @param in.lbl A label for the dataframe. Can be \"Species\" or \"Model.Run\"\n#' @return returns the created species file read into R.\n#' @export setup.inputs\nsetup.inputs = function(in.info,in.lhs,in.lbl = \"Species\"){\n\n    #Get names from input parameters file\n    trait.names = row.names(in.info)\n    \n    #Check that number of trait names match number of traits\n    if (length(trait.names) != ncol(in.lhs)){\n        stop(\"Trait names must match number of traits in Latin Hypercube\")\n        }\n    \n    in.info$Range = in.info$Max - in.info$Min\n\n    if (in.lbl == \"Species\"){\n        #Create a data frame with a row for each species to be created    \n        out.vals = data.frame(Species = seq(1,nrow(in.lhs)))\n        }\n\n    if (in.lbl == \"Model.Run\"){\n        #Create a data frame with a row for each model run to be created    \n        out.vals = data.frame(Model.Run = seq(1,nrow(in.lhs)))\n        }        \n    \n    #Add the names of the traits to the data frame\n    for (nam in trait.names){\n        out.vals[[nam]] = rep(0,nrow(in.lhs))\n        }\n\n    #**# This may need optimization!\n    #loop through Latin hypercube samples\n    for (i in 1:nrow(in.lhs)){\n\n        #Restrict to a particular sample from the hypercube\n        this.sample = in.lhs[i , ]\n\n         #Loop through each trait, and get it's specific value\n          #Max - Min = Range - this is sampled by multiplying by the latin hypercube value for the trait, and then the sampled range is added to the minimum\n        for (tr in 1:ncol(in.lhs)){  #Either ncol(in.lhs) or length(trait.names) would work here.\n            this.trait = trait.names[tr]\n            out.vals[i , this.trait] = in.info[this.trait,\"Range\"] * this.sample[tr] + in.info[this.trait,\"Min\"]\n            }\n        }    \n    \n    return(out.vals)\n    }\n\n## CALCULATE TRAITS\n#' Calculate traits (stochastic plants)\n#'\n#' Calculate traits based on logic in stochastic plants MS\n#'\n#' @param sp.vals Input species parameters. See details at \\link[spatialdemography]{sp.vals}\n#' @param these.env.cond Input environmental settings. See details at \\link[spatialdemography]{env.param.file}\n#' @param sp.out.file Location for the output species file\n#' @param env.file Location for the output Environmental Layers file\n#' @param do.seed.clone.override An indicator variable to determine whether to override longevity/seed/clone trade-offs\n#' @param do.thinning.override An inidicator variable to determine whether to override default thinning behavior.\n#' @return No value is returned from the function, but a new species file is written and a new environmental layers file is written.\n#' @note Stochastic seed survival probably needs to be stochastic and change at each time step as well.\n#' @template stochasticplants\n#' @export calculate.traits\ncalculate.traits = function(sp.vals, these.env.cond, sp.out.file, env.file, do.seed.clone.override, do.thinning.override){ \n\n    warning(\"The calculate.traits function is in development and requires further testing\")\n\n    # Calculate juvenile biomass\n    sp.vals$biomass.juv = mean(c(sp.vals$biomass.seed,sp.vals$biomass.adult)) #Arithmetic mean.\n\n    #Make sure juvenile biomass is greater than or equal to clone biomass, otherwise the thinning law will behave oddly\n    if (sp.vals$biomass.juv < sp.vals$biomass.clone){\n        sp.vals$biomass.juv = sp.vals$biomass.clone #Set to clone biomass if juv.biomass is is less than clone biomass.\n        }\n\n    #Option to override the longevity/reproduction/seeds/clones trade-off\n    #If not doing the override (if using the override, the required fields will already be in sp.vals)\n    if (do.seed.clone.override == 0){    \n        ## Calculate reproductive allocation based on adult longevity\n        # reproductive allocation depended on adult longevity based on a Weibull function\n          #**# Why the Weibull?\n        k1 = 1   #**# Rationale?\n        k3 = 0.5 #**# Rationale?\n        \n        #**# This is giving me a square root of a negative number.  Something is wrong in the equation I have.\n        #Perhaps the raising to a power happens after the exp?  that would make sense with how it was written.\n        #relative allocation to reproduction (a)\n        sp.vals$a = k1 * (exp(-sp.vals$adult.longevity / these.env.cond$k2))^k3\n        \n        ## Sexual vs. asexual reproduction & seed size vs. seed number\n        #total allocation to reproduction (q)\n        sp.vals$q = sp.vals$biomass.adult * sp.vals$a * these.env.cond$fertility.mean   #in grams\n        #q = num.seeds * biomass.seed + num.clones * biomass.clone\n        #g = (num.clones * biomass.clone) / q\n        #The below follow algebraically from the above\n        sp.vals$num.clones = sp.vals$q * sp.vals$g / sp.vals$biomass.clone\n        sp.vals$num.seeds = sp.vals$q * (1 - sp.vals$g) / sp.vals$biomass.seed\n        }\n    \n    ## Thinning law\n    \n    #If not overriding thinning, get parameters (otherwise, parameters will already be in file)\n    if (do.thinning.override == 0){\n    \n        #Calculate thinning rates\n        sp.vals$d12 = do.thinning(sp.vals$biomass.seed,sp.vals$biomass.juv)\n        sp.vals$dc2 = do.thinning(sp.vals$biomass.clone,sp.vals$biomass.juv)\n        sp.vals$d23 = do.thinning(sp.vals$biomass.juv,sp.vals$biomass.adult)\n        }\n    \n    ## Putting together the vital rates\n    #Create a data frame to store the output\n    sp.data = data.frame(Species = sp.vals$Species)\n    \n    #Set up entries in dataframe\n    entries =  c(\"p01\",\"p02\",\"p11\",\"p12\",\"p22\",\"p23\",\"p30\",\"p32\",\"p33\",\"biomass.adult\",\"biomass.juv\",\"biomass.seed\",\"dispersalfunction\",\"disppar1\",\"disppar2\",\"F.p30\",\"F.p32\",\"S.p02\",\"S.p12\")\n    for (entry in entries){\n        sp.data[[entry]] = rep(NA,length(sp.vals$Species))\n        }\n\n    #calculate values to go in data frame\n    Ss = 1 # Ss is left here to remind me that it matters.  But it will actually be incorporated through a stochastic environmental layer\n    sp.data$biomass.adult = sp.vals$biomass.adult\n    sp.data$biomass.juv = sp.vals$biomass.juv\n    sp.data$biomass.seed = sp.vals$biomass.seed\n    sp.data$p01 = (1 - sp.vals$w) * (1 - these.env.cond$seed.mortality) #Number not germinating  * number surviving\n    sp.data$p02 = sp.vals$w * sp.vals$d12 * Ss #= p12 #number germinating * thinning * stochastic survival\n    sp.data$p11 = (1 - these.env.cond$seed.mortality) * (1 - sp.vals$w) # =p01 number not germinating * number surviving\n    sp.data$p12 = sp.vals$w * sp.vals$d12 * Ss #number germinating * thinning * stochastic survival\n    sp.data$p22 = 0 #By definition\n    sp.data$p23 = sp.vals$d23 #**# Is this defined somewhere?  I'm just assuming this is the thinning component\n    sp.data$p33 = sp.vals$adult.longevity #By definition\n    sp.data$p30 = sp.vals$num.seeds * (1 - sp.vals$seed.disp.ratio) #Number of seeds, except those that disperse\n    sp.data$p32 = sp.vals$num.clones * sp.vals$dc2 #Direct Clonal reproduction.  There is also an adult contribution through mobile seeds that immediately germinate - p02\n\n    #**# Add rounding - but try that after you get match with Jakob's results\n\n    sp.vals$ending = sprintf(\"%s:%s:%s;%s:%s\",sp.vals$biomass.adult,sp.vals$biomass.seed,sp.vals$biomass.clone,sp.vals$a,sp.vals$g)\n    sp.data$F.p30 = sprintf(\"%s;104;%s\",sp.data$p30,sp.vals$ending)\n    sp.data$F.p32 = sprintf(\"%s;105;%s\",sp.data$p32,sp.vals$ending)\n    \n    sp.data$S.p02 = sprintf(\"1;103;%s;%s\",these.env.cond$Ss.mean,these.env.cond$Ss.var)\n    sp.data$S.p12 = sprintf(\"1;103;%s;%s\",these.env.cond$Ss.mean,these.env.cond$Ss.var)\n    \n    # Version from MS\n    #keeping terminology from SpatialDemography, not from MS\n    #no mobile seeds - not spatially explicit\n    #p11 = (1 - seed.mortality) * (1 - w)\n    #p12 = w * d12 * Ss\n    #p22 = 0\n    #p23 = d23 #**# Is this defined somewhere?  I'm just assuming this\n    #p33 = adult.longevity\n    #p31 = num.seeds * (1 - seed.disp.ratio) * (1 - seed.mortality) * (1 - w)\n    #p32 = num.clones * dc2 + (1 - seed.disp.ratio) * num.seeds * p12 #Clonal reproduction + those seeds that immediately germinate & turn into juveniles\n        \n    #Set up dispersal function based on desired seed dispersal ratios\n    #**# Umm, how do you go from a seed dispersal ratio to a seed dispersal function?\n    #Wait, right now it's wired into the species setup.  So you should actually have the real\n    #dispersal function give a seed dispersal rate of 0.  That's kind of confusing, actually.\n    #It will work for the non-spatially explicit approach.  But if it is spatially explicit...\n    # then this species generation approach would need to be revised.\n    # such that the seed dispersal ratio came from the dispersal function.  And then a dispersal\n    # function would have been specified.\n    # but maybe I should start with specifying a dispersal function, then it will be more general\n    # and won't need revision later.\n    # do it later if you want this to be spatially explicit.  It will be easy enough to do.\n    sp.data$dispersalfunction = 3 #Test a constant dispersal function\n    sp.data$disppar1 = 0 #Seed disperse 0 cells - this will keep them all in the cell of origin\n    sp.data$disppar2 = NA #Not applicable for constant dispersal function.  #**# hopefully this does not break anything.    \n\n    #Write species file\n    write.table(sp.data, file = sp.out.file, sep = \",\", row.names = F, col.names = T)\n    \n    #Write environmental conditions file\n    #Write header to file\n    hdr = \"env.lbl,landscape.identifiers,env.type,cover.level,param1,param2,cond.lyr,cond.vals,env.change.freq,env.change.type,env.change.mag\\n\"\n    cat(hdr, file = env.file)\n\n    #Write values to file\n      #env.type == 1 is log-normal distribution, 6 = beta distribution based on a mean and \"variance\"\n    #note: env.type through cond.vals really aren't applicable, as env.change.type will override the behavior due to the copula.\n    fert.info = sprintf(\"1;%s;lnorm;%s;%s\",these.env.cond$Ss.fert.cor,these.env.cond$fertility.mean,these.env.cond$fertility.var) #1 indicates copula number, lnorm indicates log-normal distribution\n    fertility.data = sprintf(\"fertility,F,1,NA,%s,%s,NA,NA,1,from.file,%s\\n\",these.env.cond$fertility.mean,these.env.cond$fertility.var,fert.info)\n\n    Ss.info = sprintf(\"1;%s;beta;%s;%s\",these.env.cond$Ss.fert.cor,these.env.cond$Ss.mean,these.env.cond$Ss.var)\n    Ss.data = sprintf(\"stochastic_seedling_survival,S,6,NA,%s,%s,NA,NA,1,from.file,%s\\n\", these.env.cond$Ss.mean,these.env.cond$Ss.var,Ss.info)\n\n    cat(fertility.data, file = env.file, append = T)\n    cat(Ss.data, file = env.file, append = T)\n    \n    }\n\n#' Species Values Input\n#'\n#' Input species file for calculate traits %DD% Add documentation\n#'\n#' @details \\itemize{\n#' \\item biomass.seed Biomass of the species' seed (= seed mass).  Used in thinning & reproductive trade-off\\cr\n#' \\item biomass.adult Biomass of the adult.  Used in thinning law \\cr\n#' \\item  biomass.clone Biomass of clones produced.  Used in thinning law & reproductive trade-off \\cr\n#' \\item  g The proportion of reproductive effort allocated to producing clones \\cr\n#' \\item  seed.disp.ratio The proportion of seeds dispersing to other cells in the landscape \\cr\n#' \\item  w The proportion of seeds germinating at each time step \\cr\n#' \\item  seed.mortality The proportion of seeds that die \\cr\n#' \\item  adult.longevity The proportion of adults that survive each time step \\cr\n#' \\item  Ss Stochastic seedling survival #DD# needs more documentation \\cr\n#' \\item  k2 A parameter for the Weibull function that determines reproductive allocation \\cr\n#' \\item  fertility A multiplier that determines how many seeds/clones are produced for a given reproductive allocation \\cr\n#' \\item  sp.out.file The path and file where the new species file will be written (or of an existing file to be appended to) \\cr\n#' \\item  do.append Whether to create a new file (F) or to append to an existing file (T) \\cr\n#' \\item  n.seeds.o An option to override seed production (independent of the trade-off).  Both n.seeds.o and n.clones.o must be non-null to do the override. \\cr\n#' \\item  n.clones.o An ooption to override clone production.  Both this and n.seeds.o must be non-null to override the trade-offs. \\cr\n#' \\item  d12.o An option to override the thinning portion of the seed -> juvenile transition rate.  All d**.o must be non-null for the override to take place. \\cr\n#' \\item  d23.o An option to override the thinning portion of the juvenile -> adult transition rate.  All d**.o must be non-null for the override to take place. \\cr\n#' \\item  dc2.o An option to override the thinning portion of the clone -> juvenile transition rate.  All d**.o must be non-null for the override to take place. \\cr\n#' }\n#' @name sp.vals\nNULL\n\n#DD# Add documentation for the environmental settings file\n#DD# add in ' again when reenabling\n#* # Environmental Settings Input\n#* #\n#* #\n#* #\n# # @details STUFF GOES HERE.\n# #\n# # @name these.env.cond\n#NULL\n\n# # NOTE: This is not actually used in Jakob's quantile regression script!\n# # Compute partial correlations\n# #\n# # Definition of function that computes partial correlation matrix\n# # Used by qr.bqr\n# # %% I have absolutely no idea how this works!\n# #\n# # @author Jakob L.K. Gerstenlauer\n#pcor2 <- function(x){\n#    conc <- solve(var(x))\n#    resid.sd <- 1/sqrt(diag(conc))\n#    pcc <- - sweep(sweep(conc, 1, resid.sd, \"*\"), 2, resid.sd, \"*\")\n#    return(pcc)\n#    }\n\n#' Z transform\n#'\n#' Function for z transforming input variables. Used by qr.bqr\n#'\n#' @param x an input variable\n#' @author Jakob L.K. Gerstenlauer\nZtrans<-function(x){\n    return( (x - mean(x)) / sd(x) )\n    }\n\n#DD# This function will likely need to be completely redone!\n#' ForEach\n#'\n#' This function implements a simple algorithm transforming all variables that are part of the header vector with the function in FunctionName.\n#' Note that all variables are overwritten! by default\n#' The <<- operator creates objects in the global environment which is necessary here!\n#'\n#' @param DataFrame The data frame of reference\n#' @param header A vector of type character containing the names of all variables\n#' @param FunctionName The name of function which is used to transform all variables\n#' @param Appendix appendix to new variable name\n#' @author Jakob L.K. Gerstenlauer\nForEach <- function(DataFrame, header, FunctionName, Appendix=\"\"){\n    for (i in seq(1,length(header))){\n        #print(paste(DataFrame,\"$\",header[i],Appendix,\"<<-\",FunctionName,\"(\",DataFrame,\"$\",header[i],\")\",sep=\"\"))\n        eval (parse (text=paste(DataFrame,\"$\",header[i],Appendix,\"<<-\",FunctionName,\"(\",DataFrame,\"$\",header[i],\")\",sep=\"\")))\n        }\n    }\n\n\n# # QR/BQR Header setup\n# #\n# # Write the header for the quantile regression, boosted quantile regression,\n# # or correlation outputs\n# #\n# # @author Jakob L.K. Gerstenlauer and Sasha Keyel\n#make.header = function(in.vars,run.type,out.file){\n#\n#    #NO LONGER NEEDED - HEADER IS FORMED AT A LATER STEP\n#    #RunID is a linking function to join with the original header information\n#    #Variable is whether it is loglambda or variation of log lambda\n#    #Quantile is the quantile for which the data apply (not applicable for the correlations)    \n#    preface = \"RunID,Variable,Quantile\"\n#    if (run.type == \"cor\"){\n#        preface = \"RunID,Variable\"\n#        }\n#    \n#    in.vars = listtotext(in.vars,\",\") #convert variables to text\n#    hdr = sprintf(\"%s,%s\\n\", preface, in.vars)\n#    \n#    #Write header to file\n#    cat(hdr, file = out.file, append = FALSE)\n#    }\n\n#' Calculate modified coefficient of varation\n#'\n#' Calcualte modified coefficient of variation %% #DD# Add description for rationale here\n#'\n#' @param d2 A data frame\n#'\n#' @author Jakob Gerstenlauer, converted to function by Sasha Keyel\nget.cov = function(d2){\n\n    warning(\"get.cov is still under development.\")\n\n    #**# FLAG - I'm not sure a polynomial is the best fit/choice for this!\n    #1) First a modified coefficient of variation (COV) is calculated which reflects the dispersion of stochastic growth independent of mean growth\n    m2.lm<-lm(VarianceLogLambda ~ poly(LogLambda,2), d2)\n    #use the response residuals from the polynomial model\n    d2$COV<- residuals(m2.lm,\"response\")\n\n    #**# FLAG - THIS CALCULATION SEEMS WRONG\n    #rescale to zero as the lowest value #**# Why? Convenience? Or biology?\n    MIN<-min(d2$COV)\n    d2$COV<-d2$COV + abs(MIN) #**# Does this code actually work? Seems like you should subtract the minimum from all values\n\n    return(d2)\n    }\n\n\n#' Calculate Z-transform\n#'\n#' @param d2 A data frame\n#' @param in.vars input variables\n#'\n#' @author Jakob Gerstenlauer, converted to function by Sasha Keyel\ndo.z.transform = function(d2,in.vars){\n    \n    warning(\"do.z.transform is still under development\")\n    \n    #Do some standardizations: first z-transform all predictors to provide standardized regression coefficients\n    #compare H.Schielzeth 2010 Methods in Ecology & Evolution, 1, 103-113.\n\n    #overwrite all predictors with ztransform\n    predictors<-c(\"SeedDispRatio\", \"p01\", \"pveg\", \"ptbveg\", \"ptb0\", \"ptb2\", \"p22\", \"MeanSeedNumber\");\n    ForEach(\"d2\", predictors, \"Ztrans\")\n\n    #add interactions, e.g. monomials\n    d2$p01.p22<- d2$p01 * d2$p22\n    d2$p01.pveg<- d2$p01 * d2$pveg\n    d2$pveg.p22<- d2$pveg * d2$p22\n    d2$ptb2.p22<- d2$ptb2 * d2$p22\n    d2$ptb2.p01<- d2$ptb2 * d2$p01\n    d2$SDR.p01<- d2$SeedDispRatio * d2$p01\n    d2$SDR.p22<- d2$SeedDispRatio * d2$p22\n    d2$SDR.ptb2<-d2$SeedDispRatio * d2$ptb2\n\n    predictors<-c(\"p01.pveg\",\"pveg.p22\",\"ptb2.p22\",\"ptb2.p01\",\"p12\",\"p0s1\",\"pveg1\",\"p01.p22\",\n                   \"SDR.p01\", \"SDR.p22\", \"SDR.ptb2\");\n    ForEach(\"d2\", predictors, \"Ztrans\")\n\n    #z transform response variables for quantile regression analysis\n    d2$LogLambda.z<-Ztrans(d2$LogLambda)\n    d2$COV.z<-Ztrans(d2$COV)\n    return(d2)\n    }\n\n#' Calculatae spearman correlations\n#'\n#' Calculate spearman correlations for selected variables\n#'\n#' @param qr.cor.out qr.cor.out\n#' @param RunID An ID\n#' @param d2 A data frame\n#' @param cor.vars cor.vars\n#'\n#' @author Jakob Gerstenlauer and Sasha Keyel\nget.cors = function(qr.cor.out, RunID, d2, cor.vars){\n\n    #test this\n    LL.cors = c()\n    COV.cors = c()\n    for (this.var in cor.vars){\n        LL.cor = cor(d2[[\"LogLambda\"]],d2[[this.var]], method = \"spearman\")\n        COV.cor = cor(d2[[\"COV\"]],d2[[this.var]], method = \"spearman\")\n        LL.cors = c(LL.cors,LL.cor)\n        COV.cors = c(COV.cors,COV.cor)\n        }\n\n    size = length(cor.vars)\n    cors.results = data.frame(rep(RunID,size),Predictor = cor.vars, LogLambdaCor = LL.cors, COVCor = COV.cors)\n\n    write.table(cors.results, file = qr.cor.out, row.names = F, sep = \",\") \n    return(cors.results)\n    }\n\n#' Quantile regression helper function\n#'\n#' Helper function to implement the quantile regression\n#'\n#' @param d2 A data frame\n#' @param qr.results Results\n#' @param Response Response\n#' @param Predictor Predictor\n#' @param this.quantile The quantile of interest\n#' @param counter A counter\n#'\ndo.qr = function(d2,qr.results,Response,Predictor, this.quantile,counter){\n    #Load required packages\n    if (!require(quantreg)){ stop(\"Please install quantreg: install.packages('quantreg')\") }\n\n    Formula<- as.formula(paste(Response,\" ~ \",Predictor,sep=\"\"))\n    model.qr<-quantreg::rq( Formula, tau = this.quantile, data=d2);\n\n    SummaryObject<-summary(model.qr)\n\n    Slope<-SummaryObject$coefficients[2,1]\n    StandardError<-SummaryObject$coefficients[2,2]\n\n    Response.SE = sprintf(\"%s.SE\",Response)\n\n    qr.results[[Response]][counter] = Slope\n    qr.results[[Response.SE]][counter] = StandardError\n\n    return(qr.results)\n    }\n\n#DD# Where does this function fit in?\n#DD# How should it be implemented? Option in code or as a separate thing to run after code is completed?\n#DD# What data is required to run it? Base vital rates, individual species outcomes.\n#DD# so, this could be done outside the main function, as an analysis function, that reads in the species file and the summary info.\n#DD# So, you'd need an extraction code to get the info of interest\n#DD# Then you need to run the analysis\n#DD# Then you need to output the results.\n#' Implement quantile regression\n#'\n#' Implement quantile regression\n#' %% Re-enable this line when code is functional and properly integrated: @export quant.reg\n#'\n#' @param qr.out File to which the results should be written. Needs to already exist with header information (created earlier in the code)\n#' @param RunID ID to join to global scenario conditions\n#' @param d2 Input dataframe containing values\n#' @param qr.vars A list of variables in the dataframe to use in quantile regression\n#' @param quantiles The quantiles at which to do the evaluations\n#'\nquant.reg = function(qr.out, RunID, d2,qr.vars,quantiles){\n    \n    quant.vals = sort(rep(quantiles,length(qr.vars))) # Get a vector with the quantile values for assigning to results\n    size = length(qr.vars) * length(quantiles) #Get a length variable for use in setting up dataframe\n    qr.results = data.frame(RunID = rep(RunID, size), Predictor = rep(qr.vars,length(quantiles)), Quantile = quant.vals, LogLambda.z = rep(NA,size),LogLambda.z.SE = rep(NA,size), COV.z = rep(NA,size),COV.z.SE = rep(NA,size))\n    \n    counter = 0\n    #Loop through quantiles\n    for (i in 1:length(quantiles)){\n        this.quantile = quant.vals[i]\n    \n        #Loop through variables\n        for (j in 1:length(qr.vars)){\n            counter = counter + 1 #Keep an index of what row the results should be written to.\n\n            #First add the target predictor\n            TargetPredictor = qr.vars[j]\n            \n            #then add all other predictors\n            Predictor = TargetPredictor\n            for (ii in 1:length(qr.vars)){\n                if (ii!=j){Predictor <-paste(Predictor,\" + \",qr.vars[ii],sep=\"\")}\n                }\n            \n            Responses = c(\"LogLambda.z\",\"COV.z\")\n            for (Response in Responses){\n                qr.results = do.qr(d2,qr.results,Response,Predictor, this.quantile,counter)\n                }\n            LL.Response  <- \"LogLambda.z\";            \n            }\n        }\n    \n    write.table(qr.results, file = qr.out, row.names = F, append = F)\n    return(qr.results)\n    }\n\n#' Implement boosted quantile regression\n#'\n#' Implement boosted quantile regression\n#'\n#' @param bqr.out bqr.out\n#' @param RunID The run id\n#' @param d2 A data frame\n#' @param bqr.vars Variables to include in boosted quantile regression\n#' @param quantiles The quantiles to evaluate at\n#' @param NumberOfTrees Number of trees to use in Boosted Quantile Regression.\n#' 10,000 is suggested as a default. #DD# Look up source from main MS.\nboost.quant.reg = function(bqr.out, RunID, d2, bqr.vars, quantiles,NumberOfTrees=10000){\n    if (!require(gbm)){ stop(\"Please install gbm: install.packages('gbm')\") }\n    \n    #Set up subset of data for analysis\n    ndata.LL = na.omit(subset(d2, select= c(bqr.vars,\"LogLambda\")))\n    ndata.COV = na.omit(subset(d2, select = c(bqr.vars,\"COV\")))\n        \n    #Loop through quantiles\n    for (this.quantile in quantiles){\n        LL.gbm = gbm::gbm(LogLambda ~ .,distribution=list(name=\"quantile\",alpha=this.quantile), verbose=FALSE, interaction.depth=3, n.trees = NumberOfTrees, data=ndata.LL)\n        LL.summary = summary(LL.gbm)\n        LL.summary = LL.summary[ order(LL.summary$var) , ] #bring var into alphabetical order\n        \n        COV.gbm = gbm::gbm(COV ~ .,distribution=list(name=\"quantile\",alpha=this.quantile), verbose=FALSE, interaction.depth=3, n.trees = NumberOfTrees, data=ndata.COV)\n        COV.summary = summary(COV.gbm)\n        COV.summary = COV.summary[ order(COV.summary$var) , ] #bring var into alphabetical order\n\n        #create a data frame from these results\n        size = length(bqr.vars)\n        bqr.sub = data.frame(RunID = rep(RunID, size), Predictor = sort(bqr.vars), Quantile = rep(this.quantile,size), RelImp.LogLambda = LL.summary[ ,2], RelImp.COV = COV.summary[ ,2])\n        \n        if (!exists(\"bqr.results\")){\n            bqr.results = bqr.sub\n        }else{\n            bqr.results = merge(bqr.results, bqr.sub, all = T)\n            }\n        }\n\n    write.table(bqr.results, file = bqr.out, row.names = F, append = F, sep = \",\")\n    return(bqr.results)\n    }\n\n#**# NEED TO READ UP ON QUANTILE REGRESSION AND BOOSTED QUANTILE REGRESSION!!!\n#**# THIS FUNCTION NEEDS REVISING/FIXING (need to add in annotation for roxygen2 as well. But it was doing something weird!\n#   # Additional Analyses: Quantile Regression and Boosted Quantile Regression\n#   #\n#   # The purpose of this function is to conduct additional analyses on the SpatialDemography data\n#   #\n#   # @author Jakob L.K. Gerstenlauer, modified by Alexander \"Sasha\" Keyel\n#   # %**%@export do.quantile.regression\n#do.quantile.regression = function(in.file.base, out.file.base, quantiles){\n#\n#    #Temporary parameters for code testing\n#    #in.file.base = \"C:/docs/beplants/Scripts/test/\"\n#    #out.file.base = in.file.base\n#    #quantiles <- c(0.15, 0.5, 0.85)\n#\n#    #**# Flag - with the new version of the model, more options are available - so you may need to amend these in light of the new model!\n#    cor.vars = c(\"SeedDispRatio\",\"p01\",\"pveg\",\"ptbveg\",\"ptb0\",\"ptb2\",\"p22\",\"MeanSeedNumber\",\"p12\",\"p0s1\",\"pveg1\") #List of variables to be examined for correlations\n#    bqr.vars = cor.vars\n#    qr.vars = c(bqr.vars,\"p01.p22\",\"p01.pveg\",\"ptb2.p01\",\"ptb2.p22\",\"pveg.p22\",\"SDR.p01\",\"SDR.p22\",\"SDR.ptb2\") #bqr.vars plus interaction terms\n#\n#    #Set up out files\n#    qr.out = sprintf(\"%sQuantileRegression.csv\",out.file.base)\n#    bqr.out = sprintf(\"%sBoostedQuantileRegression.csv\", out.file.base)\n#    qr.cor.out = sprintf(\"%sQR_Correlations.csv\",out.file.base)\n#\n#    #Get in.files from in.file.base\n#    #**# Get list of files in directory\n#    #**# Go through list of files, and if they are the correct type, add to list of in.files\n#    # Temporary patch for running the code\n#    #in.file = sprintf(\"%sOutputParameters1022.txt\", in.file.base)\n#\n#    #**# Left off here in revisions\n#\n#    for (in.file in in.files){\n#        d2 = read.table(in.file, sep = \"\\t\", header=TRUE)\n#\n#        #**# Create the RunID at some point\n#\n#        #1) Calculate modified coefficient of variation (COV) #Wait, this is calculated separately for each analysis? That seems like a problem!\n#        d2 = get.cov(d2)\n#\n#        #**# Need to fix this to give interactions\n#        #1b?) Standardize predictor variables #**# FLAG - Do we really want to do this?\n#        #**# Figure out appropriate way to deal with interactions\n#          #1: do interactions first, then standardize them\n#          #2: do standardization first, then keep interactions\n#          #3: standardize non-interactions, then calculate interactions, then standardize the results (Jakob's approach, but this just seems wrong to me!\n#        d2 = do.z.transform(d2, qr.vars) #**# fix to deal with interaction terms\n#\n#        #2) calculate zero order spearman correlations between the mean and COV of the stochastic growth rate and all independent species traits\n#        get.my.cors(qr.cor.out, RunID,d2,cor.vars)\n#\n#        #3) Calculate standardized quantile regression coefficients\n#        quant.reg(qr.out, RunID, d2, qr.vars, quantiles)\n#\n#        #**# FLAG - It looks like the quantile regression is on standardized variables, while the boosted regression is on unstandardized variables - is this correct?\n#        #4) Using stochastic gradient boosting to calculate a variable importance measure with both mean and COV of the stochastic growth rate for all traits and severall quantiles\n#        boost.quant.reg(bqr.out, RunID, d2, bqr.vars, quantiles)\n#        }\n#    }\n\n\n#' Import environmental layer\n#'\n#' Takes an existing environmental layer in the format of an R matrix or raster and\n#' converts to the required input format for SpatialDemography. This may be used for \n#' multiple change steps for a single environmental layer (e.g., if there is\n#' mowing data for multiple years)\n#'\n#' @param lyr.lst A list of environmental layer values (one for each change step)\n#' @param lyr.format.lst A list specifying the format for each set of environmental layer values in lyr.lst\n#' @param outfile The landscape file to be generated.\n#'\n#' @export import.env.lyr\nimport.env.lyr = function(lyr.lst, lyr.format.lst, outfile){\n    \n    if (length(lyr.lst) != length(lyr.format.lst)){\n        stop(\"lyr.lst must have the same number of elements as lyr.format.lst!\")\n        }\n\n    for (i in 1:length(lyr.lst)){\n\n        lyr = lyr.lst[[i]]\n        lyr.format = lyr.format.lst[[i]]\n\n        #If using an input raster, do additional conversion requiring raster package\n        if (lyr.format == \"raster\"){\n            if (!require(raster)){ stop(\"Please install raster: install.packages('raster')\" ) }\n    \n            #Read in raster object (Logic of the if statement: if the lyr is already in raster format (which will show up as typeof == \"S4\"), then don't change it\n            if (typeof(lyr) != \"S4\"){\n                lyr = raster::raster(lyr)\n                }\n    \n            #convert to matrix format\n            lyr = as.matrix(lyr) # WArNING: Watch out for problems downstream - as.matrix from base R is used in other parts of the code and the raster version might mask the normal behavior of this function in other places.\n            }\n        \n\n        #Write header info\n        if (i == 1){\n            cells = seq(1, length(lyr))\n            cell.lbls = sprintf(\"Cell%s\",cells)\n            hdr = c(\"ChangeStep\",cell.lbls)\n            hdr = matrix(hdr, nrow = 1) #Reformat for proper output\n            write.table(hdr, file = outfile, sep = \",\", row.names = F, col.names = F)\n            }\n\n        #Convert matrix format to line format for writing to landscape file\n        lyr = matrix.as.vector(lyr)\n        lyr = c(i,lyr) #Add i as change step column\n        lyr = matrix(lyr, nrow = 1) #Reformat so that it is output as a row rather than a column.\n\n        #Write to landscape file\n        write.table(lyr, file = outfile, sep = \",\", row.names = F, col.names = F, append = T)\n        }        \n    }\n\n#' Make cumulative probabilities\n#'\n#' Converts from a series of individual transition probabilities to a cumulative transition probability\n#' @param in.transitions a matrix of transition probabilities, with rows corresponding to the transition probabilities for each value\nmake.cum = function(in.transitions){\n    \n    #Create a variable to hold the outputs\n    out.trans = in.transitions\n    #loop through rows\n    for (a.row in 1:nrow(in.transitions)){\n        this.row = in.transitions[a.row, ]\n        cum.tot = 0\n        \n        #Loop through elements in a row\n        for (j in 1:length(this.row)){\n            #Get the cumulative value for this row\n            cum.tot = cum.tot + this.row[j]\n            #Update the proper location with the cumulative value\n            out.trans[a.row, j] = cum.tot        \n            }\n        }    \n  \n    return(out.trans)\n    }\n\n#' Check that cumulative probabilities are correctly made\n#'\n#' Check that cumulative probabilities are correctly made\n#' @param in.vals input values\n#' @param check.probs The probabilities to be checked\n#' @param check.val The value that the last probability value must have\ncheck.cum = function(in.vals, check.probs, check.val){\n    #Check that the ending transitions are correct (1 for transition probabilities, 0 for delta probabilities)\n    part1 = length(in.vals) #Get size of in.vals, to know where to check\n    size = length(check.probs) #Get size of trans.probs, to know how many things to check\n    interval = size / part1 #Get interval at which to evaluate\n    \n    for (i in 1:interval){\n        eval.point = part1 * i\n        \n        if (check.probs[eval.point] != check.val){\n            stop(sprintf(\"The last cumulative transition probability MUST be %s\",check.val))\n            }\n        }\n    }\n\n\n#' Setup env.change.mag\n#'\n#' This is a helper function to facilitate setting up the env.change.mag field in\n#' the Enviornmental_layers file. This may not be relevant for many environmental change types.\n#' %% Add example for Markov version?\n#' @param env.change.freq The frequency of environmental change. Mainly included to ensure that it is not 0\n#' @param env.change.type The type of environmental change. For more info, see \\link[spatialdemography]{env.change.type}\n#' @param in.vals Input values excluding transition rates or changes in transition rates (changes to mean or sd SHOULD be included when appropriate for the change type)\n#' @param in.transitions Only applies to Markov approaches. This should be a matrix of transitions, starting with the lowest cell value to each other cell value (1st row), then an additional row for each cell value.\n#' @param in.delta.transitions Only applies to changing Markov approaches. This should indicate the change in transition probability.\n#' @param trans.type Acceptable values: \"ind\", \"cum\". Only applies to Markov approaches. Indicates whether transition probabilities are given for each transition (\"ind\"), or cumulatively to include prior transitions (\"cum\").\n#'\n#' @export setup.env.change.mag\nsetup.env.change.mag = function(env.change.freq, env.change.type, in.vals = NA, in.transitions = NA, in.delta.transitions = NA, trans.type = NA){\n\n    #Check for obvious, simple setup conditions\n    if (env.change.freq == 0){ return(\"0\")  } #env.change.mag can be 0/NA if the environment does not change    \n    if (env.change.type == \"swap\") { return(\"0\") } #env.change.mag can be 0 if the values are only swapped\n    \n    if (env.change.type == \"cover.change.and.swap\" | env.change.type == \"rnorm.prob\"){\n        stop(sprintf(\"setup.env.change.mag does not yet support %s. Sorry for the inconvenience\", env.change.type))\n        }\n    \n    if (env.change.type == \"landscape.wide.change\"){\n        #check that input is correct length\n        if (length(in.vals) != 4){\n            stop(\"Inappropriate input values. Values should be mean, standard deviation, change in overall mean, change in overall standard deviation, and should be in vector format.\")\n            }\n        \n        print(sprintf(\"mean: %s, sd: %s, change in mean: %s, change in sd: %s\",in.vals[1],in.vals[2],in.vals[3],in.vals[4]))\n        \n        return(listtotext(in.vals, \";\"))\n        }\n    \n    if (env.change.type == \"markov\" | env.change.type == \"markov.changing.transitions\"){\n        \n        #Check input dimensions\n        if ((length(in.vals)^2) != length(in.transitions)){\n            stop(\"There must be a transition probability for every pair of input values.\")\n            }\n\n        #Check that transition probabilities sum to 1 for individual transitions\n        if (trans.type == \"ind\"){\n            test = apply(in.transitions,1,sum)\n            test = unique(test) #All values should be 1, so this should be length 1\n            \n            if (unique(test) != 1 | length(test) != 1){\n                stop(\"Transition probabilities do not sum to 1. Did make a typo or did you mean to use cumulative probabilities?\")\n                }\n\n            #Convert normal transition probabilities to cumulative transition probabilities\n            in.transitions = make.cum(in.transitions)\n            }\n        \n        #Convert probabilities to a vector for use in later code\n        trans.probs = matrix.as.vector(in.transitions)\n            \n        #Check that the probabilities were constructed correctly (i.e. last value == 1)\n        check.cum(in.vals,trans.probs,1)\n\n        #Add internal delimiters\n        in.vals.out = listtotext(in.vals,\":\")\n        trans.probs.out = listtotext(trans.probs,\":\")\n        \n        out.vals = sprintf(\"%s;%s\",in.vals.out,trans.probs.out)\n\n\n        if (env.change.type == \"markov.changing.transitions\"){\n            # Check input dimensions\n            if (length(in.transitions) != length(in.delta.transitions)){\n                stop(\"There must be a change value for each transition value\")\n                }\n\n            #Convert delta.transitions to cumulative format\n            if (trans.type == \"ind\"){\n                in.delta.transitions = make.cum(in.delta.transitions)\n                }\n            \n            delta.probs = matrix.as.vector(in.delta.transitions)\n\n            #Check for an easy error in setting up cumulative changes in transitions\n            check.cum(in.vals,delta.probs,0)\n\n            delta.probs.out = listtotext(delta.probs,\":\")\n            out.vals = sprintf(\"%s;%s\",out.vals,delta.probs.out)            \n            }\n\n        return(out.vals)\n        }\n        \n    stop(\"If the code reached this point, something went wrong in setup.env.change.mag. Was env.change.type correctly specified and supported by SpatialDemography?\")\n    }\n\n#' Test Setup\n#'\n#' This function helps set up the file structure for the model accuracy/implementation test\n#'\n#' @param base.dir a base directory containing the relevant files\n#' @param run.name the run name and output directory\n#' @return Returns a list of the five files that are inputs to SpatialDemography\n#' @export test.setup\ntest.setup = function(base.dir, run.name){\n    \n    #Create a default value for the locations file\n    loc.file = \"none\"\n    \n    base.files = list.files(base.dir)\n\n    # Create a folder for the test run & inputs\n    inputs.dir = sprintf(\"%s/inputs/\", run.name)    \n    dir.create(inputs.dir, recursive = T)    \n    \n    #Initialize optional file names used in the SpatialDemography call (but not all are actually required)\n    sri.file = spi.file = \"\"\n\n    #Initialize species file\n    sp.dir = sprintf(\"%s/Species/\",run.name)\n    dir.create(sp.dir, showWarnings = F)\n    spf.file = sprintf(\"%sspecies_file_%s.csv\",sp.dir,run.name)\n\n    #loop through each file, and put a copy in the appropriate place    \n    for (a.file in base.files){\n    \n        file.part = substr(a.file,1,3)\n        b.file = sprintf(\"%s%s\",base.dir,a.file)\n        \n        #initial conditions file\n        if (file.part == \"INC\"){\n            inc.file = sprintf(\"%sInitial_conditions_%s.csv\",inputs.dir,run.name)\n            file.copy(b.file,inc.file) }\n        \n        #Settings file\n        if (file.part == \"SET\"){\n            set.file = sprintf(\"%sSettings_%s.csv\",inputs.dir,run.name)\n            file.copy(b.file,set.file) }\n            \n        #Environmental layers file\n        if (file.part == \"ENL\"){\n            enl.file = sprintf(\"%sEnvironmental_layers_%s.csv\",inputs.dir,run.name)\n            file.copy(b.file,enl.file) }\n        \n        #Species file\n        if (file.part == \"SPF\"){\n            file.copy(b.file,spf.file) }\n        \n        #Species base instructions\n        if (file.part == \"SPI\"){\n            spi.file = sprintf(\"%s/inputs/Species_instructions_file_%s.csv\",run.name,run.name)\n            file.copy(b.file,spi.file) }\n            \n        #Species response instructions\n        if (file.part == \"SRI\"){\n            sri.file = sprintf(\"%sSpecies_response_instructions_%s.csv\",inputs.dir,run.name)\n            file.copy(b.file,sri.file) }\n        \n        #Environmental layers file(s)\n        if (file.part == \"ELF\"){\n            el.name = substr(a.file,5, (nchar(a.file) - 4)) #Get the file name exclusive of the code and the .csv\n            enl.dir = sprintf(\"%s/landscape/\",run.name)\n            dir.create(enl.dir, showWarnings = F)\n            this.enl.file = sprintf(\"%s%s_%s.csv\",enl.dir,el.name,run.name)\n            file.copy(b.file,this.enl.file) }\n        \n        #Species locations file\n        if (file.part == \"LOC\"){\n            loc.file = sprintf(\"%slocations_%s.csv\",inputs.dir,run.name)\n            file.copy(b.file,loc.file) }\n        }    \n\n    #Check that all required files have been created\n    if (!exists(\"inc.file\") | !exists(\"set.file\") | !exists(\"enl.file\")){\n        stop(\"Not all required files were generated.  Check that an initial conditions file, settings file, and environmental layers file have been created\")\n        }\n\n    return(list(inc.file,set.file,enl.file,spf.file,spi.file,sri.file,loc.file))\n    }\n\n#' Check outputs\n#'\n#' Check that the outputs generated by the test run match their expected values\n#'\n#' This will ensure that changes to the code, or to the user's operating system\n#' do not change the overall model outcomes in unexpected ways.  The goal is to\n#' test the main model options, and ensure that they are still producing the \n#' outputs one would expect from the definition of the code implementation.\n#'\n#' @param run.name The name of the run\n#' @param RunLog A log for the run\n#' @export check.outputs\ncheck.outputs = function(run.name, RunLog){\n\n    # WARNING: Copying and pasting out of excel was yielding an erratic number of decimal places (sometimes 5, sometimes 8!)\n    #Rounding to 5 places as a patch.  But may need to replace all copied and pasted values (if you paste special instead of copying from formula, you get stable behavior with many more decimal places)\n    #I've made rounding standard now, so more decimal places can be input.  This is relevant in that if a number ends in 5 (e.g., 0.65, rounds to 0.6), it will round it differently than if it ends in 51 (0.651 - rounds to 0.7)\n    # NOTE: Need to set format to number, and give it at least 2 extra beyond what you want to round to (to avoid the 0.5 problem)\n    #7 decimal places (rounding to 5) was not enough for matrix diagnostics, due to a 50 at the end of one value\n\n    rl.cat(\"SpatialDemography executed successfully\",RunLog)\n    rl.cat(sprintf(\"%s Checks beginning\",run.name),RunLog)\n    \n    ## Check that all output files were created & spot check values from output files\n    # customize results for each run\n    was.vdb = 1\n    if (run.name == \"TestRun1\"){\n        #NOTE: An alterantive approach would be to create copies of each of the files, and compare the copy version to the created version.  Then you could check EVERYTHING, and would not need huge text strings as inputs.\n        #But it would not deal with an error where your template file becomes corrupted.  There is something nice about having the numbers explicitly here.  And column totals should be enough to check everything.\n        \n        #Order of entries for each vector:\n        #rows,columns,grand.total,c(row.totals),c(col.totals),spotcheck1,spotcheck2,spotcheck3, headers\n        # NOTE: Time file check removed because now timing file is optional and checked in the second vignette.\n        #chk.time = list(45,3,NA,NA,NA,c(1,2,\"Time\"),c(8,1,\"Dispersal probabilities generated\"),c(45,1,\"Code completed\"),\"N\")\n\n        #Grand total is 4813.057794, but character entries crash the script later (could convert these to factor and adjust the total)\n        #results.row.tots = c(16121.000000,2356.028897,-13663.971103) #NA, because there are character arguments here.\n        results.col.tots = c(NA,3,NA,NA,300,4,4.266666,4493.791128,4,4)\n        chk.results = list(3,10,NA,NA,results.col.tots,c(\"c\",3,\"Scale\"),c(1,9,5),c(3,7,-2.866667),\"C\")\n \n        #Hint: Copy paste from excel (transpose to rows for row totals, then copy to TINN-R), use ctrl + R, check regular expressions box, and replace \\t with ','.\n        occ.row.tots = c(17,18,60,34,35,64,41,42,61,42,43,58,45,46,59,47,48,57,47,48,52,49,50,55,48,49,58,51,51,60,53,52,60,56,56,61,59,57,63,63,61,67,64,64,69,67,66,71,69,67,76,73,70,79,73,73,78,75,77,80,78,81,82,81,82,84,84,85,87,88,88,90,91,91,94,92,93,98,95,94,101,98,99,104,100,101,107,103,104,110,106,106,112,108,109,114,110,111,117,115)\n        occ.col.tots = c(5050,158,79,0,0,0,903,343,0,794,0) \n        chk.occ = list(100,11,7327,occ.row.tots,occ.col.tots,c(3,8,11),c(100,11,0),c(90,7,15),\"C\")\n\n        chg.row.tots = c(2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104)\n        chg.col.tots = c(5050,253)\n        chk.change = list(100,2,5303,chg.row.tots,chg.col.tots,c(25,2,2),c(100,2,4),c(49,1,49),\"C\")\n        \n        chk.loglambda = list(10,4,NA,NA,NA,c(1,1,-0.1197051),c(9,4,0.239478),c(6,3,0.007529),\"A\") #NOTE: fix this check to include a grand total and sub-totals once Inf problem is fixed\n        chk.SSadult = list(100,21,NA,NA,NA,c(1,2,157.3888),c(100,20,-0.179403),c(56,9,0.018326),\"C\") # NOTE: Fix this when you fix the log lambda problem\n        chk.SSall = list(100,21,NA,NA,NA,c(1,2,54157.3888),c(100,21,3.400067),c(78,7,18988.938449),\"C\")\n\n        #In two lines of 50 entries, because one line seemed to be exceeding some limit of TINN-R!\n        juv.row.tots = c(16001.0000000,20002.0000000,9532.0400000,9533.0400000,12118.9341000,6580.7209826,6581.7209826,8499.6119494,5195.2231538,5196.2231538,6808.1293903,4578.5979201,4579.5979201,6059.8718341,4385.3380115,4386.3380115,5847.4594333,4457.9709438,4458.9709438,5978.3748484,4732.6576163,4723.6576163,6362.4824498,5151.5892293,5146.4900293,6959.0643195,5717.3743230,4077.6275642,5504.4818766,4533.3016894,3323.5364424,4497.5029760,3677.8675905,2773.0496292,3800.5390990,3060.3457800,2388.1759281,3332.3360321,2623.0556088,2132.5079748,3052.0147215,2327.3277867,1981.4615266,2902.4132963,2146.4601132,1918.2901596,2878.0614262,2061.9038246,1931.8368538,2964.5436049,\n                         2071.0471984,2015.1900186,2556.3911365,1725.7359195,1680.0684204,2481.6953299,1626.6452619,1585.5249595,2600.3175190,1667.8874988,1637.4606521,2846.9340173,1799.1844973,1762.8495523,3193.2595349,1997.8312875,1955.5090355,3629.9221896,2255.1636329,2205.9920726,4167.7967321,2570.0372444,2512.8533217,4790.0144251,2945.7127674,2879.1582588,5523.7835754,2177.4753653,2109.5594582,4163.9559453,1854.4453918,1779.6591765,3621.3233375,1747.4151886,1680.5487102,3510.8783326,1775.1298537,1713.3585234,3651.9343401,1891.0604818,1841.9102149,3961.3414773,2074.3096080,2022.9343288,4403.3793056,2316.9030909,2262.2267348,4966.2199462,2617.7851443,2558.7136836)        \n        juv.col.tots = c(5050.0000000,27432.6619165,16348.8960201,51.9701191,44.1542224,40.3735813,149163.7483060,37129.9576166,41.9021585,153437.6441818,108.2462440)\n        chk.SSJuv = list(100,11,388849.554366,juv.row.tots,juv.col.tots,c(1,2,4000),c(100,11,0.1724852),c(5,10,3837.3025),\"C\")\n\n        #In two lines of 50 entries, because one line seemed to be exceeding some limit of TINN-R!\n        seed.row.tots = c(200001.0000000,95292.4000000,95293.4000000,121143.3410000,65752.2098256,65753.2098256,84923.1194941,51870.2315379,51871.2315379,67981.2939025,45676.9792006,45677.9792006,60471.7183414,43717.3801149,43718.3801149,58320.5943326,44416.7094380,44417.7094380,59602.7484838,47136.5761635,47037.5761635,63416.8244984,51298.8922931,51238.9002931,69355.6431953,56929.7432301,40523.2756422,54782.8187658,45062.0168937,32955.3644236,44686.0297605,36480.6759055,27423.4962921,37689.3909896,30278.4577999,23547.7592808,32980.3603213,25878.5560883,20964.0797481,30150.1472147,22894.2778671,19426.6152664,28627.1329628,21058.6011316,18767.9015957,28356.6142625,20186.0382465,18876.3685379,29194.4360487,20250.4719842,\n                          19682.9001856,25085.9113654,16770.3591945,16304.6842037,24311.9532993,15752.4526194,15332.2495953,25471.1751905,16137.8749878,15824.6065215,27910.3401731,17423.8449728,17051.4955234,31346.5953493,19383.3128753,18951.0903553,35686.2218959,21929.6363295,21428.9207264,41037.9673208,25051.3724436,24470.5332170,47233.1442507,28781.1276738,28106.5825882,54543.8357542,21071.7536527,20383.5945824,40918.5594527,17814.4539183,17057.5917654,35465.2333754,16717.1518861,16039.4871021,34333.7833259,16967.2985375,16340.5852340,35717.3434012,18099.6048181,17599.1021486,38784.4147735,19905.0960803,19382.3432881,43177.7930560,22304.0309094,21748.2673483,48779.1994618,25285.8514431,24686.1368357,55698.9815126)        \n        seed.col.tots = c(5050.0000000,234326.9773246,133489.0588075,519.7161996,441.6363186,403.7358126,1525687.7708736,341525.9222388,419.1542563,1495646.0987093,1134.4546351)\n        chk.SSseed = list(100,11,3738644.525176,seed.row.tots,seed.col.tots,c(1,2,50000),c(100,11,51.9921946),c(29,6,13.617064),\"C\")\n\n        matdiag.row.tots = c(69.59812855,70.596257,71.596257,72.59812855,73.59812855,75.11708996,76.11247886,76.59812855,78.11118759,79.11118759,70.59084518,71.5935497,72.5935497,73.59084518,74.59084518,76.00543201,77.10601083,77.59084518,79.10582685,80.10582685,71.59638013,72.59629472,73.59629472,74.59638013,75.59638013,77.11181031,78.11258207,78.59638013,80.10765322,81.10765322,72.59420323,73.59257921,74.59257921,75.59420323,76.59420323,78.00769945,79.1058636,79.59420323,81.10601419,82.10601419)\n        matdiag.col.tots = c(100.0000000,220.0000000,38.72645501,40.0000000,40.0000000,38.3901292,33.0836104,28.2957258,415.0000000,415.0000000,415.0000000,415.0000000,415.0000000,415.0000000,3.3200000) #7 decimal places was not enough, due to the 0.5 problem\n        chk.matdiag = list(40,15,3031.815920,matdiag.row.tots,matdiag.col.tots,c(1,3,0.916223),c(40,15,0.083),c(22,9,10.375),\"C\") #TRUE counts as 1, False as 0.\n\n        #VDB inputs\n        spdat.col.tots = c(22000.0000000,202000.0000000,159969.3678078,225137.0719933,230420.1294484,244149.7284733,261371.6202708,1145713.1742795,459748.3052263,341238.1876533,1110709.3326962,534106.4663334,1920273.6995709,322819.9489757,542625.4587332,299973.0956467,247360.0283679,246154.5365964)\n        chk.spdat = list(4000,18,8515770.152073,NA,spdat.col.tots ,c(1,1,1),c(4000,18,0.015653),c(1900,13,0.001151),\"A2\") #Too many row totals for me to conveniently reproduce here!  Will hope that the grand total and column checks will be sufficient!\n        amat.row.tots = c(2004.372403,2005.372403,2006.372403,2007.372403,2008.372403,2009.62976,2010.57072,2011.372403,2012.57072,2013.57072,2005.355814,2006.355814,2007.355814,2008.355814,2009.355814,2010.646349,2011.5448,2012.355814,2013.5448,2014.5448,2006.372403,2007.372403,2008.372403,2009.372403,2010.372403,2011.62976,2012.57072,2013.372403,2014.57072,2015.57072,2007.355814,2008.355814,2009.355814,2010.355814,2011.355814,2012.646349,2013.5448,2014.355814,2015.5448,2016.5448)\n        chk.amat = list(40,2306,80417.983949,amat.row.tots,NA,c(1,3,0),c(40,2306,0),c(40,2305,0.04096),\"C\") #Too many col totals for met to conveniently reproduce here!\n        \n        amatsum.col.tots = c(1600,3520,5440,536.0202456,6640,6640,53.12)\n        chk.amatsum = list(640,7,24429.140246,NA,amatsum.col.tots ,c(640,7,0.083),c(1,1,1),c(1,4,0.669792),\"C\")\n\n        tmat.col.tots = c(1600,3520,5440,0,0,73360,64,0,0,0,33.9839488,0)\n        chk.tmat = list(640,12,84017.983949,NA,tmat.col.tots,c(640,12,0),c(1,1,1),c(99,7,0.1),\"C\")\n        \n        chk.lst = list(chk.results,chk.occ,chk.change,chk.loglambda,\n                       chk.SSadult,chk.SSall,chk.SSJuv,chk.SSseed,chk.matdiag,\n                       chk.spdat,chk.amat,chk.amatsum,chk.tmat) #chk.time,\n        }\n        \n    if (run.name == \"TestRun2\"){\n\n        #Order of entries for each vector:\n        #rows,columns,grand.total,c(row.totals),c(col.totals),spotcheck1,spotcheck2,spotcheck3, headers\n        #NOTE: Time file check removed because time file is checked in second vignette.\n        #chk.time = list(39,3,NA,NA,NA,c(1,1,\"Process\"),c(26,1,\"Seedling competition step finished\"),c(36,1,\"Calculate change in metrics\"),\"N\")\n\n        #Grand total: 687673.5990616 (but text entries error it, hence NA.\n        results.col.tots = c(NA,3,NA,NA,15,4,2,687605.599062,4,4) \n        chk.results = list(3,10,NA,NA,results.col.tots,c(\"c\",6,\"Sp.Rich\"),c(1,2,1),c(2,10,2),\"C\")\n \n        #Hint: Copy paste from excel (transpose to rows for row totals, then copy to TINN-R), use ctrl + R, check regular expressions box, and replace \\t with ','.\n        occ.row.tots = c(21,34,35,36,37)\n        occ.col.tots = c(15,73,75) \n        chk.occ = list(5,3,163,occ.row.tots,occ.col.tots,c(1,2,9),c(5,3,16),c(1,3,11),\"C\")\n\n        chg.row.tots = c(2,3,5,6,7)\n        chg.col.tots = c(15,8)\n        chk.change = list(5,2,23,chg.row.tots,chg.col.tots,c(\"c\",1,\"RunTime\"),c(5,2,2),c(3,2,2),\"C\")\n        \n        chk.loglambda = list(2,4,2.475480642,c(1.4122923,1.063188343),c(0.515552855,0.220388037,1.223721822,0.515817928),c(1,1,0.319909889),c(\"c\",2,\"sd.all\"),c(\"r\",2,\"Sp2\"),\"A\") \n\n        SSadult.row.tots = c(2814.2288,7700.435113,12834.15028,21324.89222,34386.19393)\n        SSadult.col.tots = c(15.0000000,49740.1116811,29299.8937780,2.7498403,2.1450470)\n        chk.SSadult = list(5,5,79059.9003464,SSadult.row.tots,SSadult.col.tots,c(1,2,1458),c(5,5,0.3861654),c(\"c\",3,\"Sp2\"),\"C\") #na.rm = T below, so do not include NA's when summing (but don't worry about them either\n\n        SSall.row.tots = c(302457.9788,332577.77679653,469500.590225319,629511.36671288,855088.983315117)\n        SSall.col.tots = c(15.0000000,1377682.5255441,1211437.1080943,1.2796396,0.7825719)\n        chk.SSall = list(5,5,2589136.6958499,SSall.row.tots,SSall.col.tots,c(\"c\",4,\"log.lambda.Sp1\"),c(5,5,0.244916),c(1,3,164993.9788),\"C\")\n\n        juv.row.tots = c(81332.25,101388.7808100,203059.2952263,315086.7419066,494723.6119617)\n        juv.col.tots = c(15,684613.8642459,510961.8156586)\n        chk.SSJuv = list(5,3,1195590.6799046,juv.row.tots,juv.col.tots,c(\"c\",2,\"Sp1\"),c(1,1,1),c(5,3,190093.437411564),\"C\")\n\n        seed.row.tots = c(218313.5,223494.3606000,253613.456890,293108.1378578,325989.4929269)\n        seed.col.tots = c(15,643328.5496171,671175.3986577)\n        chk.SSseed = list(5,3,1314518.9482748,seed.row.tots,seed.col.tots,c(\"c\",3,\"Sp2\"),c(5,3,159186.26977859),c(2,3,120603.6106),\"C\")\n\n        matdiag.row.tots = c(74.7497218,75.0433275,75.8432597,75.3379262)\n        matdiag.col.tots = c(6.0000000,6.0000000,8.8943991,4.0000000,4.0000000,8.8595318,7.4017187,6.4865857,41.5000000,41.5000000,41.5000000,41.5000000,41.5000000,41.5000000,0.3320000)\n        chk.matdiag = list(4,15,300.9742353,matdiag.row.tots,matdiag.col.tots,c(1,3,2.3230986),c(\"c\",3,\"A.Eigen\"),c(\"c\",15,\"Prop.Dispersing\"),\"C\") #TRUE counts as 1, False as 0.\n\n        #VDB inputs\n        spdat.row.tots = c(99302.0000000,36707.0000000,1460.0000000,137465.0000000,119015.5000000,44629.2500000,1358.2288000,164996.9788000,102891.7500000,49803.0000000,4384.0824000,157072.8324000,120607.6106000,51590.7808100,3319.3578880,175509.7492980,123273.9509500,110972.0743450,7650.1802800,241888.2055750,130345.5059400,92093.2208813,5188.9660868,227617.6929080,151076.6255188,182520.6153508,13456.5328714,347043.7737409,142038.5123391,132573.1265558,7874.3771799,282474.0160748,166804.2231483,304631.1745502,22809.3161297,494232.7138282,159193.2697786,190100.4374116,11583.9638234,360863.6710135)\n        spdat.col.tots = c(60.0000000,120.0000000,303896.7201762,313242.7493124,455272.5429151,469031.9089386,319093.5617628,270247.8404904,228670.5310556,284787.5029071,233877.1553618,303369.6860848,443103.7410257,455272.5429151,234313.2536910,275201.4720508,277363.6805300,311494.3780596)\n        chk.spdat = list(40,18,5178419.2672769,spdat.row.tots,spdat.col.tots ,c(1,2,1),c(39,18,43.20325014),c(15,4,521),\"A2\")\n\n        amat.row.tots = c(2537.2659200,2537.7605376,2538.2400000,2538.7346176)\n        chk.amat = list(4,2306,10152.0010752,amat.row.tots,NA,c(\"c\",2306,\"Entry_2304\"),c(\"c\",1,\"ChangeStep\"),c(2,308,0.5),\"C\") #Too many rows for totals\n        \n        amatsum.row.tots = c(26.1368234,26.4968572,28.1368234,29.1368234,30.1368234,30.7810617,31.7810617,32.7810617,34.1368234,34.4968572,36.1368234,37.1368234,37.7810617,38.7810617,39.7810617,41.1368234,26.4968572,28.1368234,28.4968572,29.4968572,30.4968572,31.2703334,32.2703334,33.7810617,34.4968572,36.1368234,36.4968572,37.4968572,38.2703334,39.2703334,40.7810617,41.4968572,26.7810617,28.1368234,28.7810617,30.1368234,31.1368234,31.7810617,33.1368234,33.7810617,34.7810617,36.1368234,36.7810617,37.7810617,38.7810617,39.7810617,41.1368234,41.7810617,27.2703334,28.4968572,29.7810617,30.4968572,31.4968572,32.7810617,33.4968572,34.7810617,35.2703334,36.4968572,37.2703334,38.7810617,39.7810617,40.7810617,41.4968572,42.2703334)\n        amatsum.col.tots = c(96,96,544,121.7350371,664,664,5.312)\n        chk.amatsum = list(64,7,2191.0470371,amatsum.row.tots,amatsum.col.tots,c(\"c\",4,\"Dominant.EigenValue\"),c(\"c\",1,\"ChangeStep\"),c(63,7,0.083),\"C\")\n\n        tmat.row.tots = c(150.0625000,151.0034600,152.0625000,153.0625000,154.0625000,155.0265000,156.0265000,157.0265000,158.0625000,159.0034600,160.0625000,161.0625000,162.0265000,163.0265000,164.0265000,165.0625000,151.0034600,152.0625000,153.0034600,154.0034600,155.0034600,155.9887144,156.9887144,158.0265000,159.0034600,160.0625000,161.0034600,162.0034600,162.9887144,163.9887144,165.0265000,166.0034600,151.0265000,152.0625000,153.0265000,154.0625000,155.0625000,156.0265000,157.0625000,158.0265000,159.0265000,160.0625000,161.0265000,162.0265000,163.0265000,164.0265000,165.0625000,166.0265000,151.9887144,153.0034600,154.0265000,155.0034600,156.0034600,157.0265000,158.0034600,159.0265000,159.9887144,161.0034600,161.9887144,163.0265000,164.0265000,165.0265000,166.0034600,166.9887144)\n        tmat.col.tots = c(96.0000000,96.0000000,544.0000000,3.2000000,0.0000000,7336.0000000,6.4000000,1.6000000,2013.6000000,0.0000000,4.0010752,44.8000000)\n        chk.tmat = list(64,12,10145.6010752,tmat.row.tots,tmat.col.tots,c(64,12,0.7),c(1,1,1),c(\"c\",7,\"p12\"),\"C\")\n        \n        chk.lst = list(chk.results,chk.occ,chk.change,chk.loglambda,\n                       chk.SSadult,chk.SSall,chk.SSJuv,chk.SSseed,chk.matdiag,\n                       chk.spdat,chk.amat,chk.amatsum,chk.tmat) #chk.time,\n        }\n\n    if (run.name == \"TestRun3\"){\n        stop(\"This option is not yet programmed!\")\n        }\n\n\n    if (!exists(\"chk.lst\")){\n        stop(sprintf(\"Error in doing checks for %s.  Please note that checks have only been programmed for TestRuns 1 & 2\", run.name))\n        }\n\n    do.standard.checks(run.name,RunLog,chk.lst,was.vdb)\n\n    rl.cat(sprintf(\"%s Checks completed successfully\",run.name),RunLog)    \n    }\n\n#' Implement checks of data\n#'\n#' Implement checks of data\n#' @details \\itemize{\n#' \\item do.standard.checks These are checks that EVERY test run should pass, given the correct inputs \\cr\n#' \\item do.vdb.checks These are checks that the visual debugger data output correctly \\cr\n#' \\item do.chg.checks Check that environmental change was implemented correctly \\cr\n#' }\n#'\n#' @param run.name Need file path for values to check\n#' @param RunLog File logging the testing procedure\n#' @param chk.lst List of inputs for values specific to the run\n#' @param was.vdb indicator for whether visual debugger data were generated\n#'\ndo.standard.checks = function(run.name,RunLog,chk.lst, was.vdb = 1){\n    #Check existence of files\n    path1 = sprintf(\"%s/outputs/\",run.name)\n    path2 = sprintf(\"%s/%s/\",run.name,run.name)\n    path3 = sprintf(\"%sDiagnostics/\",path2)\n    path.vec = c(rep(path1,1),rep(path2,7),path3) #rep(path1,2)\n    name.vec = c(\"Results\",\"Cells_occupied\",\"change_count_lookup\",\n                 \"LogLambda\",\"SpeciesStats_Adults_v2\",\"SpeciesStats_All_v2\",\n                 \"SpeciesStats_Juvs\",\"SpeciesStats_Seeds\",\"MatrixDiagnostics\") #\"Timefile_\",\n    format.vec = c(rep(1,1),rep(2,7),2) #rep(1,2)\n\n    if (was.vdb == 1){\n        vdb.paths = c(path2,rep(path3,3))\n        vdb.names = c(\"SpeciesData\",\"AMatrices\",\"AMatricesSummaries\",\"TransitionMatrices\")\n        vdb.formats = c(2,rep(2,3))\n        path.vec = c(path.vec,vdb.paths)\n        name.vec = c(name.vec,vdb.names)\n        format.vec = c(format.vec,vdb.formats)\n        }\n    \n    #Check that all three vectors have the correct length\n    if (length(path.vec) != length(name.vec) | length(path.vec) != length(format.vec)){\n        stop(\"Error in do.standard.checks: vectors for checking inputs do not match\")\n        }\n    \n    for (a in 1:length(path.vec)){  #1){ #\n        in.path = path.vec[a]\n        in.name = name.vec[a]\n        in.format = format.vec[a]\n        in.chk = chk.lst[[a]]\n        \n        #Check that file exists\n        chk.file(in.path,in.name,in.format,in.chk,run.name,RunLog)\n        \n        }\n    \n    #NOTE: Consider adding a check that landscape files are correct & figure out how to do this in a scenario specific way    \n    }\n\n#' Check file\n#'\n#' Check existence of a file & accuracy of values, based on specified inputs\n#'\n#' @param in.path in.path\n#' @param in.name in.name\n#' @param in.format in.format\n#' @param in.chk in.chk\n#' @param run.name Run name\n#' @param RunLog A log\n#'\nchk.file = function(in.path,in.name,in.format,in.chk,run.name,RunLog){\n    if (in.format == 1){\n        test.file = sprintf(\"%s%s%s.csv\",in.path,in.name,run.name)\n        }\n    if (in.format == 2){\n        test.file = sprintf(\"%s%s.csv\",in.path,in.name)\n        }\n        \n    if (!file.exists(test.file)){\n        err.mess = sprintf(\"No %s file created (or the file was created in an incorrect location\",in.name)\n        stop(err.mess)\n        }\n    no.err = sprintf(\"%s file exists in the correct location\",in.name)\n    rl.cat(no.err,RunLog)\n\n    #Check accuracy of inputs    \n    #unpack in.chk\n    t.rows = in.chk[[1]]\n    t.col = in.chk[[2]]\n    t.tot = in.chk[[3]]\n    t.row.tot = in.chk[[4]]\n    t.col.tot = in.chk[[5]]\n    t.spot1 = in.chk[[6]]\n    t.spot2 = in.chk[[7]]\n    t.spot3 = in.chk[[8]]\n    headers = in.chk[[9]]\n    \n    #Read in file\n    is.error = 0\n    #A takes row names and column names\n    if (headers == \"A\"){\n        test.dat = read.csv(test.file,row.names = 1) #read.table was giving an error of \"too many column names for columns\", and I have no idea why (it's a .csv, for crying out loud!)\n        }\n    \n    if (headers == \"A2\"){\n        test.dat = read.csv(test.file)\n        proto.row.names = test.dat[ ,1]\n        rownames(test.dat) = sprintf(\"%s%s\",seq(1,length(proto.row.names)),proto.row.names)\n        test.dat[ ,1] = NULL\n        }\n    \n    #N indicates no row or column names    \n    if (headers == \"N\"){\n        test.dat = read.table(test.file, sep = \",\")\n        }\n    #C indicates only column names\n    if (headers == \"C\"){\n        test.dat = read.csv(test.file)\n        }\n    \n    if (nrow(test.dat) != t.rows){\n        is.error = 1\n        rl.cat(sprintf(\"Row numbers did not match, %s != %s\",nrow(test.dat),t.rows),RunLog)  }\n    if (ncol(test.dat) != t.col){\n        is.error = 1\n        rl.cat(sprintf(\"Col numbers did not match, %s != %s\",ncol(test.dat),t.col),RunLog)  }\n    if (!is.na(t.tot)){ #NA will indicate that a row/column check is inappropriate\n        test.tot = sum(test.dat,na.rm = T)\n        test.tot = round(test.tot,5) #Round to 5 places\n        t.tot = round(t.tot,5) #make sure t.tot is to 6 places\n        if (test.tot != t.tot){\n            is.error = 1\n            rl.cat(sprintf(\"Grand totals did not match, %s != %s\",test.tot,t.tot), RunLog)\n            }\n        }\n    if (!is.na(t.row.tot[1])){\n        test.row.tot = apply(test.dat,1,sum, na.rm = T)\n        test.row.tot = round(test.row.tot,5)\n        t.row.tot = round(t.row.tot, 5) #Check that this is 6 places as well\n        test.row.tot = listtotext(test.row.tot,\";\")\n        t.row.tot = listtotext(t.row.tot,\";\")\n        if (test.row.tot != t.row.tot){\n            is.error = 1\n            rl.cat(sprintf(\"Row totals do not match, %s != %s\",test.row.tot,t.row.tot), RunLog)\n            }\n        }\n    if (!is.na(t.col.tot[1])){\n        test.col.tot = apply(test.dat,2,sum, na.rm = T)\n        test.col.tot = round(test.col.tot,5)\n        t.col.tot = round(t.col.tot,5)\n        test.col.tot = listtotext(test.col.tot,\";\")\n        t.col.tot = listtotext(t.col.tot,\";\")\n        if (test.col.tot != t.col.tot){\n            is.error = 1\n            rl.cat(sprintf(\"Column totals do not match, %s != %s\",test.col.tot,t.col.tot), RunLog)\n            }\n        }\n    \n    is.error = do.spot.chk(t.spot1,test.dat,is.error,RunLog)\n    is.error = do.spot.chk(t.spot2,test.dat,is.error,RunLog)\n    is.error = do.spot.chk(t.spot3,test.dat,is.error,RunLog)\n    \n    if (is.error == 1){\n        stop(sprintf(\"There were one or more problems with file %s. See RunLog for details\",in.name))\n        }\n    }\n\n#' Spot check\n#'\n#' Custom function for doing spot checks\n#'\n#' @param t.spot t.spot\n#' @param test.dat test.dat\n#' @param is.error Indicator for whether or not an error occurred\n#' @param RunLog A run log\n#'\ndo.spot.chk = function(t.spot,test.dat,is.error,RunLog){\n\n    spot.val = t.spot[3]\n    \n    #r indicates a spot check should check a row name\n    if (t.spot[1] == \"r\"){\n        pos = as.num(t.spot[2])\n        r.names = rownames(test.dat) #row.names is used for matrices, rownames for data frames\n        test.val = r.names[pos]\n        }\n    \n    #c indicates a spot check should check a column name\n    if (t.spot[1] == \"c\"){\n        pos = as.num(t.spot[2])\n        c.names = colnames(test.dat) #not col.names, as that is used for matrices\n        test.val = c.names[pos]\n        }\n        \n    if (t.spot[1] != \"r\" & t.spot[1] != \"c\"){    \n        spot.row = as.num(t.spot[1])\n        spot.col = as.num(t.spot[2])\n        test.val = test.dat[spot.row,spot.col] #Get test value from the data frame\n        }\n    \n    #This one is more complicated, because test.val might not equal spot.val because of rounding issues\n    if (test.val != spot.val){\n    \n        temp.err = 1 #can't use is.error, because that is function wide.  Indicate an error is possible\n        \n        #check if mismatch is due to rounding (but note that character inputs are also possible!)\n        test.val = as.num(test.val)\n        #if test.val is character, the above step will yield NA, and the error is legitimate\n        if (!is.na(test.val)){\n            test.val = round(test.val,5)\n            spot.val = round(spot.val,5)\n            if (test.val == spot.val){\n                temp.err = 0\n                }\n            }\n            \n        if (temp.err == 1){ \n            is.error = 1\n            rl.cat(sprintf(\"Spot check failed %s != %s\",test.val,spot.val),RunLog)\n            }\n        }\n    return(is.error)\n    }\n\n#' RunLog cat\n#'\n#' Customized cat function for writing to RunLog\n#'\n#' @param in.text Input text to be written\n#' @param RunLog the log to write to.\nrl.cat = function(in.text,RunLog){\n    in.text = sprintf(\"%s\\n\",in.text) #Add new line character that I always forget\n    cat(in.text, file = RunLog, append = T) #include append = T call, which I forgot in most previous calls\n    }    \n\n\n\n####################### BROKEN FUNCTIONS BELOW HERE ############################\n\n##Eigenvalues for each cell for each species\n##The overall A eigenvalue for each species\n##Dispersal probabilities (or do we want it as observed dispersal?) for each species.\n# NOTE: Replaced by compute.diagnostics\n#LocalTransitionMatrix = function(SeedDispersalRatio,S,B1.Grassland,B1.Cropland,B1.Forest,B2.Grassland,B2.Cropland,B2.Forest){\n#    #Calculate a local transition matrix L_habitat which is the product of B1 and B2 and O a matrix describing only the loss of seeds        \n#    #set-up of O: (u: seed dispersal ratio)\n#    #(1)(2)(3)(4)\n#    # 1-u 0 0 0\n#    #  0  1 0 0\n#    #  0  0 1 0\n#    #  0  0 0 1\n#    #\n#    #(1):mobile seeds, (2):seed bank, (3): juveniles, (4):adults\n#    \n#    O <- sparseMatrix(i= c(1,2,3,4), j= c(1,2,3,4),\n#                    x= c((1 - SeedDispersalRatio), 1, 1, 1),\n#                    dims = c(S,S))\n#    \n#    #for grassland patches:\n#    B.Grassland <- B2.Grassland  %*% O %*% B1.Grassland\n#    \n#    #for cropland patches:\n#    B.Cropland <- B2.Cropland %*% O %*%  B1.Cropland\n#    \n#    #for forest patches:\n#    B.Forest <- B2.Forest %*% O %*% B1.Forest\n#    ltm.out = list(O,B.Grassland,B.Cropland,B.Forest)\n#    return(ltm.out)\n#    }\n#\n#\n#NOTE: Replaced by compute.diagnostics & code is broken due to changes in the code\n##Calculate the eigenvalues for the main matrix for each species for the population model\n#CalcA = function(B1.lst,B2.lst,P,M.lst,change.count,outpath.base){\n#    \n#    #Set up file output\n#    A.out.path = sprintf(\"%sAeigen/\",outpath.base)  \n#    dir.create(A.out.path,recursive = T,showWarnings = F)\n#    A.out.file = sprintf(\"A_%s.csv\",change.count)\n#    A.header = \"Species,Matrix Eigen Value A\"\n#    cat(A.header,file = A.out.file)\n#    \n#    #Simple slow way (but may not be optimal\n#    for (sp in 1:length(B1.lst)){\n#        B1 = B1.lst[[sp]]\n#        B2 = B2.lst[[sp]]\n#        M = M.lst[[sp]]\n#        \n#        #This is the way Jakob originally framed it, so this should be correct\n#        A <- B2 %*% t(P) %*% M %*% P %*% B1\n#\n#        A.eigen<-eigen(A, only.values=TRUE)\n#        A.eigen = max(A.eigen$values) # NOTE: This fails when A gives (only?) complex numbers\n#        \n#        #Output the eigenvalues in a way that can be accessed by the visual debugger.\n#        this.output = sprintf(\"%s,%s\",sp,A.eigen)\n#        cat(this.output, file = A.out.file, append = T)\n#        \n#        }\n#        \n#    #return(list(A,A.eigen))\n#    }\n#\n##NOTE: Replaced by compute.diagnostics    \n#### Functions pertaining to Eigen-analysis and perturbation analysis\n##Calculate eigenvalues for local transition matrices\n#  #WARNING: NEED to add change.count\n#CalcEigen = function(ToRun,in.df,sp,B.Grassland,B.Forest,B.Cropland){\n#\n#    #start with the grassland local transition matrix\n#    GM.eigen<-eigen(B.Grassland)\n#    dom.pos<-which.max(GM.eigen$values)\n#    GM.dom.eigenv<-Re(GM.eigen$values[dom.pos]) #the dominant eigenvalue\n#    \n#    #forest local transition matrix\n#    FM.eigen<-eigen(B.Forest)\n#    dom.pos<-which.max(FM.eigen$values) #which.max gets the location of the local maximum\n#    FM.dom.eigenv<-Re(FM.eigen$values[dom.pos]) # NOTE: Re takes just the real part of a complex number\n#    \n#    #cropland local transition matrix    \n#    CM.eigen<-eigen(B.Cropland)\n#    dom.pos<-which.max(CM.eigen$values)\n#    CM.dom.eigenv<-Re(CM.eigen$values[dom.pos])\n#\n#    #Write outputs to file\n#    if (ToRun == 1){\n#        in.df$Grassland_Eigenvalue[sp] = GM.dom.eigenv\n#        in.df$Forest_Eigenvalue[sp] = FM.dom.eigenv\n#        in.df$Cropland_Eigenvalue[sp] = CM.dom.eigenv\n#        #cat(file=infile, sprintf(\"%s,\",GM.dom.eigenv),append=TRUE)\n#        #cat(file=infile, sprintf(\"%s,\",FM.dom.eigenv),append=TRUE)\n#        #cat(file=infile, sprintf(\"%s,\",CM.dom.eigenv),append=TRUE)\n#        }\n#    \n#    return(list(list(GM.dom.eigenv,FM.dom.eigenv,CM.dom.eigenv),in.df))\n#    }\n \n##Calcualte Perturbation-analysis of the dispersal matrix  \n#CalcPerturbation = function(ToRun,infile,A,A.eigen,p,DispersalProbabilities){\n#\n#    #standardize the matrix by dividing through the dominant eigenvalue\n#    As <- A / Re(A.eigen$values[1])\n#    \n#    #Here we calculate several indices proposed by Neubert and Caswell(1997) and Stott et al. (2010) using R code provided by Stott et al.(2010)\n#    # We omit the upper and lower Kreissbound indices because the calculation takes very long or even fails\n#    # and we know from Stott et al. Table 2 that the indices are strongly correlated with the rho_max and rho_min    \n#    rhomax.Stott        <- rhomax(As,30)\n#    rhomin.Stott        <- rhomin(As,30)\n#    reac.Stott          <- reac(A)\n#    firststepatt.Stott  <- firststepatt(A)\n#        \n#    #Dispersal submatrix Mij\n#    #For the dispersal submatrix, the interpretation of eigenvalues and vectors is not clear!\n#    DispM<-matrix(as.vector(DispersalProbabilities), nrow=p,byrow=TRUE)\n#    #image(DispM)\n#    DispM.eigen<-eigen(DispM, symmetric=TRUE)\n#    \n#    #the stable stage distribution\n#    dom.pos<-which.max(DispM.eigen$values)\n#    DispM.StableStageDist<-DispM.eigen$vectors[,dom.pos]/sum(DispM.eigen$vectors[,dom.pos])\n#    #the stable spatial distribution of the landscape\n#\n#    #the damping ratio as a measure of the rate of convergence towards the stable spatial distribution\n#    #compare: \"\"Shima, Noonburg, Phillips (2010) Life history and matrix heterogeneity interact to shape\n#    #metapopulation connectivity in spatially structured environments, Ecology, 91 (4) pp. 1215-1224.\n#    DampRatio<-DispM.eigen$values[1]/Mod(DispM.eigen$values[2])\n#\n#    #Write outputs to file  #WARNING: This part is broken\n#    if (ToRun == 1){\n#        cat(file=infile,  rhomax.Stott, rhomin.Stott, reac.Stott,  firststepatt.Stott, Re(A.eigen$values[1:5]),sep=\"\\t\",append=TRUE)\n#        cat(file=infile, \"\\t\", sep=\" \",append=TRUE)\n#        cat(file=infile, Re(DispM.eigen$values[1:5]), sep=\"\\t\", append=TRUE)\n#        cat(file=infile, \"\\t\", sep=\" \",append=TRUE)\n#        cat(file=infile, 1000 * sd(DispM.StableStageDist), sep=\"\\t\", append=TRUE)\n#        cat(file=infile, \"\\t\", sep=\" \",append=TRUE)\n#        cat(file=infile, DampRatio, sep=\"\\t\", append=TRUE)\n#        cat(file=infile, \"\\t\", sep=\" \",append=TRUE)\n#        }\n#    \n#    return(list(rhomax.Stott,rhomin.Stott,reac.Stott,firststepatt.Stott,DispM.eigen,DispM.StableStageDist,DampRatio))\n#    }\n\n### Functions for visualizing the spatially explicit landscapes\n#  #WARNING: THIS ONLY WORKS FOR SQUARE LANDSCAPES INPUT AS A SINGLE VECTOR STARTING AT THE TOP LEFT CORNER, reading left to right, then down a row, then left to right, until reaching the bottom right corner.\n#  #landscape is the original landscape, eigen.vals is a list of dominant eigenvalues, linklist links the cell codes in the landscape to the order of the eigenvalues in the eigen.vals list.\n#  #Add change.count and merge with CalcEigen?\n#EigenVis = function(landscape,extent,linklist,eigen.pdf){\n#    \n#    #Set a variable for making the plots\n#    maxplotval = 2\n#    \n#    #Do replacements for each thing in linklist (need to make sure the replacements don't double replace!)\n#    #First replacement converts to letters, to avoid double replacement of numbers (e.g., if 1 gets changed by chance to 2, and the next replacement looks for 2's, it will convert the replaced 2, and that would be bad.\n#    for (item in linklist){\n#        original.value = item[1]\n#        letter.value = item[2]\n#        landscape[landscape == original.value] <- letter.value\n#        }\n#\n#    #Second replacement changes the letters to the eigen values.  This is to avoid the possibility of double replacements due to overlap between numeric codes and eigenvalues (admittedly a low probability, but I like my codes to work cleanly)\n#    for (item in linklist){\n#        letter.value = item[2]\n#        eigen.val = as.numeric(item[3])\n#        landscape[landscape == letter.value] <- eigen.val\n#        \n#        #For plotting part\n#        if (eigen.val > maxplotval){\n#            maxplotval = eigen.val\n#            }\n#        \n#        }\n#        \n#    #R idiotically made landscape all text, so here we convert it back to numbers. #Note that as.numeric on eigen.val above does not fix the problem.  Stupid R!\n#    landscape = as.numeric(landscape)\n#    \n#    #Convert the landscape into a matrix #Need to specify byrow to get it to write each row right to left\n#    landscape.matrix = matrix(landscape,nrow = extent,ncol = extent,byrow = TRUE)\n#    \n#    #Make it into a raster\n#    landscape.raster = raster(landscape.matrix)\n#    \n#    pdf(eigen.pdf)\n#    plot(landscape.raster,col = c(\"firebrick\",\"orange\",\"light green\",\"chartreuse 4\"), breaks = c(0,0.75,1,1.25,maxplotval),main = \"Dominant Eigenvalues for landscape cells\") #\n#    dev.off()\n#    return(landscape.raster)\n#    }\n#\n\n##Visualize dispersal probabilities on the landscape\n##NOTE: This function could still use improvement.\n##NOTE: May be worth linking this to a simulation approach as well - then could look at dispersal effects over time\n#  #NOTE: K_g is carrying capacity in terms of biomass, need to divide by plant biomass to get K in terms of numbers of individuals\n#  #WARNING - THIS METHOD MAY FAIL IF A POPULATION IS DETERMINISTICALLY DECLINING TO EXTINCITON LOCALLY BUT RECEIVES ENOUGH DISPERSING INDIVIDUALS TO PERSIST.\n#    #Need to figure out under what circumstances this may occur.\n#  #The plots are still less than satisfying.  But maybe because my landscape is too small.\n#  #NOTE: add change.count\n#DispersalVis = function(landscape,DispersalProbabilities,K,SeedNum,eigen.vals,extent,disp.pdf) {\n#        \n#    #Loop through land cover types\n#    allseeds = c(0,0,0) #**# This will need to be changed if more than 3 landcover types\n#    for (lc in 1:3){ #**# THIS WILL NEED TO BE CHANGED IF MORE THAN 3 landcover types!\n#                \n#        # Check if eigenvalue is < 1, if so, the population will go extinct, and not produce dispersers at equilibrium\n#        if (eigen.vals[[lc]] >= 1){\n#\n#            #This is number of adults at carrying capacity * seeds produced per adult        \n#            #number of adults is equal to the K at equilibrium, #Calculate number of seeds produced per cell\n#            TotSeeds = K * SeedNum \n#            allseeds[lc] = TotSeeds #Put number of seeds into a vector\n#            }\n#        }\n#\n#    #Set up output landscape\n#    disp.landscape = rep(0,length(landscape))\n#\n#    pdf(disp.pdf)\n#    #Go through every cell in the landscape\n#    for (cell in 1:length(landscape)){\n#\n#        #Identify landcover type for cell of interest\n#        celltype = landscape[cell] + 1 #+1 is to correspond with allseeds vector.  This will get a number from the landscape, 1 = grassland (0 + 1), 2 = forest (1 + 1), 3 = cropland (2 + 1)\n#    \n#        #Get total seeds produced for that landscape type\n#        cell.seeds = allseeds[celltype]\n#                       \n#        #Use dispersal probabilites to calculate dispersal\n#        #Looks like DispersalProbabilities comes by cell (cells selected from left to right by rows from top to bottom), with distances to each other cell, going left to right by rows from top to bottom,\n#          #So, most of the dispersing seeds in Jakob's model remain in the cell of origin (actually seems reasonable), then a small portion disperse out to other cells.\n#        \n#        #Read Dispersal probabilities in blocks of extent^2\n#        blocksize = extent*extent #The blocks in dispersal probabilities are the square of the extent (also equal to landscape length, but for different reasons)\n#        blockstart = 1 + (cell -1) * blocksize #Starts at 1, second block starts at 401, 3rd block at 801, etc. (for block size = 400)\n#        blockend = cell * blocksize  #Ends at 400, then 800, etc. for blocksize = 400\n#        \n#        cell.dispersal.prob = DispersalProbabilities[blockstart:blockend]\n#        \n#        #Convert from Dispersal probabilities to realized dispersal at equilibrium  (total seeds produced * Dispersal probabilitie for a given cell)  \n#        cell.dispersal = cell.dispersal.prob * cell.seeds \n#        \n#        #Add values to total dispersal for the landscape\n#        disp.landscape = disp.landscape + cell.dispersal\n#        \n#        #Display dispersal per cell\n#        cell.matrix = matrix(cell.dispersal, ncol = extent, nrow = extent,byrow = T)\n#        cell.raster = raster(log(cell.matrix)) # Can get rid of log if desired.\n#        plot(cell.raster, main = sprintf(\"Maximum Log Dispersal for cell %s\", cell),col = colorRampPalette(c(\"dark red\",\"yellow\",\"chartreuse 4\"))(255))\n#        }\n#    \n#    #Display overall dispersal map\n#    landscape.disp.matrix = matrix(disp.landscape,ncol = extent, nrow = extent, byrow = T)\n#    landscape.disp.raster = raster(log(landscape.disp.matrix))\n#    plot(landscape.disp.raster,col = colorRampPalette(c(\"dark red\",\"yellow\",\"chartreuse 4\"))(255), main = \"Maximum Log Dispersal for the whole landscape\") #255 says how many colors to use in the color ramp.\n#    dev.off()\n#    }\n#\n    \n",
    "created" : 1427810531498.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "497575786",
    "id" : "F51C6DF8",
    "lastKnownWriteTime" : 1427735992,
    "path" : "C:/docs/beplants/Scripts/spatialdemography/R/sdhelper.r",
    "project_path" : "R/sdhelper.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}