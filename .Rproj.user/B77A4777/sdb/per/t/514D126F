{
    "contents" : "#This file contains the main simulation function for SpatialDemography.\n#It is in its own r script for ease of editing and for clarity.\n#See spatialdemography package for license info and more details.\n\n#' Function to run the simulation portion of SpatialDemography\n#' \n#' This function does the model setup, matrix diagonstics, and simulation portion of spatialdemography. \n#' %DD% ADD INPUT DESCRIPTIONS %%s.lbl is only really required for reading in changed landscape values from file.\n#' %% disp.pdf,eigen.pdf,rtd.c\n#'\n#' @param Model.Name The name of the model run\n#' @param ResultsFile The file that results will be written to.\n#' @param vdb.data An indicator for whether or not to create visual debugger data\n#' @param timefile Timing results are written to this file.\n#' @param write.timefile An indicator for whether the time file should be output.\n#' @param run.times A list of intermediate times during the model run\n#' @param run.lbl A list of labels for each of the intermediate times\n#' @param start.time The starting time for the model\n#' @param run.path The path for the model run\n#' @param DispPath The path for the dispersal tables\n#' @param outpath.base A base path for outputs\n#' @param num.sim The number of simulations to run\n#' @param S The number of life stages in the model (MUST BE 4)\n#' @param extent The length of one side of the square landscape\n#' @param p The number of cells in the landscape (extent ^ 2)\n#' @param landscape A list object containing the environmental layer values for each cell in the landscape\n#' @param landscape.identifiers A list of single letter identifiers for each environmental layer\n#' @param distances The distances between every pair of cells\n#' @param settings A dataframe containing the information from the settings file\n#' @param ic A dataframe containing the information from the initial conditions file\n#' @param rtd.c An indicator for how to handle response trait diversity. Currently non-functional, use the hard-wired default\n#' @param locations.file A file indicating species locations. May not be applicable in many circumstances.\n#' @param landscape.dir A directory pointing to where the landscape files should be written.\n#' @param SpTraits Species trait data read in from the species file\n#' @param tot.sp.num The number of species in the species pool (=spe)\n#' @param my.env Information about the environmental layers\n#' @param env.c.freq The frequency of environmental change\n#' @param is.change An indicator for whether or not change will occur in the model (for computational efficiency)\n#' @param change.count An indicator for the current environmental change step.\n#' @param env.lbl A vector of labels containing the landscape layer names\n#' @param s.lbl Another label\n#' @param lnd.lbl Another label\n#' @param competitiontype An indicator for what type of competition should be implemented\n#' @param microsites The number of microsites in the model\n#' @param Results A dataframe to hold the results from the model\n#' @param out.metrics A list of metrics to be calculated for the model\n#' @param scale.vec A list of spatial scales at which to evaluate the model\n#' @param timepoint.vec A list of timepoints at which to calculate the metrics given in out.metrics\n#' @param scale.cells.lst A list of cells corresponding to each spatial scale\n#' @param resolution The resolution to use for rounding (for calculating UTC values)\n#' @param log.trans Whether or not to log-transform the data. Currently not recommended, as this functionality is untested in multirich package\n#' @param MaxTime The maximum number of timesteps to run the model for.\n#' @param invasion How frequently invasion occurs\n#' @param num.invaders The number of species to have invade\n#' @param cells.to.invade The number of cells each species will invade\n#' @param repro.proportion The proportion of the species reproductive potential with which to invade\n#' @param K_g The carrying capacity in grams\n#' @param multi.species.K An indicator for whether or not to include a multispecies carrying capacity\n#' @param edge.type The edge type. Currently only Absorbing and Torus are supported\n#' @param do.simulation An indicator for whether or not to run the simulation\n#' @param do.diagnostics An indicator for whether or not to compute diagnostics\n#' @param testing An indicator for whether or not a testing run is being conducted\n#' @author Alexander \"Sasha\" Keyel & Jakob Gerstenlauer\nSimulation<-function(Model.Name,\n                      ResultsFile,\n                      vdb.data,timefile,write.timefile,\n                      run.times,run.lbl,start.time,\n                      run.path, DispPath,outpath.base,num.sim,\n                      S,extent,p,landscape,landscape.identifiers,distances,\n                      settings, ic,rtd.c,locations.file,landscape.dir,\n                      SpTraits,tot.sp.num,\n                      my.env,env.c.freq,is.change,\n                      change.count,env.lbl,\n                      s.lbl, lnd.lbl,\n                      competitiontype,microsites,\n                      Results,out.metrics,scale.vec,timepoint.vec,scale.cells.lst,\n                      resolution,log.trans,\n                      MaxTime,\n                      invasion, num.invaders, cells.to.invade,repro.proportion,\n                      K_g, multi.species.K,\n                      edge.type,\n                      do.simulation,do.diagnostics, testing){ #,do.eigen.maps,do.disp.maps\n\n    #shorten total species number to species end to spe\n    spe = tot.sp.num\n\n    #Create the appropriate vec-permutation matrix.  #Compare Hunter and Caswell 2005, http://www.montana.edu/rotella/501/HC2005.pdf #Could be moved out of simulation function to speed things up (i.e., only needs to be done once)\n    cpm.out = CreatePermutationMatrix(p,S)\n      M_sub = cpm.out[[1]]\n      P = cpm.out[[2]]\n      \n    #run.times = c(run.times,gettime());run.lbl = c(run.lbl,\"Permuation.Matrix.made\")\n    \n    #Set up demography matrix templates; create a sparse vector for the composite demography matrix with p*3 times p*3 elements #Could be moved out of simulation function to speed things up (i.e. only needs doing once.)\n    Dim<-S*S*p^2\n    B1.template = sparseMatrix(dims = c(1,Dim), i={}, j={},x=rep(0.0,Dim))\n    B2.template = B1.template\n    dim(B2.template)<-rep(S*p,2)#Reformat for allowing the diagonal to be assigned\n    diag(B2.template) = 1 #Set the diagonal to 1.  Will need to replace the 1st of every S elements on the diagonal with 0.\n    dim(B2.template) = c(1,Dim) #Put back as a 1 row matrix to maintain same format as B1.template\n    \n    run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Preliminary setup completed\")\n    \n    #set up matrices for simulation model.  If environmental change is set to change every time step, this setup will be undone   \n    mat.info = setup.matrices(K_g,spe,SpTraits,p,S,landscape,landscape.identifiers,distances,B1.template,B2.template,P,M_sub,DispPath,vdb.data,change.count,outpath.base,num.sim,run.times,run.lbl,multi.species.K, edge.type)\n      #Unpack mat.info for each species.\n      if (multi.species.K == 0){\n          #Append results to list if each species has a unique K.\n          K.lst = mat.info[[1]]\n          }\n      #else: doesn't matter - a multi-species K will be applied later on.\n      B1.lst = mat.info[[2]]\n      B2.lst = mat.info[[3]]\n      DispersalProbabilities.lst = mat.info[[4]]\n      SeedDispersalRatio.lst = mat.info[[5]]\n      M.lst = mat.info[[6]]\n      run.times = mat.info[[7]]\n      run.lbl = mat.info[[8]]\n    \n      run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"setup.matrices completed\")    \n    \n    #Create map displaying initial dispersal probabilities\n    #if (do.disp.maps == 1){\n    #    #outpath.base\n    #    #NOT YET SCRIPTED\n    #    }\n    \n    #Run basic matrix diagnostics & write results to file\n    if (do.diagnostics == 1){            \n        Gave.Warn = 0 #indicator for whether a warning was issued. If so, the warning will not be re-issued.\n        cd.out = compute.diagnostics(spe,B1.lst,B2.lst,M.lst,P,S,p,outpath.base,vdb.data,change.count,run.times,run.lbl,1,Gave.Warn) #Last 1 indicates this is the first time for creating diagnostics - need to set up files.\n          run.times = cd.out[[1]]\n          run.lbl = cd.out[[2]]\n          Gave.Warn = cd.out[[3]]\n        }\n\n    #Create map displaying initial eigen values\n    #if (do.eigen.maps == 1){\n    #    #outpath.base - needed for writing file outputs\n    #    #Not Yet Scripted\n    #    }\n    \n        \n    ##Time first two species matrix assignments (first may be slower due to generation of dispersal probabilities)\n    #if (calc.times == 1){\n    #    run.times = c(run.times,gettime()); run.lbl = c(run.lbl,sprintf(\"%s species matrix assigned\",sp))              \n    #    }\n    #\n    #    } #end species loop, turn off when troubleshooting\n    \n    run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"All species matrices assigned\")\n\n    #******# Begin Simulation #******#\n    if (do.simulation == 1){\n    \n        run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Simulation began\")\n\n        #determine indices for three stages\n        index<-1:(S*p)                  #This is a vector\n        IAdults    <-  index %% S == 0  #This is a vector, with Trues where index divided by number of stages has remainder 0 and falses everywhere else\n        ISeedlings <-  index %% S == 1\n        ISeedBank  <-  index %% S == 2\n        IJuveniles <-  index %% S == 3\n        #use:  n_Seedlings <- n_t1[Seedlings]\n        \n        #Create a vector for micro-sites for each cell for competition scenarios\n        if (competitiontype != 0){\n            #check that microsites is not set to NA\n            if (is.na(microsites)){\n                stop(\"Number of microsites must be specified for this competition type\")\n                }\n            \n            microsites.vec = rep(microsites,p)\n            }\n                \n        #Set variables for initialization of other variables                                                                                                               \n        n_0<- rep(0, S*p) #NOTE: THIS IS MIS-NAMED - n_0 only ever contains 0's in the current implementation of the code\n        \n        #Set up vectors for the life stages & outputs\n        life.stage.vector <-vector(MaxTime,mode=\"numeric\")\n        #OutputTemplate <-array(data=rep(0.0, Replications * MaxTime), dim=c(Replications,MaxTime))\n        OutputTemplate = array(data = rep(0.0,MaxTime),dim = c(1,MaxTime))\n        \n        #Set up lists\n        n0.lst = rep(list(n_0),spe)   #List for initial population vectors\n        nt1a.lst = rep(list(n_0),spe) #List for intermediate time step in matrix model\n        nt1.lst = rep(list(n_0),spe)  #List for population vector at time t + 1\n        lifestage.lst = rep(list(life.stage.vector),spe) #Create a list to use as a template for the life stage summaries\n        OutputTemplate.lst = rep(list(OutputTemplate),spe) #Create a list to use as a template for some of the outputs\n    \n        #Reset seed to what it would have been in previous version of code\n        if (exists(\".Random.seed\")){\n            .Random.seed <<- load.seed(Model.Name, 1, testing) #Only loads a seed if testing == T  #set.seed(111)       \n            }\n    \n        #Initialize species in each cell\n        #n0.lst = OccSetup(n0.lst,spe,species.locs,S,n.seed,n.juv,n.adult)\n        n0.lst = setup.locations(n0.lst, spe, S, p, ic, settings, locations.file, SpTraits, rtd.c, run.path)\n        #the initialize.species function wasn't doing anything setup.locations wasn't already doing. Change this if that changes\n        #is.out = initialize.species(n0.lst,spe,S,SpTraits, settings, ic, run.times, run.lbl, first.run) \n        #  n0.lst = is.out[[1]]\n        #  run.times = is.out[[2]]\n        #  run.lbl = is.out[[3]]\n        \n        #Only loads a seed if testing == T #set.seed(444)\n        if (exists(\".Random.seed\")){\n            .Random.seed <<- load.seed(Model.Name, 3, testing)\n            }\n        \n        run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Initial simulation setup complete\")\n    \n        ## Get initial values for metrics for the model\n        num.tp = length(timepoint.vec) #This could be moved somewhere else. Also used in calcuation of final metrics\n\n        ini.abund.lst = list()\n        for (sv in 1:length(scale.vec)){\n\n            #Set up for subsetting (if any)\n            scale.cells = extract.scale.cells(scale.cells.lst, sv, S) #The label in scale.vec is not needed, as the indices are all positional.\n\n            #out.metric = calc.metrics(Results,\"Initial\",n0.lst,IAdults,spe,p,SpTraits)\n            out.metric = calc.metrics.v2(Results,\"Initial\",n0.lst,IAdults,spe,p,SpTraits, scale.cells, sv, num.tp)\n            #Update species richness, beta-diversity, and biomass & get abundance vector for calculating functional diversity\n            Results = out.metric[[1]]\n            ini.abund.lst = append(ini.abund.lst, list(out.metric[[2]])) #This is used to calculate functional diversity at the end of the simulation\n                \n            run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Initial results recorded\")\n            }\n    \n        # set up a look up table to record which values of change count correspond to which runtimes    \n        change.count.lookup = sprintf(\"%schange_count_lookup.csv\",outpath.base)\n        cat(\"RunTime,ChangeCount\\n\", file = change.count.lookup)\n        \n        if (vdb.data == 1){\n            ## Set up output file for stats for each timestep\n            seed.stats = sprintf(\"%sSpeciesStats_Seeds.csv\",outpath.base)\n            juv.stats = sprintf(\"%sSpeciesStats_Juvs.csv\",outpath.base)\n            ad.stats = sprintf(\"%sSpeciesStats_Adults.csv\",outpath.base)\n            all.stats = sprintf(\"%sSpeciesStats_All.csv\",outpath.base)\n            cells.occupied = sprintf(\"%sCells_occupied.csv\",outpath.base)\n            \n            #Create a text list of all the species to use as a header\n            the.spp.lbl = sprintf(\"Sp%s\", seq(1,spe)) \n            the.spp.lbl = listtotext(the.spp.lbl,\",\")\n            the.hdr = sprintf(\"RunTime,%s\\n\",the.spp.lbl) \n            \n            #Write the headers for the output files\n            cat(the.hdr,file = seed.stats)\n            cat(the.hdr,file = juv.stats)\n            cat(the.hdr,file = ad.stats)\n            cat(the.hdr,file = all.stats)\n            cat(the.hdr,file = cells.occupied)\n\n            #Set up to write species data to file (one big file instead of many small files!)\n            #NA's are because only the header is being written (last 1)\n            species.data = sprintf(\"%sSpeciesData.csv\",outpath.base)\n            write.sp.hdr.data(species.data, p)           \n            }\n        \n        #simulate sequence\n        for (RunTime in 1:MaxTime){\n        \n            ## Break the popoulation model into steps\n            #Step 1                    \n            for (sp in 1:spe){\n                 \n                #Demography 1 & migration for all species\n                nt1a.lst[[sp]] <- t(P) %*% M.lst[[sp]] %*% P %*% B1.lst[[sp]] %*% n0.lst[[sp]]\n                }\n                \n            if (RunTime == 1){\n                run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"First demography step completed (includes matrix setup for environmental change scenarios\")\n                }\n\n           ## If invasion is allowed, carry out invasion\n            if (invasion != 0){\n                # Only do invasion if it is an invasion year (i.e. RunTime matches the invasion interval e.g., if invasion happen every 5 years, when RunTime is 5,10,15, etc. this will cause invasion        \n                if (RunTime %% invasion == 0){\n                    \n                    #Note: Currently the magnitude of invasion is hardwired.  This could be adjusted to change in the code as well.\n                      #Magnitude could be in terms of numbers invading or in terms of number of species invading!  Or number of cells invaded!\n                    nt1a.lst = do.invasion(nt1a.lst,spe,p,S,SpTraits,num.invaders,cells.to.invade,repro.proportion)\n                    }\n    \n                }\n            \n            ## Enforce seedling competition \n            \n            #If competitiontype == 0, do nothing.\n            if (competitiontype != 0){\n                nt1a.lst = do.competition(competitiontype, microsites.vec, nt1a.lst, spe, ISeedBank, ISeedlings, p)\n                }\n\n    \n            if (RunTime ==1 ){\n                run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Seedling competition step finished\")\n                }\n    \n            \n            #Step 2\n            for (sp in 1:spe){\n                #Demography 2\n                nt1.lst[[sp]] <- B2.lst[[sp]] %*% nt1a.lst[[sp]]\n                }\n    \n            if (RunTime ==1 ){\n                run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Second demography step finished\")\n                }\n    \n            \n            if (multi.species.K == 0){\n                for (sp in 1:spe){\n                    #enforce species specific adult carrying capacity K \n                    K = K.lst[[sp]]\n                    nt1.lst[[sp]][IAdults]<-ifelse(nt1.lst[[sp]][IAdults] > K, K, nt1.lst[[sp]][IAdults])\n                    }\n            }else { \n                #Impose multispecies carrying capacity\n                  #Currently only proportional to abundance of adults, no competitive advantages\n                          \n                #Expand ms.K to be for the whole landscape\n                K_g.land = rep(K_g,p) #K_g.land is to denote that it is for the entire landscape\n                \n                #Sum total biomass of adults present.  If < K, do nothing\n                BiomassperCell = rep(0,p) #Create a separate entry for each cell\n                \n                #**# This for loop could probably be replaced\n                for (sp in 1:spe){\n                    sp.txt = sprintf(\"%s\",sp)\n                    #Add previous biomass to (number of adults of the current species * biomass of an adult)\n                    BiomassperCell = BiomassperCell + nt1a.lst[[sp]][IAdults] * SpTraits[sp.txt,\"biomass.adult\"]\n                    }\n                \n                #If greater than K, figure out proportional reduction needed to reach K for each cell\n                    #find proportion to reduce by\n                    #Remember - you are doing this per cell, per species.  Here is the per cell part\n                    #AdultsperCell * prop.reduction = K\n                    #K / AdultsperCell = prop.reduction\n    \n                prop.reduction = rep(1,p) #This might actually not be needed - set up a vector to be filled\n                prop.reduction = ifelse(BiomassperCell > K_g.land, (K_g.land / BiomassperCell),1)\n                \n                #**# This one too, perhaps?                   \n                #Apply proportional reduction to each species\n                for (sp in 1:spe){\n                    #Don't actually need biomass here since this would be (adults * biomass * reduction) / biomass.  Biomass cancels, leaving adults * reduction\n                    nt1.lst[[sp]][IAdults] = nt1.lst[[sp]][IAdults] * prop.reduction\n                    }\n                \n                }\n    \n            if (RunTime ==1 ){\n                run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Carrying capacity applied\")\n                }\n        \n            #Create lists to hold summary output if vdb.data is being used\n            SeedBank.lst = Juveniles.lst = Adults.lst = All.lst = Cells.Occupied.lst = rep(NA,spe)\n            \n            for (sp in 1:spe){\n                ## Set the initial population vector for the next run\n                n0.lst[[sp]] <- nt1.lst[[sp]]  \n                \n                ## Compute summary information\n                if (vdb.data == 1){\n                    \n                    #**# Optimization note: could change this so all information is written at once at the end - this would probably be quicker (don't have to keep writing to file)\n                    \n                    #Get information to output\n                    VSeedBank <- nt1.lst[[sp]][ISeedBank]\n                    SeedBank.lst[[sp]]<-sum(VSeedBank)\n                    \n                    VJuveniles <- nt1.lst[[sp]][IJuveniles]\n                    Juveniles.lst[[sp]] <- sum(VJuveniles)\n                    \n                    VAdults   <- nt1.lst[[sp]][IAdults]\n                    Adults.lst[[sp]]<- sum(VAdults)\n                    \n                    VAll = VSeedBank + VJuveniles + VAdults\n                    All.lst[[sp]] = sum(VAll)\n                         \n                    #Calculate number of cells occupied by more than 1 adult. #Formerly was occupied by >2 adults.\n                    Cells.Occupied.lst[[sp]] <- length(VAdults[ VAdults > 1])\n                  \n                    #Output species data to a large aggregate file\n                    write.sp.data(\"Seeds\",sp,RunTime,VSeedBank,extent,species.data)\n                    write.sp.data(\"Juveniles\",sp,RunTime,VJuveniles,extent,species.data)\n                    write.sp.data(\"Adults\",sp,RunTime,VAdults,extent,species.data)\n                    write.sp.data(\"ALL\",sp,RunTime,VAll,extent,species.data)\n                  \n                    # Plots left over from an earlier version of the code. Currently not used\n                    # The plots will now be done in the server file, rather than here.\n                    #Trellis1<-levelplot(SpatialDist.SeedBank, colorkey=TRUE, xlab=\"\", ylab=\"\")\n                    #Trellis2<-levelplot(SpatialDist.Juveniles, colorkey=TRUE, xlab=\"\", ylab=\"\")\n                    #Trellis3<-levelplot(SpatialDist.Adults, colorkey=TRUE, xlab=\"\", ylab=\"\")\n                    #\n                    #Row<-1 + RunTime/3 \n                    #\n                    #\n                    #plot(Trellis1, split=c(1,Row, 3,4), more=TRUE)\n                    #plot(Trellis2, split=c(2,Row, 3,4), more=TRUE)\n                    #plot(Trellis3, split=c(3,Row, 3,4), more=TRUE)\n                    }\n                \n                } #end of species loop\n            \n            # Write species summary data to file\n            if (vdb.data == 1){\n                seedbank.out = listtotext(SeedBank.lst,\",\")\n                juv.out = listtotext(Juveniles.lst,\",\")\n                ad.out = listtotext(Adults.lst,\",\")\n                all.out = listtotext(All.lst,\",\")\n                cells.occ.out = listtotext(Cells.Occupied.lst,',')\n                \n                cat(sprintf(\"%s,%s\\n\",RunTime,seedbank.out), file = seed.stats, append = T)\n                cat(sprintf(\"%s,%s\\n\",RunTime,juv.out), file = juv.stats, append = T)\n                cat(sprintf(\"%s,%s\\n\",RunTime,ad.out), file = ad.stats, append = T)\n                cat(sprintf(\"%s,%s\\n\",RunTime,all.out), file = all.stats, append = T)\n                cat(sprintf(\"%s,%s\\n\",RunTime,cells.occ.out), file = cells.occupied, append = T)            \n                }\n\n            ## ENVIRONMENTAL CHANGE\n            #Set an indicator for whether matrices need to be reset or not (i.e. did change occur this time step?)\n            time.step.change = 0\n    \n            #Do not do environmental change on the very last time step: no point: all demography, etc. has already taken place!\n            if (RunTime != MaxTime){\n    \n              #Step 0 (only if in a changing environment)\n              if (is.change == 1){\n                                  \n                  #Loop through change layers\n                  for (ev in 1:length(env.c.freq)){\n                      env.lyr = env.c.freq[ev]\n                      \n                      #Check if this environmental layer will ever change.  env.lyr == 0 will crash the next if statement (yields NAN instead of T/F\n                      if (env.lyr != 0){\n                                  \n                          #Check if this environmental layer will change this time step\n                          if (RunTime %% env.lyr == 0){\n                              \n                              #Set an indicator so that matrices and lists will be updated to take into account the new landscape\n                              time.step.change = 1\n      \n                              #Change the landscape as appropriate\n                              dec.out = do.env.change(my.env,ev,landscape,landscape.identifiers,p,run.path,env.lbl,s.lbl,landscape.dir, lnd.lbl, change.count)\n                              landscape[[ev]] = dec.out[[1]]\n                              my.env = dec.out[[2]]\n                                                     \n                              #NOTE: This timing step will not actually work, since this may not happen on the first run of the code!\n                              if (RunTime == 1){\n                                  run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Environment changed\")\n                                  }\n                              }\n                          }\n                      }               \n                  \n                  #If there was environmental change this timestep, reset the lists\n                  if (time.step.change == 1){\n      \n                      #Update the change counter to refelct the number of changes\n                      change.count = change.count + 1\n                            \n                      ## Set up matrices based on the neew landscape to govern model behavior                     \n                      #Calculate matrices for this species\n                      mat.info = setup.matrices(K_g,spe,SpTraits,p,S,landscape,landscape.identifiers,distances,B1.template,B2.template,P,M_sub,DispPath,vdb.data,change.count,outpath.base,num.sim,run.times,run.lbl,multi.species.K,edge.type)\n                        #Unpack mat.info for each species.\n                        if (multi.species.K == 0){\n                            K.lst = mat.info[[1]]\n                            }\n                        #else Doesn't matter - multispecies K will be applied later on.\n                        B1.lst = mat.info[[2]]\n                        B2.lst = mat.info[[3]]\n                        DispersalProbabilities.lst = mat.info[[4]]\n                        SeedDispersalRatio.lst = mat.info[[5]]\n                        M.lst = mat.info[[6]]\n                        run.times = mat.info[[7]]\n                        run.lbl = mat.info[[8]]                                           \n                      \n                      #Recompute diagnostics for new landscape\n                      if (do.diagnostics == 1){\n                          cd.out = compute.diagnostics(spe,B1.lst,B2.lst,M.lst,P,S,p,outpath.base,vdb.data,change.count,run.times,run.lbl, Gave.Warn = Gave.Warn)\n                            run.times = cd.out[[1]]\n                            run.lbl = cd.out[[2]]\n                            Gave.Warn = cd.out[[3]]\n                          }\n                      \n                      #If visual output is desired, save files\n                      if (vdb.data == 1){\n                          for (b in 1:length(env.lbl)){\n                              \n                              #Check if a file was already used, if so, do not reproduce it\n                              if (is.na(my.env$env.change.type[b]) | my.env$env.change.type[b] != \"from.file\"){ #Note: the second criteria crashes with an NA value, but because the first criteria evaluates first, if a value is NA, it will evaluate to True and skip the second step.\n                                  lbl = env.lbl[b]                                  \n                                  outfile = sprintf(\"%s%s_%s_%s.csv\",landscape.dir,lbl,s.lbl,Model.Name)                                  \n                                  write.env.lyr(landscape[[b]],change.count,extent,outfile)              \n                                  }\n                              }\n                          }\n                      }\n                  }\n              }\n        \n            #Write which change step corresponds to which runtimestep\n            cat(sprintf(\"%s,%s\\n\",RunTime,change.count), file = change.count.lookup,append = T)\n                    \n            if (RunTime ==1 ){\n                run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"First timepoint completed\")\n                }\n                \n            }#end of loop over time series                    \n    \n        #Output the last timestep run by the model so that one can check that the model ran to completion\n        Results$LastTime[1:nrow(Results)] = RunTime\n    \n        run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Remaining simulation runs completed\")\n       \n        #Calculate log lambda & dispersion of log lambda for all life stages\n        #If only run for one time step, this makes no sense, because you cannot calculate loglambda. Although running the model for a single time step should be relatively rare.\n        if (MaxTime > 1 & vdb.data == 1){\n            logL.all = get.log.lambda(all.stats,\"all\")\n        \n            #Calculate log lambda & disperson of ll for only adults\n            logL.ad = get.log.lambda(ad.stats,\"adults\")\n          \n            #Calculate log lambda & dispersion of ll for each cell\n            #LogL.all.cell = get.log.lambda(species.data, lifestage = \"ALL\") # NEEDS SCRIPTING\n        \n            #Calculate log lambda & dispersion of ll for each cell for only adults\n            #LogL.ad.cell = get.log.lambda(species.data, lifestage = \"Adults\") # NEEDS SCRIPTING\n            logLs = list(logL.all,logL.ad)\n\n            ll.out = sprintf(\"%sLogLambda.csv\",outpath.base)\n            compile.log.lambdas(logLs,ll.out)\n            }\n   \n        for (sv in 1:length(scale.vec)){\n        \n            #Recover the associated ini.abund.vec\n            ini.abund.vec = ini.abund.lst[[sv]]\n\n            #Set up for subsetting (if any)\n            scale.cells = extract.scale.cells(scale.cells.lst, sv, S) #The label in scale.vec is not needed, as the indices are all positional.\n        \n            #Calculate species richness, beta-diversity, and biomass at end of simulation\n            timepoint = \"Final\"                  \n            metric.out = calc.metrics.v2(Results,timepoint,n0.lst,IAdults,spe,p,SpTraits, scale.cells, sv, num.tp) #n0.lst is still appropriate here, because nt1.lst is reassigned to n0.lst at each model step.\n            Results = metric.out[[1]]\n            fin.abund.vec = metric.out[[2]]\n\n            run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Calculate final metrics\")\n\n            \n            #Calculate functional diversity at end of simulation\n            abund.mat = matrix(c(ini.abund.vec,fin.abund.vec), nrow = 2,byrow = T,dimnames = list(c(\"Initial\",\"Final\"),colnames(ini.abund.vec)))\n            Results = calc.fd(Results,SpTraits,abund.mat,spe,resolution,log.trans,sv, num.tp)\n\n            run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Calculate functional diversity\")\n\n            \n            #Calculate change in functional diversity over the course of the simulation\n            Results = calc.delta.metrics.v2(Results,out.metrics,sv,num.tp)\n\n            run.times = c(run.times,gettime()); run.lbl = c(run.lbl,\"Calculate change in metrics\")            \n            }\n\n        # Output results from this replicate\n        write.table(Results,file = ResultsFile,col.names = F,row.names = F, sep = \",\",append = T)\n        \n        }\n\n    run.times = c(run.times, gettime()); run.lbl = c(run.lbl, sprintf(\"%s completed\", Model.Name))\n    GetTimes(start.time,run.times,run.lbl,timefile,write.timefile,Model.Name)\n        \n    return(Results) #These have been cleared, and returning it saves me from re-creating the data frame (although maybe that would be faster?)\n    }\n",
    "created" : 1427810529753.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3145863413",
    "id" : "514D126F",
    "lastKnownWriteTime" : 1426613860,
    "path" : "C:/docs/beplants/Scripts/spatialdemography/R/simulation.r",
    "project_path" : "R/simulation.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}